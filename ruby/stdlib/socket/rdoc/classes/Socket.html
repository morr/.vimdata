<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html 
     PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
     "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>Class: Socket</title>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
  <meta http-equiv="Content-Script-Type" content="text/javascript" />
  <link rel="stylesheet" href=".././rdoc-style.css" type="text/css" media="screen" />
  <script type="text/javascript">
  // <![CDATA[

  function popupCode( url ) {
    window.open(url, "Code", "resizable=yes,scrollbars=yes,toolbar=no,status=no,height=150,width=400")
  }

  function toggleCode( id ) {
    if ( document.getElementById )
      elem = document.getElementById( id );
    else if ( document.all )
      elem = eval( "document.all." + id );
    else
      return false;

    elemStyle = elem.style;
    
    if ( elemStyle.display != "block" ) {
      elemStyle.display = "block"
    } else {
      elemStyle.display = "none"
    }

    return true;
  }
  
  // Make codeblocks hidden by default
  document.writeln( "<style type=\"text/css\">div.method-source-code { display: none }</style>" )
  
  // ]]>
  </script>

</head>
<body>



    <div id="classHeader">
        <table class="header-table">
        <tr class="top-aligned-row">
          <td><strong>Class</strong></td>
          <td class="class-name-in-header">Socket</td>
        </tr>
        <tr class="top-aligned-row">
            <td><strong>In:</strong></td>
            <td>
                <a href="../files/socket/socket_c.html">
                socket/socket.c
                </a>
        <br />
            </td>
        </tr>

        <tr class="top-aligned-row">
            <td><strong>Parent:</strong></td>
            <td>
                <a href="BasicSocket.html">
                BasicSocket
               </a>
            </td>
        </tr>
        </table>
    </div>
  <!-- banner header -->

  <div id="bodyContent">



  <div id="contextContent">

    <div id="description">
      <p>
Class <tt><a href="Socket.html">Socket</a></tt> provides access to the
underlying operating system socket implementations. It can be used to
provide more operating system specific functionality than the
protocol-specific socket classes but at the expense of greater complexity.
In particular, the class handles addresses using +struct sockaddr+
structures packed into Ruby strings, which can be a joy to manipulate.
</p>
<h3>Exception Handling</h3>
<p>
Ruby&#8216;s implementation of <tt><a href="Socket.html">Socket</a></tt>
causes an exception to be raised based on the error generated by the system
dependent implementation. This is why the methods are documented in a way
that isolate Unix-based system exceptions from Windows based exceptions. If
more information on particular exception is needed please refer to the Unix
manual pages or the Windows WinSock reference.
</p>
<h3>Documentation by</h3>
<ul>
<li>Zach Dennis

</li>
<li>Sam Roberts

</li>
<li><em>Programming Ruby</em> from The Pragmatic Bookshelf.

</li>
</ul>
<p>
Much material in this documentation is taken with permission from
<em>Programming Ruby</em> from The Pragmatic Bookshelf.
</p>

    </div>


   </div>

    <div id="method-list">
      <h3 class="section-bar">Methods</h3>

      <div class="name-list">
      <a href="#M001255">accept</a>&nbsp;&nbsp;
      <a href="#M001256">accept_nonblock</a>&nbsp;&nbsp;
      <a href="#M001253">bind</a>&nbsp;&nbsp;
      <a href="#M001251">connect</a>&nbsp;&nbsp;
      <a href="#M001252">connect_nonblock</a>&nbsp;&nbsp;
      <a href="#M001262">getaddrinfo</a>&nbsp;&nbsp;
      <a href="#M001260">gethostbyname</a>&nbsp;&nbsp;
      <a href="#M001261">getservbyname</a>&nbsp;&nbsp;
      <a href="#M001254">listen</a>&nbsp;&nbsp;
      <a href="#M001258">recvfrom</a>&nbsp;&nbsp;
      <a href="#M001259">recvfrom_nonblock</a>&nbsp;&nbsp;
      <a href="#M001257">sysaccept</a>&nbsp;&nbsp;
      </div>
    </div>

  </div>


    <!-- if includes -->

    <div id="section">

    <div id="class-list">
      <h3 class="section-bar">Classes and Modules</h3>

      Module <a href="Socket/Constants.html" class="link">Socket::Constants</a><br />

    </div>




      


    <!-- if method_list -->
    <div id="methods">
      <h3 class="section-bar">Public Class methods</h3>

      <div id="method-M001262" class="method-detail">
        <a name="M001262"></a>

        <div class="method-heading">
          <a href="#M001262" class="method-signature">
          <span class="method-name"> Socket.getaddrinfo(host, service, family=nil, socktype=nil, protocol=nil, flags=nil) => addrinfo<br />
</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Return address information for <tt>host</tt> and <tt>port</tt>. The
remaining arguments are hints that limit the address information returned.
</p>
<p>
This method corresponds closely to the POSIX.1g <a
href="Socket.html#M001262">getaddrinfo</a>() definition.
</p>
<h3>Parameters</h3>
<ul>
<li><tt>host</tt> is a host name or an address string (dotted decimal for IPv4,
or a hex string for IPv6) for which to return information. A nil is also
allowed, its meaning depends on <tt>flags</tt>, see below.

</li>
<li><tt>service</tt> is a service name (&quot;http&quot;, &quot;ssh&quot;,
&#8230;), or a port number (80, 22, &#8230;), see <a
href="Socket.html#M001261">Socket.getservbyname</a> for more information. A
nil is also allowed, meaning zero.

</li>
<li><tt>family</tt> limits the output to a specific address family, one of the
Socket::AF_* constants. Socket::AF_INET (IPv4) and Socket::AF_INET6 (IPv6)
are the most commonly used families. You will usually pass either nil or
Socket::AF_UNSPEC, allowing the IPv6 information to be returned first if
<tt>host</tt> is reachable via IPv6, and IPv4 information otherwise. The
two strings &quot;AF_INET&quot; or &quot;AF_INET6&quot; are also allowed,
they are converted to their respective Socket::AF_* constants.

</li>
<li><tt>socktype</tt> limits the output to a specific type of socket, one of
the Socket::SOCK_* constants. Socket::SOCK_STREAM (for TCP) and
Socket::SOCK_DGRAM (for UDP) are the most commonly used socket types. If
nil, then information for all types of sockets supported by
<tt>service</tt> will be returned. You will usually know what type of
socket you intend to create, and should pass that socket type in.

</li>
<li><tt>protocol</tt> limits the output to a specific protocol numpber, one of
the Socket::IPPROTO_* constants. It is usually implied by the socket type
(Socket::SOCK_STREAM =&gt; Socket::IPPROTO_TCP, &#8230;), if you pass other
than nil you already know what this is for.

</li>
<li><tt>flags</tt> is one of the Socket::AI_* constants. They mean:

<ul>
<li>Socket::AI_PASSIVE: when set, if <tt>host</tt> is nil the &#8216;any&#8217;
address will be returned, Socket::INADDR_ANY or 0 for IPv4,
&quot;0::0&quot; or &quot;::&quot; for IPv6. This address is suitable for
use by servers that will <a href="Socket.html#M001253">bind</a> their
socket and do a passive <a href="Socket.html#M001254">listen</a>, thus the
name of the flag. Otherwise the local or loopback address will be returned,
this is &quot;127.0.0.1&quot; for IPv4 and &quot;::1&#8217; for IPv6.

</li>
<li>&#8230;

</li>
</ul>
</li>
</ul>
<h3>Returns</h3>
<p>
Returns an array of arrays, where each subarray contains:
</p>
<ul>
<li>address family, a string like &quot;AF_INET&quot; or &quot;AF_INET6&quot;

</li>
<li>port number, the port number for <tt>service</tt>

</li>
<li>host name, either a canonical name for <tt>host</tt>, or it&#8216;s address
in presentation format if the address could not be looked up.

</li>
<li>host IP, the address of <tt>host</tt> in presentation format

</li>
<li>address family, as a numeric value (one of the Socket::AF_* constants).

</li>
<li>socket type, as a numeric value (one of the Socket::SOCK_* constants).

</li>
<li>protocol number, as a numeric value (one of the Socket::IPPROTO_*
constants).

</li>
</ul>
<p>
The first four values are identical to what is commonly returned as an
address array, see <a href="IPSocket.html">IPSocket</a> for more
information.
</p>
<h3>Examples</h3>
<p>
Not all input combinations are valid, and while there are many
combinations, only a few cases are common.
</p>
<p>
A typical client will call <a href="Socket.html#M001262">getaddrinfo</a>
with the <tt>host</tt> and <tt>service</tt> it wants to <a
href="Socket.html#M001251">connect</a> to. It knows that it will attempt to
<a href="Socket.html#M001251">connect</a> with either TCP or UDP, and
specifies <tt>socktype</tt> accordingly. It loops through all returned
addresses, and try to <a href="Socket.html#M001251">connect</a> to them in
turn:
</p>
<pre>
  addrinfo = Socket::getaddrinfo('www.example.com', 'www', nil, Socket::SOCK_STREAM)
  addrinfo.each do |af, port, name, addr|
    begin
      sock = TCPSocket.new(addr, port)
      # ...
      exit 1
    rescue
    end
  end
</pre>
<p>
With UDP you don&#8216;t know if <a href="Socket.html#M001251">connect</a>
suceeded, but if communication fails, the next address can be tried.
</p>
<p>
A typical server will call <a href="Socket.html#M001262">getaddrinfo</a>
with a <tt>host</tt> of nil, the <tt>service</tt> it listens to, and a
<tt>flags</tt> of Socket::AI_PASSIVE. It will <a
href="Socket.html#M001254">listen</a> for connections on the first returned
address:
</p>
<pre>
  addrinfo = Socket::getaddrinfo(nil, 'www', nil, Socket::SOCK_STREAM, nil, Socket::AI_PASSIVE)
  af, port, name, addr = addrinfo.first
  sock = TCPServer(addr, port)
  while( client = s.accept )
    # ...
  end
</pre>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001262-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001262-source">
<pre>
/*
 * Document-method: getaddrinfo
 * call-seq: Socket.getaddrinfo(host, service, family=nil, socktype=nil, protocol=nil, flags=nil) =&gt; addrinfo
 *
 * Return address information for +host+ and +port+. The remaining arguments
 * are hints that limit the address information returned.
 *
 * This method corresponds closely to the POSIX.1g getaddrinfo() definition.
 *
 * === Parameters
 * - +host+ is a host name or an address string (dotted decimal for IPv4, or a hex string
 *   for IPv6) for which to return information. A nil is also allowed, its meaning
 *   depends on +flags+, see below.
 * - +service+ is a service name (&quot;http&quot;, &quot;ssh&quot;, ...), or 
 *   a port number (80, 22, ...), see Socket.getservbyname for more
 *   information. A nil is also allowed, meaning zero.
 * - +family+ limits the output to a specific address family, one of the
 *   Socket::AF_* constants. Socket::AF_INET (IPv4) and Socket::AF_INET6 (IPv6)
 *   are the most commonly used families. You will usually pass either nil or
 *   Socket::AF_UNSPEC, allowing the IPv6 information to be returned first if
 *   +host+ is reachable via IPv6, and IPv4 information otherwise.  The two
 *   strings &quot;AF_INET&quot; or &quot;AF_INET6&quot; are also allowed, they are converted to
 *   their respective Socket::AF_* constants.
 * - +socktype+ limits the output to a specific type of socket, one of the
 *   Socket::SOCK_* constants. Socket::SOCK_STREAM (for TCP) and
 *   Socket::SOCK_DGRAM (for UDP) are the most commonly used socket types. If
 *   nil, then information for all types of sockets supported by +service+ will
 *   be returned. You will usually know what type of socket you intend to
 *   create, and should pass that socket type in.
 * - +protocol+ limits the output to a specific protocol numpber, one of the
 *   Socket::IPPROTO_* constants. It is usually implied by the socket type
 *   (Socket::SOCK_STREAM =&gt; Socket::IPPROTO_TCP, ...), if you pass other than
 *   nil you already know what this is for.
 * - +flags+ is one of the Socket::AI_* constants. They mean:
 *   - Socket::AI_PASSIVE: when set, if +host+ is nil the 'any' address will be
 *     returned, Socket::INADDR_ANY or 0 for IPv4, &quot;0::0&quot; or &quot;::&quot; for IPv6.  This
 *     address is suitable for use by servers that will bind their socket and do
 *     a passive listen, thus the name of the flag. Otherwise the local or
 *     loopback address will be returned, this is &quot;127.0.0.1&quot; for IPv4 and &quot;::1'
 *     for IPv6.
 *   - ...
 *
 *
 * === Returns
 *
 * Returns an array of arrays, where each subarray contains:
 * - address family, a string like &quot;AF_INET&quot; or &quot;AF_INET6&quot;
 * - port number, the port number for +service+
 * - host name, either a canonical name for +host+, or it's address in presentation
 *   format if the address could not be looked up.
 * - host IP, the address of +host+ in presentation format
 * - address family, as a numeric value (one of the Socket::AF_* constants).
 * - socket type, as a numeric value (one of the Socket::SOCK_* constants).
 * - protocol number, as a numeric value (one of the Socket::IPPROTO_* constants).
 *
 * The first four values are identical to what is commonly returned as an
 * address array, see IPSocket for more information.
 *
 * === Examples
 *
 * Not all input combinations are valid, and while there are many combinations,
 * only a few cases are common.
 *
 * A typical client will call getaddrinfo with the +host+ and +service+ it
 * wants to connect to. It knows that it will attempt to connect with either
 * TCP or UDP, and specifies +socktype+ accordingly. It loops through all
 * returned addresses, and try to connect to them in turn:
 *
 *   addrinfo = Socket::getaddrinfo('www.example.com', 'www', nil, Socket::SOCK_STREAM)
 *   addrinfo.each do |af, port, name, addr|
 *     begin
 *       sock = TCPSocket.new(addr, port)
 *       # ...
 *       exit 1
 *     rescue
 *     end
 *   end
 *
 * With UDP you don't know if connect suceeded, but if communication fails,
 * the next address can be tried.
 *
 * A typical server will call getaddrinfo with a +host+ of nil, the +service+
 * it listens to, and a +flags+ of Socket::AI_PASSIVE. It will listen for
 * connections on the first returned address:
 *   addrinfo = Socket::getaddrinfo(nil, 'www', nil, Socket::SOCK_STREAM, nil, Socket::AI_PASSIVE)
 *   af, port, name, addr = addrinfo.first
 *   sock = TCPServer(addr, port)
 *   while( client = s.accept )
 *     # ...
 *   end
 */
static VALUE
sock_s_getaddrinfo(argc, argv)
    int argc;
    VALUE *argv;
{
    VALUE host, port, family, socktype, protocol, flags, ret;
    char hbuf[1024], pbuf[1024];
    char *hptr, *pptr, *ap;
    struct addrinfo hints, *res;
    int error;

    host = port = family = socktype = protocol = flags = Qnil;
    rb_scan_args(argc, argv, &quot;24&quot;, &amp;host, &amp;port, &amp;family, &amp;socktype, &amp;protocol, &amp;flags);
    if (NIL_P(host)) {
        hptr = NULL;
    }
    else {
        strncpy(hbuf, StringValuePtr(host), sizeof(hbuf));
        hbuf[sizeof(hbuf) - 1] = '\0';
        hptr = hbuf;
    }
    if (NIL_P(port)) {
        pptr = NULL;
    }
    else if (FIXNUM_P(port)) {
        snprintf(pbuf, sizeof(pbuf), &quot;%ld&quot;, FIX2LONG(port));
        pptr = pbuf;
    }
    else {
        strncpy(pbuf, StringValuePtr(port), sizeof(pbuf));
        pbuf[sizeof(pbuf) - 1] = '\0';
        pptr = pbuf;
    }

    MEMZERO(&amp;hints, struct addrinfo, 1);
    if (NIL_P(family)) {
        hints.ai_family = PF_UNSPEC;
    }
    else if (FIXNUM_P(family)) {
        hints.ai_family = FIX2INT(family);
    }
    else if ((ap = StringValuePtr(family)) != 0) {
        if (strcmp(ap, &quot;AF_INET&quot;) == 0) {
            hints.ai_family = PF_INET;
        }
#ifdef INET6
        else if (strcmp(ap, &quot;AF_INET6&quot;) == 0) {
            hints.ai_family = PF_INET6;
        }
#endif
    }

    if (!NIL_P(socktype)) {
        hints.ai_socktype = NUM2INT(socktype);
    }
    if (!NIL_P(protocol)) {
        hints.ai_protocol = NUM2INT(protocol);
    }
    if (!NIL_P(flags)) {
        hints.ai_flags = NUM2INT(flags);
    }
    error = getaddrinfo(hptr, pptr, &amp;hints, &amp;res);
    if (error) {
        rb_raise(rb_eSocket, &quot;getaddrinfo: %s&quot;, gai_strerror(error));
    }

    ret = make_addrinfo(res);
    freeaddrinfo(res);
    return ret;
}
</pre>
          </div>
        </div>
      </div>

      <div id="method-M001260" class="method-detail">
        <a name="M001260"></a>

        <div class="method-heading">
          <a href="#M001260" class="method-signature">
          <span class="method-name"> Socket.gethostbyname(host) => hostent<br />
</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Resolve <tt>host</tt> and return name and address information for it,
similarly to <a href="Socket.html#M001260">gethostbyname</a>(3).
<tt>host</tt> can be a domain name or the presentation format of an
address.
</p>
<p>
Returns an array of information similar to that found in a +struct
hostent+:
</p>
<pre>
  - cannonical name: the cannonical name for host in the DNS, or a
    string representing the address
  - aliases: an array of aliases for the canonical name, there may be no aliases
  - address family: usually one of Socket::AF_INET or Socket::AF_INET6
  - address: a string, the binary value of the +struct sockaddr+ for this name, in
    the indicated address family
  - ...: if there are multiple addresses for this host,  a series of
    strings/+struct sockaddr+s may follow, not all necessarily in the same
    address family. Note that the fact that they may not be all in the same
    address family is a departure from the behaviour of gethostbyname(3).
</pre>
<p>
Note: I believe that the fact that the multiple addresses returned are not
necessarily in the same address family may be a bug, since if this function
actually called <a href="Socket.html#M001260">gethostbyname</a>(3), ALL the
addresses returned in the trailing address list (h_addr_list from struct
hostent) would be of the same address family! Examples from my system, OS X
10.3:
</p>
<pre>
  [&quot;localhost&quot;, [], 30, &quot;\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001&quot;, &quot;\177\000\000\001&quot;]
    and
  [&quot;ensemble.local&quot;, [], 30, &quot;\376\200\000\004\000\000\000\000\002\003\223\377\376\255\010\214&quot;, &quot;\300\250{\232&quot; ]
</pre>
<p>
Similar information can be returned by <a
href="Socket.html#M001262">Socket.getaddrinfo</a> if called as:
</p>
<pre>
   Socket.getaddrinfo(+host+, 0, Socket::AF_UNSPEC, Socket::SOCK_STREAM, nil, Socket::AI_CANONNAME)
</pre>
<h2>Examples</h2>
<pre>
  Socket.gethostbyname &quot;example.com&quot;
  =&gt; [&quot;example.com&quot;, [], 2, &quot;\300\000\&quot;\246&quot;]
</pre>
<p>
This name has no DNS aliases, and a single IPv4 address.
</p>
<pre>
  Socket.gethostbyname &quot;smtp.telus.net&quot;
  =&gt; [&quot;smtp.svc.telus.net&quot;, [&quot;smtp.telus.net&quot;], 2, &quot;\307\271\334\371&quot;]
</pre>
<p>
This name is an an alias so the canonical name is returned, as well as the
alias and a single IPv4 address.
</p>
<pre>
  Socket.gethostbyname &quot;localhost&quot;
  =&gt; [&quot;localhost&quot;, [], 30, &quot;\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001&quot;, &quot;\177\000\000\001&quot;]
</pre>
<p>
This machine has no aliases, returns an IPv6 address, and has an additional
IPv4 address.
</p>
<p>
<tt>host</tt> can also be an IP address in presentation format, in which
case a reverse lookup is done on the address:
</p>
<pre>
  Socket.gethostbyname(&quot;127.0.0.1&quot;)
  =&gt; [&quot;localhost&quot;, [], 2, &quot;\177\000\000\001&quot;]

  Socket.gethostbyname(&quot;192.0.34.166&quot;)
  =&gt; [&quot;www.example.com&quot;, [], 2, &quot;\300\000\&quot;\246&quot;]
</pre>
<h2>See</h2>
<p>
See: <a href="Socket.html#M001262">Socket.getaddrinfo</a>
</p>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001260-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001260-source">
<pre>
/*
 * Document-method: gethostbyname
 * call-seq: Socket.gethostbyname(host) =&gt; hostent
 *
 * Resolve +host+ and return name and address information for it, similarly to
 * gethostbyname(3). +host+ can be a domain name or the presentation format of
 * an address.
 *
 * Returns an array of information similar to that found in a +struct hostent+:
 *   - cannonical name: the cannonical name for host in the DNS, or a
 *     string representing the address
 *   - aliases: an array of aliases for the canonical name, there may be no aliases
 *   - address family: usually one of Socket::AF_INET or Socket::AF_INET6
 *   - address: a string, the binary value of the +struct sockaddr+ for this name, in
 *     the indicated address family
 *   - ...: if there are multiple addresses for this host,  a series of
 *     strings/+struct sockaddr+s may follow, not all necessarily in the same
 *     address family. Note that the fact that they may not be all in the same
 *     address family is a departure from the behaviour of gethostbyname(3).
 *
 * Note: I believe that the fact that the multiple addresses returned are not
 * necessarily in the same address family may be a bug, since if this function
 * actually called gethostbyname(3), ALL the addresses returned in the trailing
 * address list (h_addr_list from struct hostent) would be of the same address
 * family!  Examples from my system, OS X 10.3:
 *
 *   [&quot;localhost&quot;, [], 30, &quot;\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001&quot;, &quot;\177\000\000\001&quot;]
 *     and
 *   [&quot;ensemble.local&quot;, [], 30, &quot;\376\200\000\004\000\000\000\000\002\003\223\377\376\255\010\214&quot;, &quot;\300\250{\232&quot; ]
 *
 * Similar information can be returned by Socket.getaddrinfo if called as:
 *
 *    Socket.getaddrinfo(+host+, 0, Socket::AF_UNSPEC, Socket::SOCK_STREAM, nil, Socket::AI_CANONNAME)
 *
 * == Examples
 *   
 *   Socket.gethostbyname &quot;example.com&quot;                                                           
 *   =&gt; [&quot;example.com&quot;, [], 2, &quot;\300\000\&quot;\246&quot;]
 *   
 * This name has no DNS aliases, and a single IPv4 address.
 *   
 *   Socket.gethostbyname &quot;smtp.telus.net&quot;
 *   =&gt; [&quot;smtp.svc.telus.net&quot;, [&quot;smtp.telus.net&quot;], 2, &quot;\307\271\334\371&quot;]
 *   
 * This name is an an alias so the canonical name is returned, as well as the
 * alias and a single IPv4 address.
 *   
 *   Socket.gethostbyname &quot;localhost&quot;
 *   =&gt; [&quot;localhost&quot;, [], 30, &quot;\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001&quot;, &quot;\177\000\000\001&quot;]
 *   
 * This machine has no aliases, returns an IPv6 address, and has an additional IPv4 address.
 *
 * +host+ can also be an IP address in presentation format, in which case a
 * reverse lookup is done on the address:
 *
 *   Socket.gethostbyname(&quot;127.0.0.1&quot;)
 *   =&gt; [&quot;localhost&quot;, [], 2, &quot;\177\000\000\001&quot;]
 *
 *   Socket.gethostbyname(&quot;192.0.34.166&quot;)
 *   =&gt; [&quot;www.example.com&quot;, [], 2, &quot;\300\000\&quot;\246&quot;]
 *
 *
 * == See
 * See: Socket.getaddrinfo
 */
static VALUE
sock_s_gethostbyname(obj, host)
    VALUE obj, host;
{
    rb_secure(3);
    return make_hostent(host, sock_addrinfo(host, Qnil, SOCK_STREAM, AI_CANONNAME), sock_sockaddr);
}
</pre>
          </div>
        </div>
      </div>

      <div id="method-M001261" class="method-detail">
        <a name="M001261"></a>

        <div class="method-heading">
          <a href="#M001261" class="method-signature">
          <span class="method-name"> Socket.getservbyname(name, proto="tcp") => port<br />
</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
<tt>name</tt> is a service name (&quot;ftp&quot;, &quot;telnet&quot;,
&#8230;) and proto is a protocol name (&quot;udp&quot;, &quot;tcp&quot;,
&#8230;). &#8217;/etc/services&#8217; (or your system&#8216;s equivalent)
is searched for a service for <tt>name</tt> and <tt>proto</tt>, and the
port number is returned.
</p>
<p>
Note that unlike <a href="Socket.html#M001262">Socket.getaddrinfo</a>,
<tt>proto</tt> may not be specified using the Socket::SOCK_* constants, a
string must must be used.
</p>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001261-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001261-source">
<pre>
/*
 * Document-method: getservbyname
 * call-seq: Socket.getservbyname(name, proto=&quot;tcp&quot;) =&gt; port
 *
 * +name+ is a service name (&quot;ftp&quot;, &quot;telnet&quot;, ...) and proto is a protocol name
 * (&quot;udp&quot;, &quot;tcp&quot;, ...). '/etc/services' (or your system's equivalent) is
 * searched for a service for +name+ and +proto+, and the port number is
 * returned.
 *
 * Note that unlike Socket.getaddrinfo, +proto+ may not be specified using the
 * Socket::SOCK_* constants, a string must must be used.
 */
static VALUE
sock_s_getservbyaname(argc, argv)
    int argc;
    VALUE *argv;
{
    VALUE service, proto;
    struct servent *sp;
    int port;

    rb_scan_args(argc, argv, &quot;11&quot;, &amp;service, &amp;proto);
    if (NIL_P(proto)) proto = rb_str_new2(&quot;tcp&quot;);
    StringValue(service);
    StringValue(proto);

    sp = getservbyname(StringValueCStr(service),  StringValueCStr(proto));
    if (sp) {
        port = ntohs(sp-&gt;s_port);
    }
    else {
        char *s = RSTRING(service)-&gt;ptr;
        char *end;

        port = strtoul(s, &amp;end, 0);
        if (*end != '\0') {
            rb_raise(rb_eSocket, &quot;no such service %s/%s&quot;, s, RSTRING(proto)-&gt;ptr);
        }
    }
    return INT2FIX(port);
}
</pre>
          </div>
        </div>
      </div>

      <h3 class="section-bar">Public Instance methods</h3>

      <div id="method-M001255" class="method-detail">
        <a name="M001255"></a>

        <div class="method-heading">
          <a href="#M001255" class="method-signature">
          <span class="method-name">socket.accept => [ socket, string ]<br />
</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Accepts an incoming connection returning an array containing a new <a
href="Socket.html">Socket</a> object and a string holding the
<tt>struct</tt> sockaddr information about the caller.
</p>
<h3>Example</h3>
<pre>
     # In one script, start this first
     require 'socket'
     include Socket::Constants
     socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
     sockaddr = Socket.pack_sockaddr_in( 2200, 'localhost' )
     socket.bind( sockaddr )
     socket.listen( 5 )
     client, client_sockaddr = socket.accept
     puts &quot;The client said, '#{client.readline.chomp}'&quot;
     client.puts &quot;Hello from script one!&quot;
     socket.close

     # In another script, start this second
     require 'socket'
     include Socket::Constants
     socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
     sockaddr = Socket.pack_sockaddr_in( 2200, 'localhost' )
     socket.connect( sockaddr )
     socket.puts &quot;Hello from script 2.&quot;
     puts &quot;The server said, '#{socket.readline.chomp}'&quot;
     socket.close
</pre>
<h3>Unix-based Exceptions</h3>
<p>
On unix-based based systems the following system exceptions may be raised
if the call to <em><a href="Socket.html#M001255">accept</a></em> fails:
</p>
<ul>
<li>Errno::EAGAIN - O_NONBLOCK is set for the <tt>socket</tt> file descriptor
and no connections are parent to be accepted

</li>
<li>Errno::EWOULDBLOCK - same as Errno::EAGAIN

</li>
<li>Errno::EBADF - the <tt>socket</tt> is not a valid file descriptor

</li>
<li>Errno::ECONNABORTED - a connection has been aborted

</li>
<li>Errno::EFAULT - the socket&#8216;s internal address or address length
parameter cannot be access or written

</li>
<li>Errno::EINTR - the <em><a href="Socket.html#M001255">accept</a></em> method
was interrupted by a signal that was caught before a valid connection
arrived

</li>
<li>Errno::EINVAL - the <tt>socket</tt> is not accepting connections

</li>
<li>Errno::EMFILE - OPEN_MAX file descriptors are currently open in the calling
process

</li>
<li>Errno::ENOBUFS - no buffer space is available

</li>
<li>Errno::ENOMEM - there was insufficient memory available to complete the
operation

</li>
<li>Errno::ENOSR - there was insufficient STREAMS resources available to
complete the operation

</li>
<li>Errno::ENFILE - the maximum number of file descriptors in the system are
already open

</li>
<li>Errno::ENOTSOCK - the <tt>socket</tt> does not refer to a socket

</li>
<li>Errno::EOPNOTSUPP - the socket type for the calling <tt>socket</tt> does
not support <a href="Socket.html#M001255">accept</a> connections

</li>
<li>Errno::EPROTO - a protocol error has occurred

</li>
</ul>
<h3>Windows Exceptions</h3>
<p>
On Windows systems the following system exceptions may be raised if the
call to <em><a href="Socket.html#M001255">accept</a></em> fails:
</p>
<ul>
<li>Errno::ECONNRESET - an incoming connection was indicated, but was
terminated by the remote peer prior to accepting the connection

</li>
<li>Errno::EFAULT - the socket&#8216;s internal address or address length
parameter is too small or is not a valid part of the user space address

</li>
<li>Errno::EINVAL - the <em><a href="Socket.html#M001254">listen</a></em>
method was not invoked prior to calling <em><a
href="Socket.html#M001255">accept</a></em>

</li>
<li>Errno::EINPROGRESS - a blocking Windows Sockets 1.1 call is in progress or
the service provider is still processing a callback function

</li>
<li>Errno::EMFILE - the queue is not empty, upong etry to <em><a
href="Socket.html#M001255">accept</a></em> and there are no socket
descriptors available

</li>
<li>Errno::ENETDOWN - the network is down

</li>
<li>Errno::ENOBUFS - no buffer space is available

</li>
<li>Errno::ENOTSOCK - <tt>socket</tt> is not a socket

</li>
<li>Errno::EOPNOTSUPP - <tt>socket</tt> is not a type that supports
connection-oriented service.

</li>
<li>Errno::EWOULDBLOCK - <tt>socket</tt> is marked as nonblocking and no
connections are present to be accepted

</li>
</ul>
<h3>See</h3>
<ul>
<li><a href="Socket.html#M001255">accept</a> manual pages on unix-based systems

</li>
<li><a href="Socket.html#M001255">accept</a> function in Microsoft&#8216;s
Winsock functions reference

</li>
</ul>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001255-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001255-source">
<pre>
/*
 * call-seq:
 *      socket.accept =&gt; [ socket, string ]
 * 
 * Accepts an incoming connection returning an array containing a new
 * Socket object and a string holding the +struct+ sockaddr information about 
 * the caller.
 * 
 * === Example
 *      # In one script, start this first
 *      require 'socket'
 *      include Socket::Constants
 *      socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
 *      sockaddr = Socket.pack_sockaddr_in( 2200, 'localhost' )
 *      socket.bind( sockaddr )
 *      socket.listen( 5 )
 *      client, client_sockaddr = socket.accept
 *      puts &quot;The client said, '#{client.readline.chomp}'&quot;
 *      client.puts &quot;Hello from script one!&quot;
 *      socket.close
 * 
 *      # In another script, start this second
 *      require 'socket'
 *      include Socket::Constants
 *      socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
 *      sockaddr = Socket.pack_sockaddr_in( 2200, 'localhost' )
 *      socket.connect( sockaddr )
 *      socket.puts &quot;Hello from script 2.&quot; 
 *      puts &quot;The server said, '#{socket.readline.chomp}'&quot;
 *      socket.close 
 * 
 * === Unix-based Exceptions
 * On unix-based based systems the following system exceptions may be raised if the
 * call to _accept_ fails:
 * * Errno::EAGAIN - O_NONBLOCK is set for the +socket+ file descriptor and no 
 *   connections are parent to be accepted
 * * Errno::EWOULDBLOCK - same as Errno::EAGAIN
 * * Errno::EBADF - the +socket+ is not a valid file descriptor
 * * Errno::ECONNABORTED - a connection has been aborted
 * * Errno::EFAULT - the socket's internal address or address length parameter 
 *   cannot be access or written
 * * Errno::EINTR - the _accept_ method was interrupted by a signal that was 
 *   caught before a valid connection arrived
 * * Errno::EINVAL - the +socket+ is not accepting connections
 * * Errno::EMFILE - OPEN_MAX file descriptors are currently open in the calling 
 *   process
 * * Errno::ENOBUFS - no buffer space is available
 * * Errno::ENOMEM - there was insufficient memory available to complete the
 *   operation
 * * Errno::ENOSR - there was insufficient STREAMS resources available to 
 *   complete the operation
 * * Errno::ENFILE - the maximum number of file descriptors in the system are 
 *   already open
 * * Errno::ENOTSOCK - the +socket+ does not refer to a socket
 * * Errno::EOPNOTSUPP - the socket type for the calling +socket+ does not 
 *   support accept connections
 * * Errno::EPROTO - a protocol error has occurred
 * 
 * === Windows Exceptions
 * On Windows systems the following system exceptions may be raised if 
 * the call to _accept_ fails:
 * * Errno::ECONNRESET - an incoming connection was indicated, but was 
 *   terminated by the remote peer prior to accepting the connection
 * * Errno::EFAULT - the socket's internal address or address length parameter
 *   is too small or is not a valid part of the user space address
 * * Errno::EINVAL - the _listen_ method was not invoked prior to calling _accept_
 * * Errno::EINPROGRESS - a blocking Windows Sockets 1.1 call is in progress or
 *   the service provider is still processing a callback function
 * * Errno::EMFILE - the queue is not empty, upong etry to _accept_ and there are
 *   no socket descriptors available
 * * Errno::ENETDOWN - the network is down
 * * Errno::ENOBUFS - no buffer space is available
 * * Errno::ENOTSOCK - +socket+ is not a socket
 * * Errno::EOPNOTSUPP - +socket+ is not a type that supports connection-oriented
 *   service.
 * * Errno::EWOULDBLOCK - +socket+ is marked as nonblocking and no connections are
 *   present to be accepted
 * 
 * === See
 * * accept manual pages on unix-based systems
 * * accept function in Microsoft's Winsock functions reference
 */
static VALUE
sock_accept(sock)
    VALUE sock;
{
    OpenFile *fptr;
    VALUE sock2;
    char buf[1024];
    socklen_t len = sizeof buf;

    GetOpenFile(sock, fptr);
    sock2 = s_accept(rb_cSocket,fileno(fptr-&gt;f),(struct sockaddr*)buf,&amp;len);

    return rb_assoc_new(sock2, rb_str_new(buf, len));
}
</pre>
          </div>
        </div>
      </div>

      <div id="method-M001256" class="method-detail">
        <a name="M001256"></a>

        <div class="method-heading">
          <a href="#M001256" class="method-signature">
          <span class="method-name">socket.accept_nonblock => [client_socket, client_sockaddr]<br />
</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Accepts an incoming connection using <a
href="Socket.html#M001255">accept</a>(2) after O_NONBLOCK is set for the
underlying file descriptor. It returns an array containg the accpeted
socket for the incoming connection, <em>client_socket</em>, and a string
that contains the <tt>struct</tt> sockaddr information about the caller,
<em>client_sockaddr</em>.
</p>
<h3>Example</h3>
<pre>
     # In one script, start this first
     require 'socket'
     include Socket::Constants
     socket = Socket.new(AF_INET, SOCK_STREAM, 0)
     sockaddr = Socket.sockaddr_in(2200, 'localhost')
     socket.bind(sockaddr)
     socket.listen(5)
     begin
       client_socket, client_sockaddr = socket.accept_nonblock
     rescue Errno::EAGAIN, Errno::ECONNABORTED, Errno::EPROTO, Errno::EINTR
       IO.select([socket])
       retry
     end
     puts &quot;The client said, '#{client_socket.readline.chomp}'&quot;
     client_socket.puts &quot;Hello from script one!&quot;
     socket.close

     # In another script, start this second
     require 'socket'
     include Socket::Constants
     socket = Socket.new(AF_INET, SOCK_STREAM, 0)
     sockaddr = Socket.sockaddr_in(2200, 'localhost')
     socket.connect(sockaddr)
     socket.puts &quot;Hello from script 2.&quot;
     puts &quot;The server said, '#{socket.readline.chomp}'&quot;
     socket.close
</pre>
<p>
Refer to <a href="Socket.html#M001255">Socket#accept</a> for the exceptions
that may be thrown if the call to <em><a
href="Socket.html#M001256">accept_nonblock</a></em> fails.
</p>
<p>
<a href="Socket.html#M001256">Socket#accept_nonblock</a> may raise any
error corresponding to <a href="Socket.html#M001255">accept</a>(2) failure,
including Errno::EAGAIN.
</p>
<h3>See</h3>
<ul>
<li><a href="Socket.html#M001255">Socket#accept</a>

</li>
</ul>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001256-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001256-source">
<pre>
/*
 * call-seq:
 *    socket.accept_nonblock =&gt; [client_socket, client_sockaddr]
 * 
 * Accepts an incoming connection using accept(2) after
 * O_NONBLOCK is set for the underlying file descriptor.
 * It returns an array containg the accpeted socket
 * for the incoming connection, _client_socket_,
 * and a string that contains the +struct+ sockaddr information
 * about the caller, _client_sockaddr_.
 * 
 * === Example
 *      # In one script, start this first
 *      require 'socket'
 *      include Socket::Constants
 *      socket = Socket.new(AF_INET, SOCK_STREAM, 0)
 *      sockaddr = Socket.sockaddr_in(2200, 'localhost')
 *      socket.bind(sockaddr)
 *      socket.listen(5)
 *      begin
 *        client_socket, client_sockaddr = socket.accept_nonblock
 *      rescue Errno::EAGAIN, Errno::ECONNABORTED, Errno::EPROTO, Errno::EINTR
 *        IO.select([socket])
 *        retry
 *      end
 *      puts &quot;The client said, '#{client_socket.readline.chomp}'&quot;
 *      client_socket.puts &quot;Hello from script one!&quot;
 *      socket.close
 *
 *      # In another script, start this second
 *      require 'socket'
 *      include Socket::Constants
 *      socket = Socket.new(AF_INET, SOCK_STREAM, 0)
 *      sockaddr = Socket.sockaddr_in(2200, 'localhost')
 *      socket.connect(sockaddr)
 *      socket.puts &quot;Hello from script 2.&quot; 
 *      puts &quot;The server said, '#{socket.readline.chomp}'&quot;
 *      socket.close
 * 
 * Refer to Socket#accept for the exceptions that may be thrown if the call
 * to _accept_nonblock_ fails. 
 *
 * Socket#accept_nonblock may raise any error corresponding to accept(2) failure,
 * including Errno::EAGAIN.
 * 
 * === See
 * * Socket#accept
 */
static VALUE
sock_accept_nonblock(sock)
    VALUE sock;
{
    OpenFile *fptr;
    VALUE sock2;
    char buf[1024];
    socklen_t len = sizeof buf;

    GetOpenFile(sock, fptr);
    sock2 = s_accept_nonblock(rb_cSocket, fptr, (struct sockaddr *)buf, &amp;len);
    return rb_assoc_new(sock2, rb_str_new(buf, len));
}
</pre>
          </div>
        </div>
      </div>

      <div id="method-M001253" class="method-detail">
        <a name="M001253"></a>

        <div class="method-heading">
          <a href="#M001253" class="method-signature">
          <span class="method-name">socket.bind(server_sockaddr) => 0<br />
</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Binds to the given <tt>struct</tt> sockaddr.
</p>
<h3>Parameter</h3>
<ul>
<li><tt>server_sockaddr</tt> - the <tt>struct</tt> sockaddr contained in a
string

</li>
</ul>
<h3>Example</h3>
<pre>
     require 'socket'
     include Socket::Constants
     socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
     sockaddr = Socket.pack_sockaddr_in( 2200, 'localhost' )
     socket.bind( sockaddr )
</pre>
<h3>Unix-based Exceptions</h3>
<p>
On unix-based based systems the following system exceptions may be raised
if the call to <em><a href="Socket.html#M001253">bind</a></em> fails:
</p>
<ul>
<li>Errno::EACCES - the specified <em>sockaddr</em> is protected and the
current user does not have permission to <a
href="Socket.html#M001253">bind</a> to it

</li>
<li>Errno::EADDRINUSE - the specified <em>sockaddr</em> is already in use

</li>
<li>Errno::EADDRNOTAVAIL - the specified <em>sockaddr</em> is not available
from the local machine

</li>
<li>Errno::EAFNOSUPPORT - the specified <em>sockaddr</em> isnot a valid address
for the family of the calling <tt>socket</tt>

</li>
<li>Errno::EBADF - the <em>sockaddr</em> specified is not a valid file
descriptor

</li>
<li>Errno::EFAULT - the <em>sockaddr</em> argument cannot be accessed

</li>
<li>Errno::EINVAL - the <tt>socket</tt> is already bound to an address, and the
protocol does not support binding to the new <em>sockaddr</em> or the
<tt>socket</tt> has been shut down.

</li>
<li>Errno::EINVAL - the address length is not a valid length for the address
family

</li>
<li>Errno::ENAMETOOLONG - the pathname resolved had a length which exceeded
PATH_MAX

</li>
<li>Errno::ENOBUFS - no buffer space is available

</li>
<li>Errno::ENOSR - there were insufficient STREAMS resources available to
complete the operation

</li>
<li>Errno::ENOTSOCK - the <tt>socket</tt> does not refer to a socket

</li>
<li>Errno::EOPNOTSUPP - the socket type of the <tt>socket</tt> does not support
binding to an address

</li>
</ul>
<p>
On unix-based based systems if the address family of the calling
<tt>socket</tt> is Socket::AF_UNIX the follow exceptions may be raised if
the call to <em><a href="Socket.html#M001253">bind</a></em> fails:
</p>
<ul>
<li>Errno::EACCES - search permission is denied for a component of the prefix
path or write access to the <tt>socket</tt> is denided

</li>
<li>Errno::EDESTADDRREQ - the <em>sockaddr</em> argument is a null pointer

</li>
<li>Errno::EISDIR - same as Errno::EDESTADDRREQ

</li>
<li>Errno::EIO - an i/o error occurred

</li>
<li>Errno::ELOOP - too many symbolic links were encountered in translating the
pathname in <em>sockaddr</em>

</li>
<li>Errno::ENAMETOOLLONG - a component of a pathname exceeded NAME_MAX
characters, or an entired pathname exceeded PATH_MAX characters

</li>
<li>Errno::ENOENT - a component of the pathname does not name an existing file
or the pathname is an empty string

</li>
<li>Errno::ENOTDIR - a component of the path prefix of the pathname in
<em>sockaddr</em> is not a directory

</li>
<li>Errno::EROFS - the name would reside on a read only filesystem

</li>
</ul>
<h3>Windows Exceptions</h3>
<p>
On Windows systems the following system exceptions may be raised if the
call to <em><a href="Socket.html#M001253">bind</a></em> fails:
</p>
<ul>
<li>Errno::ENETDOWN&#8212; the network is down

</li>
<li>Errno::EACCES - the attempt to <a href="Socket.html#M001251">connect</a>
the datagram socket to the broadcast address failed

</li>
<li>Errno::EADDRINUSE - the socket&#8216;s local address is already in use

</li>
<li>Errno::EADDRNOTAVAIL - the specified address is not a valid address for
this computer

</li>
<li>Errno::EFAULT - the socket&#8216;s internal address or address length
parameter is too small or is not a valid part of the user space addressed

</li>
<li>Errno::EINVAL - the <tt>socket</tt> is already bound to an address

</li>
<li>Errno::ENOBUFS - no buffer space is available

</li>
<li>Errno::ENOTSOCK - the <tt>socket</tt> argument does not refer to a socket

</li>
</ul>
<h3>See</h3>
<ul>
<li><a href="Socket.html#M001253">bind</a> manual pages on unix-based systems

</li>
<li><a href="Socket.html#M001253">bind</a> function in Microsoft&#8216;s
Winsock functions reference

</li>
</ul>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001253-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001253-source">
<pre>
/*
 * call-seq:
 *      socket.bind(server_sockaddr) =&gt; 0
 * 
 * Binds to the given +struct+ sockaddr.
 * 
 * === Parameter
 * * +server_sockaddr+ - the +struct+ sockaddr contained in a string
 *
 * === Example
 *      require 'socket'
 *      include Socket::Constants
 *      socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
 *      sockaddr = Socket.pack_sockaddr_in( 2200, 'localhost' )
 *      socket.bind( sockaddr )
 *  
 * === Unix-based Exceptions
 * On unix-based based systems the following system exceptions may be raised if 
 * the call to _bind_ fails:
 * * Errno::EACCES - the specified _sockaddr_ is protected and the current
 *   user does not have permission to bind to it
 * * Errno::EADDRINUSE - the specified _sockaddr_ is already in use
 * * Errno::EADDRNOTAVAIL - the specified _sockaddr_ is not available from the
 *   local machine
 * * Errno::EAFNOSUPPORT - the specified _sockaddr_ isnot a valid address for
 *   the family of the calling +socket+
 * * Errno::EBADF - the _sockaddr_ specified is not a valid file descriptor
 * * Errno::EFAULT - the _sockaddr_ argument cannot be accessed
 * * Errno::EINVAL - the +socket+ is already bound to an address, and the 
 *   protocol does not support binding to the new _sockaddr_ or the +socket+
 *   has been shut down.
 * * Errno::EINVAL - the address length is not a valid length for the address
 *   family
 * * Errno::ENAMETOOLONG - the pathname resolved had a length which exceeded
 *   PATH_MAX
 * * Errno::ENOBUFS - no buffer space is available
 * * Errno::ENOSR - there were insufficient STREAMS resources available to 
 *   complete the operation
 * * Errno::ENOTSOCK - the +socket+ does not refer to a socket
 * * Errno::EOPNOTSUPP - the socket type of the +socket+ does not support 
 *   binding to an address
 * 
 * On unix-based based systems if the address family of the calling +socket+ is
 * Socket::AF_UNIX the follow exceptions may be raised if the call to _bind_
 * fails:
 * * Errno::EACCES - search permission is denied for a component of the prefix
 *   path or write access to the +socket+ is denided
 * * Errno::EDESTADDRREQ - the _sockaddr_ argument is a null pointer
 * * Errno::EISDIR - same as Errno::EDESTADDRREQ
 * * Errno::EIO - an i/o error occurred
 * * Errno::ELOOP - too many symbolic links were encountered in translating
 *   the pathname in _sockaddr_
 * * Errno::ENAMETOOLLONG - a component of a pathname exceeded NAME_MAX 
 *   characters, or an entired pathname exceeded PATH_MAX characters
 * * Errno::ENOENT - a component of the pathname does not name an existing file
 *   or the pathname is an empty string
 * * Errno::ENOTDIR - a component of the path prefix of the pathname in _sockaddr_
 *   is not a directory
 * * Errno::EROFS - the name would reside on a read only filesystem
 * 
 * === Windows Exceptions
 * On Windows systems the following system exceptions may be raised if 
 * the call to _bind_ fails:
 * * Errno::ENETDOWN-- the network is down
 * * Errno::EACCES - the attempt to connect the datagram socket to the 
 *   broadcast address failed
 * * Errno::EADDRINUSE - the socket's local address is already in use
 * * Errno::EADDRNOTAVAIL - the specified address is not a valid address for this
 *   computer
 * * Errno::EFAULT - the socket's internal address or address length parameter
 *   is too small or is not a valid part of the user space addressed
 * * Errno::EINVAL - the +socket+ is already bound to an address
 * * Errno::ENOBUFS - no buffer space is available
 * * Errno::ENOTSOCK - the +socket+ argument does not refer to a socket
 * 
 * === See
 * * bind manual pages on unix-based systems
 * * bind function in Microsoft's Winsock functions reference
 */ 
static VALUE
sock_bind(sock, addr)
    VALUE sock, addr;
{
    OpenFile *fptr;

    StringValue(addr);
    GetOpenFile(sock, fptr);
    if (bind(fileno(fptr-&gt;f), (struct sockaddr*)RSTRING(addr)-&gt;ptr, RSTRING(addr)-&gt;len) &lt; 0)
        rb_sys_fail(&quot;bind(2)&quot;);

    return INT2FIX(0);
}
</pre>
          </div>
        </div>
      </div>

      <div id="method-M001251" class="method-detail">
        <a name="M001251"></a>

        <div class="method-heading">
          <a href="#M001251" class="method-signature">
          <span class="method-name">socket.connect(server_sockaddr) => 0<br />
</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Requests a connection to be made on the given <tt>server_sockaddr</tt>.
Returns 0 if successful, otherwise an exception is raised.
</p>
<h3>Parameter</h3>
<ul>
<li><tt>server_sockaddr</tt> - the <tt>struct</tt> sockaddr contained in a
string

</li>
</ul>
<h3>Example:</h3>
<pre>
     # Pull down Google's web page
     require 'socket'
     include Socket::Constants
     socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
     sockaddr = Socket.pack_sockaddr_in( 80, 'www.google.com' )
     socket.connect( sockaddr )
     socket.write( &quot;GET / HTTP/1.0\r\n\r\n&quot; )
     results = socket.read
</pre>
<h3>Unix-based Exceptions</h3>
<p>
On unix-based systems the following system exceptions may be raised if the
call to <em><a href="Socket.html#M001251">connect</a></em> fails:
</p>
<ul>
<li>Errno::EACCES - search permission is denied for a component of the prefix
path or write access to the <tt>socket</tt> is denided

</li>
<li>Errno::EADDRINUSE - the <em>sockaddr</em> is already in use

</li>
<li>Errno::EADDRNOTAVAIL - the specified <em>sockaddr</em> is not available
from the local machine

</li>
<li>Errno::EAFNOSUPPORT - the specified <em>sockaddr</em> is not a valid
address for the address family of the specified <tt>socket</tt>

</li>
<li>Errno::EALREADY - a connection is already in progress for the specified
socket

</li>
<li>Errno::EBADF - the <tt>socket</tt> is not a valid file descriptor

</li>
<li>Errno::ECONNREFUSED - the target <em>sockaddr</em> was not listening for
connections refused the connection request

</li>
<li>Errno::ECONNRESET - the remote host reset the connection request

</li>
<li>Errno::EFAULT - the <em>sockaddr</em> cannot be accessed

</li>
<li>Errno::EHOSTUNREACH - the destination host cannot be reached (probably
because the host is down or a remote router cannot reach it)

</li>
<li>Errno::EINPROGRESS - the O_NONBLOCK is set for the <tt>socket</tt> and the
connection cnanot be immediately established; the connection will be
established asynchronously

</li>
<li>Errno::EINTR - the attempt to establish the connection was interrupted by
delivery of a signal that was caught; the connection will be established
asynchronously

</li>
<li>Errno::EISCONN - the specified <tt>socket</tt> is already connected

</li>
<li>Errno::EINVAL - the address length used for the <em>sockaddr</em> is not a
valid length for the address family or there is an invalid family in
<em>sockaddr</em>

</li>
<li>Errno::ENAMETOOLONG - the pathname resolved had a length which exceeded
PATH_MAX

</li>
<li>Errno::ENETDOWN - the local interface used to reach the destination is down

</li>
<li>Errno::ENETUNREACH - no route to the network is present

</li>
<li>Errno::ENOBUFS - no buffer space is available

</li>
<li>Errno::ENOSR - there were insufficient STREAMS resources available to
complete the operation

</li>
<li>Errno::ENOTSOCK - the <tt>socket</tt> argument does not refer to a socket

</li>
<li>Errno::EOPNOTSUPP - the calling <tt>socket</tt> is listening and cannot be
connected

</li>
<li>Errno::EPROTOTYPE - the <em>sockaddr</em> has a different type than the
socket bound to the specified peer address

</li>
<li>Errno::ETIMEDOUT - the attempt to <a href="Socket.html#M001251">connect</a>
time out before a connection was made.

</li>
</ul>
<p>
On unix-based systems if the address family of the calling <tt>socket</tt>
is AF_UNIX the follow exceptions may be raised if the call to <em><a
href="Socket.html#M001251">connect</a></em> fails:
</p>
<ul>
<li>Errno::EIO - an i/o error occured while reading from or writing to the file
system

</li>
<li>Errno::ELOOP - too many symbolic links were encountered in translating the
pathname in <em>sockaddr</em>

</li>
<li>Errno::ENAMETOOLLONG - a component of a pathname exceeded NAME_MAX
characters, or an entired pathname exceeded PATH_MAX characters

</li>
<li>Errno::ENOENT - a component of the pathname does not name an existing file
or the pathname is an empty string

</li>
<li>Errno::ENOTDIR - a component of the path prefix of the pathname in
<em>sockaddr</em> is not a directory

</li>
</ul>
<h3>Windows Exceptions</h3>
<p>
On Windows systems the following system exceptions may be raised if the
call to <em><a href="Socket.html#M001251">connect</a></em> fails:
</p>
<ul>
<li>Errno::ENETDOWN - the network is down

</li>
<li>Errno::EADDRINUSE - the socket&#8216;s local address is already in use

</li>
<li>Errno::EINTR - the socket was cancelled

</li>
<li>Errno::EINPROGRESS - a blocking socket is in progress or the service
provider is still processing a callback function. Or a nonblocking <a
href="Socket.html#M001251">connect</a> call is in progress on the
<tt>socket</tt>.

</li>
<li>Errno::EALREADY - see Errno::EINVAL

</li>
<li>Errno::EADDRNOTAVAIL - the remote address is not a valid address, such as
ADDR_ANY TODO check ADDRANY TO INADDR_ANY

</li>
<li>Errno::EAFNOSUPPORT - addresses in the specified family cannot be used with
with this <tt>socket</tt>

</li>
<li>Errno::ECONNREFUSED - the target <em>sockaddr</em> was not listening for
connections refused the connection request

</li>
<li>Errno::EFAULT - the socket&#8216;s internal address or address length
parameter is too small or is not a valid part of the user space address

</li>
<li>Errno::EINVAL - the <tt>socket</tt> is a listening socket

</li>
<li>Errno::EISCONN - the <tt>socket</tt> is already connected

</li>
<li>Errno::ENETUNREACH - the network cannot be reached from this host at this
time

</li>
<li>Errno::EHOSTUNREACH - no route to the network is present

</li>
<li>Errno::ENOBUFS - no buffer space is available

</li>
<li>Errno::ENOTSOCK - the <tt>socket</tt> argument does not refer to a socket

</li>
<li>Errno::ETIMEDOUT - the attempt to <a href="Socket.html#M001251">connect</a>
time out before a connection was made.

</li>
<li>Errno::EWOULDBLOCK - the socket is marked as nonblocking and the connection
cannot be completed immediately

</li>
<li>Errno::EACCES - the attempt to <a href="Socket.html#M001251">connect</a>
the datagram socket to the broadcast address failed

</li>
</ul>
<h3>See</h3>
<ul>
<li><a href="Socket.html#M001251">connect</a> manual pages on unix-based
systems

</li>
<li><a href="Socket.html#M001251">connect</a> function in Microsoft&#8216;s
Winsock functions reference

</li>
</ul>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001251-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001251-source">
<pre>
/*
 * call-seq:
 *      socket.connect(server_sockaddr) =&gt; 0
 * 
 * Requests a connection to be made on the given +server_sockaddr+. Returns 0 if
 * successful, otherwise an exception is raised.
 *  
 * === Parameter
 * * +server_sockaddr+ - the +struct+ sockaddr contained in a string
 * 
 * === Example:
 *      # Pull down Google's web page
 *      require 'socket'
 *      include Socket::Constants
 *      socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
 *      sockaddr = Socket.pack_sockaddr_in( 80, 'www.google.com' )
 *      socket.connect( sockaddr )
 *      socket.write( &quot;GET / HTTP/1.0\r\n\r\n&quot; )
 *      results = socket.read 
 * 
 * === Unix-based Exceptions
 * On unix-based systems the following system exceptions may be raised if 
 * the call to _connect_ fails:
 * * Errno::EACCES - search permission is denied for a component of the prefix
 *   path or write access to the +socket+ is denided
 * * Errno::EADDRINUSE - the _sockaddr_ is already in use
 * * Errno::EADDRNOTAVAIL - the specified _sockaddr_ is not available from the
 *   local machine
 * * Errno::EAFNOSUPPORT - the specified _sockaddr_ is not a valid address for 
 *   the address family of the specified +socket+
 * * Errno::EALREADY - a connection is already in progress for the specified
 *   socket
 * * Errno::EBADF - the +socket+ is not a valid file descriptor
 * * Errno::ECONNREFUSED - the target _sockaddr_ was not listening for connections
 *   refused the connection request
 * * Errno::ECONNRESET - the remote host reset the connection request
 * * Errno::EFAULT - the _sockaddr_ cannot be accessed
 * * Errno::EHOSTUNREACH - the destination host cannot be reached (probably 
 *   because the host is down or a remote router cannot reach it)
 * * Errno::EINPROGRESS - the O_NONBLOCK is set for the +socket+ and the
 *   connection cnanot be immediately established; the connection will be
 *   established asynchronously
 * * Errno::EINTR - the attempt to establish the connection was interrupted by
 *   delivery of a signal that was caught; the connection will be established
 *   asynchronously
 * * Errno::EISCONN - the specified +socket+ is already connected
 * * Errno::EINVAL - the address length used for the _sockaddr_ is not a valid
 *   length for the address family or there is an invalid family in _sockaddr_ 
 * * Errno::ENAMETOOLONG - the pathname resolved had a length which exceeded
 *   PATH_MAX
 * * Errno::ENETDOWN - the local interface used to reach the destination is down
 * * Errno::ENETUNREACH - no route to the network is present
 * * Errno::ENOBUFS - no buffer space is available
 * * Errno::ENOSR - there were insufficient STREAMS resources available to 
 *   complete the operation
 * * Errno::ENOTSOCK - the +socket+ argument does not refer to a socket
 * * Errno::EOPNOTSUPP - the calling +socket+ is listening and cannot be connected
 * * Errno::EPROTOTYPE - the _sockaddr_ has a different type than the socket 
 *   bound to the specified peer address
 * * Errno::ETIMEDOUT - the attempt to connect time out before a connection
 *   was made.
 * 
 * On unix-based systems if the address family of the calling +socket+ is
 * AF_UNIX the follow exceptions may be raised if the call to _connect_
 * fails:
 * * Errno::EIO - an i/o error occured while reading from or writing to the 
 *   file system
 * * Errno::ELOOP - too many symbolic links were encountered in translating
 *   the pathname in _sockaddr_
 * * Errno::ENAMETOOLLONG - a component of a pathname exceeded NAME_MAX 
 *   characters, or an entired pathname exceeded PATH_MAX characters
 * * Errno::ENOENT - a component of the pathname does not name an existing file
 *   or the pathname is an empty string
 * * Errno::ENOTDIR - a component of the path prefix of the pathname in _sockaddr_
 *   is not a directory 
 * 
 * === Windows Exceptions
 * On Windows systems the following system exceptions may be raised if 
 * the call to _connect_ fails:
 * * Errno::ENETDOWN - the network is down
 * * Errno::EADDRINUSE - the socket's local address is already in use
 * * Errno::EINTR - the socket was cancelled
 * * Errno::EINPROGRESS - a blocking socket is in progress or the service provider
 *   is still processing a callback function. Or a nonblocking connect call is 
 *   in progress on the +socket+.
 * * Errno::EALREADY - see Errno::EINVAL
 * * Errno::EADDRNOTAVAIL - the remote address is not a valid address, such as 
 *   ADDR_ANY TODO check ADDRANY TO INADDR_ANY
 * * Errno::EAFNOSUPPORT - addresses in the specified family cannot be used with
 *   with this +socket+
 * * Errno::ECONNREFUSED - the target _sockaddr_ was not listening for connections
 *   refused the connection request
 * * Errno::EFAULT - the socket's internal address or address length parameter
 *   is too small or is not a valid part of the user space address
 * * Errno::EINVAL - the +socket+ is a listening socket
 * * Errno::EISCONN - the +socket+ is already connected
 * * Errno::ENETUNREACH - the network cannot be reached from this host at this time
 * * Errno::EHOSTUNREACH - no route to the network is present
 * * Errno::ENOBUFS - no buffer space is available
 * * Errno::ENOTSOCK - the +socket+ argument does not refer to a socket
 * * Errno::ETIMEDOUT - the attempt to connect time out before a connection
 *   was made.
 * * Errno::EWOULDBLOCK - the socket is marked as nonblocking and the 
 *   connection cannot be completed immediately
 * * Errno::EACCES - the attempt to connect the datagram socket to the 
 *   broadcast address failed
 * 
 * === See
 * * connect manual pages on unix-based systems
 * * connect function in Microsoft's Winsock functions reference
 */
static VALUE
sock_connect(sock, addr)
    VALUE sock, addr;
{
    OpenFile *fptr;
    int fd;

    StringValue(addr);
    addr = rb_str_new4(addr);
    GetOpenFile(sock, fptr);
    fd = fileno(fptr-&gt;f);
    if (ruby_connect(fd, (struct sockaddr*)RSTRING(addr)-&gt;ptr, RSTRING(addr)-&gt;len, 0) &lt; 0) {
        rb_sys_fail(&quot;connect(2)&quot;);
    }

    return INT2FIX(0);
}
</pre>
          </div>
        </div>
      </div>

      <div id="method-M001252" class="method-detail">
        <a name="M001252"></a>

        <div class="method-heading">
          <a href="#M001252" class="method-signature">
          <span class="method-name">socket.connect_nonblock(server_sockaddr) => 0<br />
</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Requests a connection to be made on the given <tt>server_sockaddr</tt>
after O_NONBLOCK is set for the underlying file descriptor. Returns 0 if
successful, otherwise an exception is raised.
</p>
<h3>Parameter</h3>
<ul>
<li><tt>server_sockaddr</tt> - the <tt>struct</tt> sockaddr contained in a
string

</li>
</ul>
<h3>Example:</h3>
<pre>
     # Pull down Google's web page
     require 'socket'
     include Socket::Constants
     socket = Socket.new(AF_INET, SOCK_STREAM, 0)
     sockaddr = Socket.sockaddr_in(80, 'www.google.com')
     begin
       socket.connect_nonblock(sockaddr)
     rescue Errno::EINPROGRESS
       IO.select(nil, [socket])
       begin
         socket.connect_nonblock(sockaddr)
       rescue Errno::EISCONN
       end
     end
     socket.write(&quot;GET / HTTP/1.0\r\n\r\n&quot;)
     results = socket.read
</pre>
<p>
Refer to <a href="Socket.html#M001251">Socket#connect</a> for the
exceptions that may be thrown if the call to <em><a
href="Socket.html#M001252">connect_nonblock</a></em> fails.
</p>
<p>
<a href="Socket.html#M001252">Socket#connect_nonblock</a> may raise any
error corresponding to <a href="Socket.html#M001251">connect</a>(2)
failure, including Errno::EINPROGRESS.
</p>
<h3>See</h3>
<ul>
<li><a href="Socket.html#M001251">Socket#connect</a>

</li>
</ul>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001252-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001252-source">
<pre>
/*
 * call-seq:
 *      socket.connect_nonblock(server_sockaddr) =&gt; 0
 * 
 * Requests a connection to be made on the given +server_sockaddr+ after
 * O_NONBLOCK is set for the underlying file descriptor.
 * Returns 0 if successful, otherwise an exception is raised.
 *  
 * === Parameter
 * * +server_sockaddr+ - the +struct+ sockaddr contained in a string
 * 
 * === Example:
 *      # Pull down Google's web page
 *      require 'socket'
 *      include Socket::Constants
 *      socket = Socket.new(AF_INET, SOCK_STREAM, 0)
 *      sockaddr = Socket.sockaddr_in(80, 'www.google.com')
 *      begin
 *        socket.connect_nonblock(sockaddr)
 *      rescue Errno::EINPROGRESS
 *        IO.select(nil, [socket])
 *        begin
 *          socket.connect_nonblock(sockaddr)
 *        rescue Errno::EISCONN
 *        end
 *      end
 *      socket.write(&quot;GET / HTTP/1.0\r\n\r\n&quot;)
 *      results = socket.read 
 * 
 * Refer to Socket#connect for the exceptions that may be thrown if the call
 * to _connect_nonblock_ fails. 
 *
 * Socket#connect_nonblock may raise any error corresponding to connect(2) failure,
 * including Errno::EINPROGRESS.
 *
 * === See
 * * Socket#connect
 */
static VALUE
sock_connect_nonblock(sock, addr)
    VALUE sock, addr;
{
    OpenFile *fptr;
    int n;

    StringValue(addr);
    addr = rb_str_new4(addr);
    GetOpenFile(sock, fptr);
    rb_io_set_nonblock(fptr);
    n = connect(fileno(fptr-&gt;f), (struct sockaddr*)RSTRING(addr)-&gt;ptr, RSTRING(addr)-&gt;len);
    if (n &lt; 0) {
        rb_sys_fail(&quot;connect(2)&quot;);
    }

    return INT2FIX(n);
}
</pre>
          </div>
        </div>
      </div>

      <div id="method-M001254" class="method-detail">
        <a name="M001254"></a>

        <div class="method-heading">
          <a href="#M001254" class="method-signature">
          <span class="method-name">socket.listen( int ) => 0<br />
</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Listens for connections, using the specified <tt>int</tt> as the backlog. A
call to <em><a href="Socket.html#M001254">listen</a></em> only applies if
the <tt>socket</tt> is of type SOCK_STREAM or SOCK_SEQPACKET.
</p>
<h3>Parameter</h3>
<ul>
<li><tt>backlog</tt> - the maximum length of the queue for pending connections.

</li>
</ul>
<h3>Example 1</h3>
<pre>
     require 'socket'
     include Socket::Constants
     socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
     sockaddr = Socket.pack_sockaddr_in( 2200, 'localhost' )
     socket.bind( sockaddr )
     socket.listen( 5 )
</pre>
<h3>Example 2 (listening on an arbitary port, unix-based systems only):</h3>
<pre>
     require 'socket'
     include Socket::Constants
     socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
     socket.listen( 1 )
</pre>
<h3>Unix-based Exceptions</h3>
<p>
On unix based systems the above will work because a new <tt>sockaddr</tt>
struct is created on the address ADDR_ANY, for an arbitrary port number as
handed off by the kernel. It will not work on Windows, because Windows
requires that the <tt>socket</tt> is bound by calling <em><a
href="Socket.html#M001253">bind</a></em> before it can <em><a
href="Socket.html#M001254">listen</a></em>.
</p>
<p>
If the <em>backlog</em> amount exceeds the implementation-dependent maximum
queue length, the implementation&#8216;s maximum queue length will be used.
</p>
<p>
On unix-based based systems the following system exceptions may be raised
if the call to <em><a href="Socket.html#M001254">listen</a></em> fails:
</p>
<ul>
<li>Errno::EBADF - the <em>socket</em> argument is not a valid file descriptor

</li>
<li>Errno::EDESTADDRREQ - the <em>socket</em> is not bound to a local address,
and the protocol does not support listening on an unbound socket

</li>
<li>Errno::EINVAL - the <em>socket</em> is already connected

</li>
<li>Errno::ENOTSOCK - the <em>socket</em> argument does not refer to a socket

</li>
<li>Errno::EOPNOTSUPP - the <em>socket</em> protocol does not support <a
href="Socket.html#M001254">listen</a>

</li>
<li>Errno::EACCES - the calling process does not have approriate privileges

</li>
<li>Errno::EINVAL - the <em>socket</em> has been shut down

</li>
<li>Errno::ENOBUFS - insufficient resources are available in the system to
complete the call

</li>
</ul>
<h3>Windows Exceptions</h3>
<p>
On Windows systems the following system exceptions may be raised if the
call to <em><a href="Socket.html#M001254">listen</a></em> fails:
</p>
<ul>
<li>Errno::ENETDOWN - the network is down

</li>
<li>Errno::EADDRINUSE - the socket&#8216;s local address is already in use.
This usually occurs during the execution of <em><a
href="Socket.html#M001253">bind</a></em> but could be delayed if the call
to <em><a href="Socket.html#M001253">bind</a></em> was to a partially
wildcard address (involving ADDR_ANY) and if a specific address needs to be
commmitted at the time of the call to <em><a
href="Socket.html#M001254">listen</a></em>

</li>
<li>Errno::EINPROGRESS - a Windows Sockets 1.1 call is in progress or the
service provider is still processing a callback function

</li>
<li>Errno::EINVAL - the <tt>socket</tt> has not been bound with a call to
<em><a href="Socket.html#M001253">bind</a></em>.

</li>
<li>Errno::EISCONN - the <tt>socket</tt> is already connected

</li>
<li>Errno::EMFILE - no more socket descriptors are available

</li>
<li>Errno::ENOBUFS - no buffer space is available

</li>
<li>Errno::ENOTSOC - <tt>socket</tt> is not a socket

</li>
<li>Errno::EOPNOTSUPP - the referenced <tt>socket</tt> is not a type that
supports the <em><a href="Socket.html#M001254">listen</a></em> method

</li>
</ul>
<h3>See</h3>
<ul>
<li><a href="Socket.html#M001254">listen</a> manual pages on unix-based systems

</li>
<li><a href="Socket.html#M001254">listen</a> function in Microsoft&#8216;s
Winsock functions reference

</li>
</ul>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001254-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001254-source">
<pre>
/*
 * call-seq:
 *      socket.listen( int ) =&gt; 0
 * 
 * Listens for connections, using the specified +int+ as the backlog. A call
 * to _listen_ only applies if the +socket+ is of type SOCK_STREAM or 
 * SOCK_SEQPACKET.
 * 
 * === Parameter
 * * +backlog+ - the maximum length of the queue for pending connections.
 * 
 * === Example 1
 *      require 'socket'
 *      include Socket::Constants
 *      socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
 *      sockaddr = Socket.pack_sockaddr_in( 2200, 'localhost' )
 *      socket.bind( sockaddr )
 *      socket.listen( 5 )
 * 
 * === Example 2 (listening on an arbitary port, unix-based systems only):
 *      require 'socket'
 *      include Socket::Constants
 *      socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
 *      socket.listen( 1 )
 * 
 * === Unix-based Exceptions
 * On unix based systems the above will work because a new +sockaddr+ struct
 * is created on the address ADDR_ANY, for an arbitrary port number as handed
 * off by the kernel. It will not work on Windows, because Windows requires that
 * the +socket+ is bound by calling _bind_ before it can _listen_.
 * 
 * If the _backlog_ amount exceeds the implementation-dependent maximum
 * queue length, the implementation's maximum queue length will be used.
 * 
 * On unix-based based systems the following system exceptions may be raised if the
 * call to _listen_ fails:
 * * Errno::EBADF - the _socket_ argument is not a valid file descriptor
 * * Errno::EDESTADDRREQ - the _socket_ is not bound to a local address, and 
 *   the protocol does not support listening on an unbound socket
 * * Errno::EINVAL - the _socket_ is already connected
 * * Errno::ENOTSOCK - the _socket_ argument does not refer to a socket
 * * Errno::EOPNOTSUPP - the _socket_ protocol does not support listen
 * * Errno::EACCES - the calling process does not have approriate privileges
 * * Errno::EINVAL - the _socket_ has been shut down
 * * Errno::ENOBUFS - insufficient resources are available in the system to 
 *   complete the call
 * 
 * === Windows Exceptions
 * On Windows systems the following system exceptions may be raised if 
 * the call to _listen_ fails:
 * * Errno::ENETDOWN - the network is down
 * * Errno::EADDRINUSE - the socket's local address is already in use. This 
 *   usually occurs during the execution of _bind_ but could be delayed
 *   if the call to _bind_ was to a partially wildcard address (involving
 *   ADDR_ANY) and if a specific address needs to be commmitted at the 
 *   time of the call to _listen_
 * * Errno::EINPROGRESS - a Windows Sockets 1.1 call is in progress or the
 *   service provider is still processing a callback function
 * * Errno::EINVAL - the +socket+ has not been bound with a call to _bind_.
 * * Errno::EISCONN - the +socket+ is already connected
 * * Errno::EMFILE - no more socket descriptors are available
 * * Errno::ENOBUFS - no buffer space is available
 * * Errno::ENOTSOC - +socket+ is not a socket
 * * Errno::EOPNOTSUPP - the referenced +socket+ is not a type that supports
 *   the _listen_ method
 * 
 * === See
 * * listen manual pages on unix-based systems
 * * listen function in Microsoft's Winsock functions reference
 */
static VALUE
sock_listen(sock, log)
    VALUE sock, log;
{
    OpenFile *fptr;
    int backlog;

    rb_secure(4);
    backlog = NUM2INT(log);
    GetOpenFile(sock, fptr);
    if (listen(fileno(fptr-&gt;f), backlog) &lt; 0)
        rb_sys_fail(&quot;listen(2)&quot;);

    return INT2FIX(0);
}
</pre>
          </div>
        </div>
      </div>

      <div id="method-M001258" class="method-detail">
        <a name="M001258"></a>

        <div class="method-heading">
          <a href="#M001258" class="method-signature">
          <span class="method-name">socket.recvfrom(maxlen) => [mesg, sender_sockaddr]<br />
socket.recvfrom(maxlen, flags) => [mesg, sender_sockaddr]<br />
</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Receives up to <em>maxlen</em> bytes from <tt>socket</tt>. <em>flags</em>
is zero or more of the <tt>MSG_</tt> options. The first element of the
results, <em>mesg</em>, is the data received. The second element,
<em>sender_sockaddr</em>, contains protocol-specific information on the
sender.
</p>
<h3>Parameters</h3>
<ul>
<li><tt>maxlen</tt> - the number of bytes to receive from the socket

</li>
<li><tt>flags</tt> - zero or more of the <tt>MSG_</tt> options

</li>
</ul>
<h3>Example</h3>
<pre>
     # In one file, start this first
     require 'socket'
     include Socket::Constants
     socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
     sockaddr = Socket.pack_sockaddr_in( 2200, 'localhost' )
     socket.bind( sockaddr )
     socket.listen( 5 )
     client, client_sockaddr = socket.accept
     data = client.recvfrom( 20 )[0].chomp
     puts &quot;I only received 20 bytes '#{data}'&quot;
     sleep 1
     socket.close

     # In another file, start this second
     require 'socket'
     include Socket::Constants
     socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
     sockaddr = Socket.pack_sockaddr_in( 2200, 'localhost' )
     socket.connect( sockaddr )
     socket.puts &quot;Watch this get cut short!&quot;
     socket.close
</pre>
<h3>Unix-based Exceptions</h3>
<p>
On unix-based based systems the following system exceptions may be raised
if the call to <em><a href="Socket.html#M001258">recvfrom</a></em> fails:
</p>
<ul>
<li>Errno::EAGAIN - the <tt>socket</tt> file descriptor is marked as O_NONBLOCK
and no data is waiting to be received; or MSG_OOB is set and no out-of-band
data is available and either the <tt>socket</tt> file descriptor is marked
as O_NONBLOCK or the <tt>socket</tt> does not support blocking to wait for
out-of-band-data

</li>
<li>Errno::EWOULDBLOCK - see Errno::EAGAIN

</li>
<li>Errno::EBADF - the <tt>socket</tt> is not a valid file descriptor

</li>
<li>Errno::ECONNRESET - a connection was forcibly closed by a peer

</li>
<li>Errno::EFAULT - the socket&#8216;s internal buffer, address or address
length cannot be accessed or written

</li>
<li>Errno::EINTR - a signal interupted <em><a
href="Socket.html#M001258">recvfrom</a></em> before any data was available

</li>
<li>Errno::EINVAL - the MSG_OOB flag is set and no out-of-band data is
available

</li>
<li>Errno::EIO - an i/o error occurred while reading from or writing to the
filesystem

</li>
<li>Errno::ENOBUFS - insufficient resources were available in the system to
perform the operation

</li>
<li>Errno::ENOMEM - insufficient memory was available to fulfill the request

</li>
<li>Errno::ENOSR - there were insufficient STREAMS resources available to
complete the operation

</li>
<li>Errno::ENOTCONN - a receive is attempted on a connection-mode socket that
is not connected

</li>
<li>Errno::ENOTSOCK - the <tt>socket</tt> does not refer to a socket

</li>
<li>Errno::EOPNOTSUPP - the specified flags are not supported for this socket
type

</li>
<li>Errno::ETIMEDOUT - the connection timed out during connection establishment
or due to a transmission timeout on an active connection

</li>
</ul>
<h3>Windows Exceptions</h3>
<p>
On Windows systems the following system exceptions may be raised if the
call to <em><a href="Socket.html#M001258">recvfrom</a></em> fails:
</p>
<ul>
<li>Errno::ENETDOWN - the network is down

</li>
<li>Errno::EFAULT - the internal buffer and from parameters on <tt>socket</tt>
are not part of the user address space, or the internal fromlen parameter
is too small to accomodate the peer address

</li>
<li>Errno::EINTR - the (blocking) call was cancelled by an internal call to the
WinSock function WSACancelBlockingCall

</li>
<li>Errno::EINPROGRESS - a blocking Windows Sockets 1.1 call is in progress or
the service provider is still processing a callback function

</li>
<li>Errno::EINVAL - <tt>socket</tt> has not been bound with a call to <em><a
href="Socket.html#M001253">bind</a></em>, or an unknown flag was specified,
or MSG_OOB was specified for a socket with SO_OOBINLINE enabled, or (for
byte stream-style sockets only) the internal len parameter on
<tt>socket</tt> was zero or negative

</li>
<li>Errno::EISCONN - <tt>socket</tt> is already connected. The call to <em><a
href="Socket.html#M001258">recvfrom</a></em> is not permitted with a
connected socket on a socket that is connetion oriented or connectionless.

</li>
<li>Errno::ENETRESET - the connection has been broken due to the keep-alive
activity detecting a failure while the operation was in progress.

</li>
<li>Errno::EOPNOTSUPP - MSG_OOB was specified, but <tt>socket</tt> is not
stream-style such as type SOCK_STREAM. OOB data is not supported in the
communication domain associated with <tt>socket</tt>, or <tt>socket</tt> is
unidirectional and supports only send operations

</li>
<li>Errno::ESHUTDOWN - <tt>socket</tt> has been shutdown. It is not possible to
call <em><a href="Socket.html#M001258">recvfrom</a></em> on a socket after
<em>shutdown</em> has been invoked.

</li>
<li>Errno::EWOULDBLOCK - <tt>socket</tt> is marked as nonblocking and a call to
<em><a href="Socket.html#M001258">recvfrom</a></em> would block.

</li>
<li>Errno::EMSGSIZE - the message was too large to fit into the specified
buffer and was truncated.

</li>
<li>Errno::ETIMEDOUT - the connection has been dropped, because of a network
failure or because the system on the other end went down without notice

</li>
<li>Errno::ECONNRESET - the virtual circuit was reset by the remote side
executing a hard or abortive close. The application should close the
socket; it is no longer usable. On a UDP-datagram socket this error
indicates a previous send operation resulted in an ICMP Port Unreachable
message.

</li>
</ul>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001258-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001258-source">
<pre>
/*
 * call-seq:
 *      socket.recvfrom(maxlen) =&gt; [mesg, sender_sockaddr]
 *      socket.recvfrom(maxlen, flags) =&gt; [mesg, sender_sockaddr]
 * 
 * Receives up to _maxlen_ bytes from +socket+. _flags_ is zero or more
 * of the +MSG_+ options. The first element of the results, _mesg_, is the data
 * received. The second element, _sender_sockaddr_, contains protocol-specific information
 * on the sender.
 * 
 * === Parameters
 * * +maxlen+ - the number of bytes to receive from the socket
 * * +flags+ - zero or more of the +MSG_+ options 
 * 
 * === Example
 *      # In one file, start this first
 *      require 'socket'
 *      include Socket::Constants
 *      socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
 *      sockaddr = Socket.pack_sockaddr_in( 2200, 'localhost' )
 *      socket.bind( sockaddr )
 *      socket.listen( 5 )
 *      client, client_sockaddr = socket.accept
 *      data = client.recvfrom( 20 )[0].chomp
 *      puts &quot;I only received 20 bytes '#{data}'&quot;
 *      sleep 1
 *      socket.close
 * 
 *      # In another file, start this second
 *      require 'socket'
 *      include Socket::Constants
 *      socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
 *      sockaddr = Socket.pack_sockaddr_in( 2200, 'localhost' )
 *      socket.connect( sockaddr )
 *      socket.puts &quot;Watch this get cut short!&quot;
 *      socket.close 
 * 
 * === Unix-based Exceptions
 * On unix-based based systems the following system exceptions may be raised if the
 * call to _recvfrom_ fails:
 * * Errno::EAGAIN - the +socket+ file descriptor is marked as O_NONBLOCK and no
 *   data is waiting to be received; or MSG_OOB is set and no out-of-band data
 *   is available and either the +socket+ file descriptor is marked as 
 *   O_NONBLOCK or the +socket+ does not support blocking to wait for 
 *   out-of-band-data
 * * Errno::EWOULDBLOCK - see Errno::EAGAIN
 * * Errno::EBADF - the +socket+ is not a valid file descriptor
 * * Errno::ECONNRESET - a connection was forcibly closed by a peer
 * * Errno::EFAULT - the socket's internal buffer, address or address length 
 *   cannot be accessed or written
 * * Errno::EINTR - a signal interupted _recvfrom_ before any data was available
 * * Errno::EINVAL - the MSG_OOB flag is set and no out-of-band data is available
 * * Errno::EIO - an i/o error occurred while reading from or writing to the 
 *   filesystem
 * * Errno::ENOBUFS - insufficient resources were available in the system to 
 *   perform the operation
 * * Errno::ENOMEM - insufficient memory was available to fulfill the request
 * * Errno::ENOSR - there were insufficient STREAMS resources available to 
 *   complete the operation
 * * Errno::ENOTCONN - a receive is attempted on a connection-mode socket that
 *   is not connected
 * * Errno::ENOTSOCK - the +socket+ does not refer to a socket
 * * Errno::EOPNOTSUPP - the specified flags are not supported for this socket type
 * * Errno::ETIMEDOUT - the connection timed out during connection establishment
 *   or due to a transmission timeout on an active connection
 * 
 * === Windows Exceptions
 * On Windows systems the following system exceptions may be raised if 
 * the call to _recvfrom_ fails:
 * * Errno::ENETDOWN - the network is down
 * * Errno::EFAULT - the internal buffer and from parameters on +socket+ are not
 *   part of the user address space, or the internal fromlen parameter is
 *   too small to accomodate the peer address
 * * Errno::EINTR - the (blocking) call was cancelled by an internal call to
 *   the WinSock function WSACancelBlockingCall
 * * Errno::EINPROGRESS - a blocking Windows Sockets 1.1 call is in progress or 
 *   the service provider is still processing a callback function
 * * Errno::EINVAL - +socket+ has not been bound with a call to _bind_, or an
 *   unknown flag was specified, or MSG_OOB was specified for a socket with
 *   SO_OOBINLINE enabled, or (for byte stream-style sockets only) the internal
 *   len parameter on +socket+ was zero or negative
 * * Errno::EISCONN - +socket+ is already connected. The call to _recvfrom_ is
 *   not permitted with a connected socket on a socket that is connetion 
 *   oriented or connectionless.
 * * Errno::ENETRESET - the connection has been broken due to the keep-alive 
 *   activity detecting a failure while the operation was in progress.
 * * Errno::EOPNOTSUPP - MSG_OOB was specified, but +socket+ is not stream-style
 *   such as type SOCK_STREAM. OOB data is not supported in the communication
 *   domain associated with +socket+, or +socket+ is unidirectional and 
 *   supports only send operations
 * * Errno::ESHUTDOWN - +socket+ has been shutdown. It is not possible to 
 *   call _recvfrom_ on a socket after _shutdown_ has been invoked.
 * * Errno::EWOULDBLOCK - +socket+ is marked as nonblocking and a  call to 
 *   _recvfrom_ would block.
 * * Errno::EMSGSIZE - the message was too large to fit into the specified buffer
 *   and was truncated.
 * * Errno::ETIMEDOUT - the connection has been dropped, because of a network
 *   failure or because the system on the other end went down without
 *   notice
 * * Errno::ECONNRESET - the virtual circuit was reset by the remote side 
 *   executing a hard or abortive close. The application should close the
 *   socket; it is no longer usable. On a UDP-datagram socket this error
 *   indicates a previous send operation resulted in an ICMP Port Unreachable
 *   message.
 */
static VALUE
sock_recvfrom(argc, argv, sock)
    int argc;
    VALUE *argv;
    VALUE sock;
{
    return s_recvfrom(sock, argc, argv, RECV_SOCKET);
}
</pre>
          </div>
        </div>
      </div>

      <div id="method-M001259" class="method-detail">
        <a name="M001259"></a>

        <div class="method-heading">
          <a href="#M001259" class="method-signature">
          <span class="method-name">socket.recvfrom_nonblock(maxlen) => [mesg, sender_sockaddr]<br />
socket.recvfrom_nonblock(maxlen, flags) => [mesg, sender_sockaddr]<br />
</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Receives up to <em>maxlen</em> bytes from <tt>socket</tt> using <a
href="Socket.html#M001258">recvfrom</a>(2) after O_NONBLOCK is set for the
underlying file descriptor. <em>flags</em> is zero or more of the
<tt>MSG_</tt> options. The first element of the results, <em>mesg</em>, is
the data received. The second element, <em>sender_sockaddr</em>, contains
protocol-specific information on the sender.
</p>
<p>
When <a href="Socket.html#M001258">recvfrom</a>(2) returns 0, <a
href="Socket.html#M001259">Socket#recvfrom_nonblock</a> returns an empty
string as data. The meaning depends on the socket: EOF on TCP, empty packet
on UDP, etc.
</p>
<h3>Parameters</h3>
<ul>
<li><tt>maxlen</tt> - the number of bytes to receive from the socket

</li>
<li><tt>flags</tt> - zero or more of the <tt>MSG_</tt> options

</li>
</ul>
<h3>Example</h3>
<pre>
     # In one file, start this first
     require 'socket'
     include Socket::Constants
     socket = Socket.new(AF_INET, SOCK_STREAM, 0)
     sockaddr = Socket.sockaddr_in(2200, 'localhost')
     socket.bind(sockaddr)
     socket.listen(5)
     client, client_sockaddr = socket.accept
     begin
       pair = client.recvfrom_nonblock(20)
     rescue Errno::EAGAIN
       IO.select([client])
       retry
     end
     data = pair[0].chomp
     puts &quot;I only received 20 bytes '#{data}'&quot;
     sleep 1
     socket.close

     # In another file, start this second
     require 'socket'
     include Socket::Constants
     socket = Socket.new(AF_INET, SOCK_STREAM, 0)
     sockaddr = Socket.sockaddr_in(2200, 'localhost')
     socket.connect(sockaddr)
     socket.puts &quot;Watch this get cut short!&quot;
     socket.close
</pre>
<p>
Refer to <a href="Socket.html#M001258">Socket#recvfrom</a> for the
exceptions that may be thrown if the call to <em><a
href="Socket.html#M001259">recvfrom_nonblock</a></em> fails.
</p>
<p>
<a href="Socket.html#M001259">Socket#recvfrom_nonblock</a> may raise any
error corresponding to <a href="Socket.html#M001258">recvfrom</a>(2)
failure, including Errno::EAGAIN.
</p>
<h3>See</h3>
<ul>
<li><a href="Socket.html#M001258">Socket#recvfrom</a>

</li>
</ul>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001259-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001259-source">
<pre>
/*
 * call-seq:
 *      socket.recvfrom_nonblock(maxlen) =&gt; [mesg, sender_sockaddr]
 *      socket.recvfrom_nonblock(maxlen, flags) =&gt; [mesg, sender_sockaddr]
 * 
 * Receives up to _maxlen_ bytes from +socket+ using recvfrom(2) after
 * O_NONBLOCK is set for the underlying file descriptor.
 * _flags_ is zero or more of the +MSG_+ options.
 * The first element of the results, _mesg_, is the data received.
 * The second element, _sender_sockaddr_, contains protocol-specific information
 * on the sender.
 *
 * When recvfrom(2) returns 0, Socket#recvfrom_nonblock returns
 * an empty string as data.
 * The meaning depends on the socket: EOF on TCP, empty packet on UDP, etc.
 * 
 * === Parameters
 * * +maxlen+ - the number of bytes to receive from the socket
 * * +flags+ - zero or more of the +MSG_+ options 
 * 
 * === Example
 *      # In one file, start this first
 *      require 'socket'
 *      include Socket::Constants
 *      socket = Socket.new(AF_INET, SOCK_STREAM, 0)
 *      sockaddr = Socket.sockaddr_in(2200, 'localhost')
 *      socket.bind(sockaddr)
 *      socket.listen(5)
 *      client, client_sockaddr = socket.accept
 *      begin
 *        pair = client.recvfrom_nonblock(20)
 *      rescue Errno::EAGAIN
 *        IO.select([client])
 *        retry
 *      end
 *      data = pair[0].chomp
 *      puts &quot;I only received 20 bytes '#{data}'&quot;
 *      sleep 1
 *      socket.close
 * 
 *      # In another file, start this second
 *      require 'socket'
 *      include Socket::Constants
 *      socket = Socket.new(AF_INET, SOCK_STREAM, 0)
 *      sockaddr = Socket.sockaddr_in(2200, 'localhost')
 *      socket.connect(sockaddr)
 *      socket.puts &quot;Watch this get cut short!&quot;
 *      socket.close 
 * 
 * Refer to Socket#recvfrom for the exceptions that may be thrown if the call
 * to _recvfrom_nonblock_ fails. 
 *
 * Socket#recvfrom_nonblock may raise any error corresponding to recvfrom(2) failure,
 * including Errno::EAGAIN.
 *
 * === See
 * * Socket#recvfrom
 */
static VALUE
sock_recvfrom_nonblock(int argc, VALUE *argv, VALUE sock)
{
    return s_recvfrom_nonblock(sock, argc, argv, RECV_SOCKET);
}
</pre>
          </div>
        </div>
      </div>

      <div id="method-M001257" class="method-detail">
        <a name="M001257"></a>

        <div class="method-heading">
          <a href="#M001257" class="method-signature">
          <span class="method-name">socket.sysaccept => [client_socket_fd, client_sockaddr]<br />
</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Accepts an incoming connection returnings an array containg the (integer)
file descriptor for the incoming connection, <em>client_socket_fd</em>, and
a string that contains the <tt>struct</tt> sockaddr information about the
caller, <em>client_sockaddr</em>.
</p>
<h3>Example</h3>
<pre>
     # In one script, start this first
     require 'socket'
     include Socket::Constants
     socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
     sockaddr = Socket.pack_sockaddr_in( 2200, 'localhost' )
     socket.bind( sockaddr )
     socket.listen( 5 )
     client_fd, client_sockaddr = socket.sysaccept
     client_socket = Socket.for_fd( client_fd )
     puts &quot;The client said, '#{client_socket.readline.chomp}'&quot;
     client_socket.puts &quot;Hello from script one!&quot;
     socket.close

     # In another script, start this second
     require 'socket'
     include Socket::Constants
     socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
     sockaddr = Socket.pack_sockaddr_in( 2200, 'localhost' )
     socket.connect( sockaddr )
     socket.puts &quot;Hello from script 2.&quot;
     puts &quot;The server said, '#{socket.readline.chomp}'&quot;
     socket.close
</pre>
<p>
Refer to <a href="Socket.html#M001255">Socket#accept</a> for the exceptions
that may be thrown if the call to <em><a
href="Socket.html#M001257">sysaccept</a></em> fails.
</p>
<h3>See</h3>
<ul>
<li><a href="Socket.html#M001255">Socket#accept</a>

</li>
</ul>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001257-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001257-source">
<pre>
/*
 * call-seq:
 *      socket.sysaccept =&gt; [client_socket_fd, client_sockaddr]
 * 
 * Accepts an incoming connection returnings an array containg the (integer)
 * file descriptor for the incoming connection, _client_socket_fd_,
 * and a string that contains the +struct+ sockaddr information
 * about the caller, _client_sockaddr_.
 * 
 * === Example
 *      # In one script, start this first
 *      require 'socket'
 *      include Socket::Constants
 *      socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
 *      sockaddr = Socket.pack_sockaddr_in( 2200, 'localhost' )
 *      socket.bind( sockaddr )
 *      socket.listen( 5 )
 *      client_fd, client_sockaddr = socket.sysaccept
 *      client_socket = Socket.for_fd( client_fd )
 *      puts &quot;The client said, '#{client_socket.readline.chomp}'&quot;
 *      client_socket.puts &quot;Hello from script one!&quot;
 *      socket.close
 * 
 *      # In another script, start this second
 *      require 'socket'
 *      include Socket::Constants
 *      socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
 *      sockaddr = Socket.pack_sockaddr_in( 2200, 'localhost' )
 *      socket.connect( sockaddr )
 *      socket.puts &quot;Hello from script 2.&quot; 
 *      puts &quot;The server said, '#{socket.readline.chomp}'&quot;
 *      socket.close
 * 
 * Refer to Socket#accept for the exceptions that may be thrown if the call
 * to _sysaccept_ fails. 
 * 
 * === See
 * * Socket#accept
 */
static VALUE
sock_sysaccept(sock)
    VALUE sock;
{
    OpenFile *fptr;
    VALUE sock2;
    char buf[1024];
    socklen_t len = sizeof buf;

    GetOpenFile(sock, fptr);
    sock2 = s_accept(0,fileno(fptr-&gt;f),(struct sockaddr*)buf,&amp;len);

    return rb_assoc_new(sock2, rb_str_new(buf, len));
}
</pre>
          </div>
        </div>
      </div>


    </div>


  </div>


<div id="validator-badges">
  <p><small><a href="http://validator.w3.org/check/referer">[Validate]</a></small></p>
</div>

</body>
</html>