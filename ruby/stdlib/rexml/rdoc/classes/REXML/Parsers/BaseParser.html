<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html 
     PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
     "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>Class: REXML::Parsers::BaseParser</title>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
  <meta http-equiv="Content-Script-Type" content="text/javascript" />
  <link rel="stylesheet" href="../../.././rdoc-style.css" type="text/css" media="screen" />
  <script type="text/javascript">
  // <![CDATA[

  function popupCode( url ) {
    window.open(url, "Code", "resizable=yes,scrollbars=yes,toolbar=no,status=no,height=150,width=400")
  }

  function toggleCode( id ) {
    if ( document.getElementById )
      elem = document.getElementById( id );
    else if ( document.all )
      elem = eval( "document.all." + id );
    else
      return false;

    elemStyle = elem.style;
    
    if ( elemStyle.display != "block" ) {
      elemStyle.display = "block"
    } else {
      elemStyle.display = "none"
    }

    return true;
  }
  
  // Make codeblocks hidden by default
  document.writeln( "<style type=\"text/css\">div.method-source-code { display: none }</style>" )
  
  // ]]>
  </script>

</head>
<body>



    <div id="classHeader">
        <table class="header-table">
        <tr class="top-aligned-row">
          <td><strong>Class</strong></td>
          <td class="class-name-in-header">REXML::Parsers::BaseParser</td>
        </tr>
        <tr class="top-aligned-row">
            <td><strong>In:</strong></td>
            <td>
                <a href="../../../files/rexml/parsers/baseparser_rb.html">
                rexml/parsers/baseparser.rb
                </a>
        <br />
            </td>
        </tr>

        <tr class="top-aligned-row">
            <td><strong>Parent:</strong></td>
            <td>
                <a href="../../Object.html">
                Object
               </a>
            </td>
        </tr>
        </table>
    </div>
  <!-- banner header -->

  <div id="bodyContent">



  <div id="contextContent">

    <div id="description">
      <h1>Using the Pull Parser</h1>
<p>
<em>This API is experimental, and subject to change.</em>
</p>
<pre>
 parser = PullParser.new( &quot;&lt;a&gt;text&lt;b att='val'/&gt;txet&lt;/a&gt;&quot; )
 while parser.has_next?
   res = parser.next
   puts res[1]['att'] if res.start_tag? and res[0] == 'b'
 end
</pre>
<p>
See the <a href="PullEvent.html">PullEvent</a> class for information on the
content of the results. The data is identical to the arguments passed for
the various events to the <a
href="../StreamListener.html">StreamListener</a> API.
</p>
<p>
Notice that:
</p>
<pre>
 parser = PullParser.new( &quot;&lt;a&gt;BAD DOCUMENT&quot; )
 while parser.has_next?
   res = parser.next
   raise res[1] if res.error?
 end
</pre>
<p>
Nat Price gave me some good ideas for the API.
</p>

    </div>


   </div>

    <div id="method-list">
      <h3 class="section-bar">Methods</h3>

      <div class="name-list">
      <a href="#M002541">add_listener</a>&nbsp;&nbsp;
      <a href="#M002544">empty?</a>&nbsp;&nbsp;
      <a href="#M002549">entity</a>&nbsp;&nbsp;
      <a href="#M002545">has_next?</a>&nbsp;&nbsp;
      <a href="#M002540">new</a>&nbsp;&nbsp;
      <a href="#M002550">normalize</a>&nbsp;&nbsp;
      <a href="#M002547">peek</a>&nbsp;&nbsp;
      <a href="#M002543">position</a>&nbsp;&nbsp;
      <a href="#M002548">pull</a>&nbsp;&nbsp;
      <a href="#M002542">stream=</a>&nbsp;&nbsp;
      <a href="#M002551">unnormalize</a>&nbsp;&nbsp;
      <a href="#M002546">unshift</a>&nbsp;&nbsp;
      </div>
    </div>

  </div>


    <!-- if includes -->

    <div id="section">


    <div id="constants-list">
      <h3 class="section-bar">Constants</h3>

      <div class="name-list">
        <table summary="Constants">
        <tr class="top-aligned-row context-row">
          <td class="context-item-name">NCNAME_STR</td>
          <td>=</td>
          <td class="context-item-value">'[\w:][\-\w\d.]*'</td>
        </tr>
        <tr class="top-aligned-row context-row">
          <td class="context-item-name">NAME_STR</td>
          <td>=</td>
          <td class="context-item-value">&quot;(?:(#{NCNAME_STR}):)?(#{NCNAME_STR})&quot;</td>
        </tr>
        <tr class="top-aligned-row context-row">
          <td class="context-item-name">UNAME_STR</td>
          <td>=</td>
          <td class="context-item-value">&quot;(?:#{NCNAME_STR}:)?#{NCNAME_STR}&quot;</td>
        </tr>
        <tr class="top-aligned-row context-row">
          <td class="context-item-name">NAMECHAR</td>
          <td>=</td>
          <td class="context-item-value">'[\-\w\d\.:]'</td>
        </tr>
        <tr class="top-aligned-row context-row">
          <td class="context-item-name">NAME</td>
          <td>=</td>
          <td class="context-item-value">&quot;([\\w:]#{NAMECHAR}*)&quot;</td>
        </tr>
        <tr class="top-aligned-row context-row">
          <td class="context-item-name">NMTOKEN</td>
          <td>=</td>
          <td class="context-item-value">&quot;(?:#{NAMECHAR})+&quot;</td>
        </tr>
        <tr class="top-aligned-row context-row">
          <td class="context-item-name">NMTOKENS</td>
          <td>=</td>
          <td class="context-item-value">&quot;#{NMTOKEN}(\\s+#{NMTOKEN})*&quot;</td>
        </tr>
        <tr class="top-aligned-row context-row">
          <td class="context-item-name">REFERENCE</td>
          <td>=</td>
          <td class="context-item-value">&quot;(?:&amp;#{NAME};|&amp;#\\d+;|&amp;#x[0-9a-fA-F]+;)&quot;</td>
        </tr>
        <tr class="top-aligned-row context-row">
          <td class="context-item-name">REFERENCE_RE</td>
          <td>=</td>
          <td class="context-item-value">/#{REFERENCE}/</td>
        </tr>
        <tr class="top-aligned-row context-row">
          <td class="context-item-name">DOCTYPE_START</td>
          <td>=</td>
          <td class="context-item-value">/\A\s*&lt;!DOCTYPE\s/um</td>
        </tr>
        <tr class="top-aligned-row context-row">
          <td class="context-item-name">DOCTYPE_PATTERN</td>
          <td>=</td>
          <td class="context-item-value">/\s*&lt;!DOCTYPE\s+(.*?)(\[|&gt;)/um</td>
        </tr>
        <tr class="top-aligned-row context-row">
          <td class="context-item-name">ATTRIBUTE_PATTERN</td>
          <td>=</td>
          <td class="context-item-value">/\s*(#{NAME_STR})\s*=\s*([&quot;'])(.*?)\4/um</td>
        </tr>
        <tr class="top-aligned-row context-row">
          <td class="context-item-name">COMMENT_START</td>
          <td>=</td>
          <td class="context-item-value">/\A&lt;!--/u</td>
        </tr>
        <tr class="top-aligned-row context-row">
          <td class="context-item-name">COMMENT_PATTERN</td>
          <td>=</td>
          <td class="context-item-value">/&lt;!--(.*?)--&gt;/um</td>
        </tr>
        <tr class="top-aligned-row context-row">
          <td class="context-item-name">CDATA_START</td>
          <td>=</td>
          <td class="context-item-value">/\A&lt;!\[CDATA\[/u</td>
        </tr>
        <tr class="top-aligned-row context-row">
          <td class="context-item-name">CDATA_END</td>
          <td>=</td>
          <td class="context-item-value">/^\s*\]\s*&gt;/um</td>
        </tr>
        <tr class="top-aligned-row context-row">
          <td class="context-item-name">CDATA_PATTERN</td>
          <td>=</td>
          <td class="context-item-value">/&lt;!\[CDATA\[(.*?)\]\]&gt;/um</td>
        </tr>
        <tr class="top-aligned-row context-row">
          <td class="context-item-name">XMLDECL_START</td>
          <td>=</td>
          <td class="context-item-value">/\A&lt;\?xml\s/u;</td>
        </tr>
        <tr class="top-aligned-row context-row">
          <td class="context-item-name">XMLDECL_PATTERN</td>
          <td>=</td>
          <td class="context-item-value">/&lt;\?xml\s+(.*?)\?&gt;/um</td>
        </tr>
        <tr class="top-aligned-row context-row">
          <td class="context-item-name">INSTRUCTION_START</td>
          <td>=</td>
          <td class="context-item-value">/\A&lt;\?/u</td>
        </tr>
        <tr class="top-aligned-row context-row">
          <td class="context-item-name">INSTRUCTION_PATTERN</td>
          <td>=</td>
          <td class="context-item-value">/&lt;\?(.*?)(\s+.*?)?\?&gt;/um</td>
        </tr>
        <tr class="top-aligned-row context-row">
          <td class="context-item-name">TAG_MATCH</td>
          <td>=</td>
          <td class="context-item-value">/^&lt;((?&gt;#{NAME_STR}))\s*((?&gt;\s+#{UNAME_STR}\s*=\s*([&quot;']).*?\5)*)\s*(\/)?&gt;/um</td>
        </tr>
        <tr class="top-aligned-row context-row">
          <td class="context-item-name">CLOSE_MATCH</td>
          <td>=</td>
          <td class="context-item-value">/^\s*&lt;\/(#{NAME_STR})\s*&gt;/um</td>
        </tr>
        <tr class="top-aligned-row context-row">
          <td class="context-item-name">VERSION</td>
          <td>=</td>
          <td class="context-item-value">/\bversion\s*=\s*[&quot;'](.*?)['&quot;]/um</td>
        </tr>
        <tr class="top-aligned-row context-row">
          <td class="context-item-name">ENCODING</td>
          <td>=</td>
          <td class="context-item-value">/\bencoding\s*=\s*[&quot;'](.*?)['&quot;]/um</td>
        </tr>
        <tr class="top-aligned-row context-row">
          <td class="context-item-name">STANDALONE</td>
          <td>=</td>
          <td class="context-item-value">/\bstandalone\s*=\s[&quot;'](.*?)['&quot;]/um</td>
        </tr>
        <tr class="top-aligned-row context-row">
          <td class="context-item-name">ENTITY_START</td>
          <td>=</td>
          <td class="context-item-value">/^\s*&lt;!ENTITY/</td>
        </tr>
        <tr class="top-aligned-row context-row">
          <td class="context-item-name">IDENTITY</td>
          <td>=</td>
          <td class="context-item-value">/^([!\*\w\-]+)(\s+#{NCNAME_STR})?(\s+[&quot;'](.*?)['&quot;])?(\s+['&quot;](.*?)[&quot;'])?/u</td>
        </tr>
        <tr class="top-aligned-row context-row">
          <td class="context-item-name">ELEMENTDECL_START</td>
          <td>=</td>
          <td class="context-item-value">/^\s*&lt;!ELEMENT/um</td>
        </tr>
        <tr class="top-aligned-row context-row">
          <td class="context-item-name">ELEMENTDECL_PATTERN</td>
          <td>=</td>
          <td class="context-item-value">/^\s*(&lt;!ELEMENT.*?)&gt;/um</td>
        </tr>
        <tr class="top-aligned-row context-row">
          <td class="context-item-name">SYSTEMENTITY</td>
          <td>=</td>
          <td class="context-item-value">/^\s*(%.*?;)\s*$/um</td>
        </tr>
        <tr class="top-aligned-row context-row">
          <td class="context-item-name">ENUMERATION</td>
          <td>=</td>
          <td class="context-item-value">&quot;\\(\\s*#{NMTOKEN}(?:\\s*\\|\\s*#{NMTOKEN})*\\s*\\)&quot;</td>
        </tr>
        <tr class="top-aligned-row context-row">
          <td class="context-item-name">NOTATIONTYPE</td>
          <td>=</td>
          <td class="context-item-value">&quot;NOTATION\\s+\\(\\s*#{NAME}(?:\\s*\\|\\s*#{NAME})*\\s*\\)&quot;</td>
        </tr>
        <tr class="top-aligned-row context-row">
          <td class="context-item-name">ENUMERATEDTYPE</td>
          <td>=</td>
          <td class="context-item-value">&quot;(?:(?:#{NOTATIONTYPE})|(?:#{ENUMERATION}))&quot;</td>
        </tr>
        <tr class="top-aligned-row context-row">
          <td class="context-item-name">ATTTYPE</td>
          <td>=</td>
          <td class="context-item-value">&quot;(CDATA|ID|IDREF|IDREFS|ENTITY|ENTITIES|NMTOKEN|NMTOKENS|#{ENUMERATEDTYPE})&quot;</td>
        </tr>
        <tr class="top-aligned-row context-row">
          <td class="context-item-name">ATTVALUE</td>
          <td>=</td>
          <td class="context-item-value">&quot;(?:\&quot;((?:[^&lt;&amp;\&quot;]|#{REFERENCE})*)\&quot;)|(?:'((?:[^&lt;&amp;']|#{REFERENCE})*)')&quot;</td>
        </tr>
        <tr class="top-aligned-row context-row">
          <td class="context-item-name">DEFAULTDECL</td>
          <td>=</td>
          <td class="context-item-value">&quot;(#REQUIRED|#IMPLIED|(?:(#FIXED\\s+)?#{ATTVALUE}))&quot;</td>
        </tr>
        <tr class="top-aligned-row context-row">
          <td class="context-item-name">ATTDEF</td>
          <td>=</td>
          <td class="context-item-value">&quot;\\s+#{NAME}\\s+#{ATTTYPE}\\s+#{DEFAULTDECL}&quot;</td>
        </tr>
        <tr class="top-aligned-row context-row">
          <td class="context-item-name">ATTDEF_RE</td>
          <td>=</td>
          <td class="context-item-value">/#{ATTDEF}/</td>
        </tr>
        <tr class="top-aligned-row context-row">
          <td class="context-item-name">ATTLISTDECL_START</td>
          <td>=</td>
          <td class="context-item-value">/^\s*&lt;!ATTLIST/um</td>
        </tr>
        <tr class="top-aligned-row context-row">
          <td class="context-item-name">ATTLISTDECL_PATTERN</td>
          <td>=</td>
          <td class="context-item-value">/^\s*&lt;!ATTLIST\s+#{NAME}(?:#{ATTDEF})*\s*&gt;/um</td>
        </tr>
        <tr class="top-aligned-row context-row">
          <td class="context-item-name">NOTATIONDECL_START</td>
          <td>=</td>
          <td class="context-item-value">/^\s*&lt;!NOTATION/um</td>
        </tr>
        <tr class="top-aligned-row context-row">
          <td class="context-item-name">PUBLIC</td>
          <td>=</td>
          <td class="context-item-value">/^\s*&lt;!NOTATION\s+(\w[\-\w]*)\s+(PUBLIC)\s+([&quot;'])(.*?)\3(?:\s+([&quot;'])(.*?)\5)?\s*&gt;/um</td>
        </tr>
        <tr class="top-aligned-row context-row">
          <td class="context-item-name">SYSTEM</td>
          <td>=</td>
          <td class="context-item-value">/^\s*&lt;!NOTATION\s+(\w[\-\w]*)\s+(SYSTEM)\s+([&quot;'])(.*?)\3\s*&gt;/um</td>
        </tr>
        <tr class="top-aligned-row context-row">
          <td class="context-item-name">TEXT_PATTERN</td>
          <td>=</td>
          <td class="context-item-value">/\A([^&lt;]*)/um</td>
        </tr>
        <tr class="top-aligned-row context-row">
          <td class="context-item-name">PUBIDCHAR</td>
          <td>=</td>
          <td class="context-item-value">&quot;\x20\x0D\x0Aa-zA-Z0-9\\-()+,./:=?;!*@$_%#&quot;</td>
          <td width="3em">&nbsp;</td>
          <td class="context-item-desc">
<a href="../Entity.html">Entity</a> constants

</td>
        </tr>
        <tr class="top-aligned-row context-row">
          <td class="context-item-name">SYSTEMLITERAL</td>
          <td>=</td>
          <td class="context-item-value">%Q{((?:&quot;[^&quot;]*&quot;)|(?:'[^']*'))}</td>
        </tr>
        <tr class="top-aligned-row context-row">
          <td class="context-item-name">PUBIDLITERAL</td>
          <td>=</td>
          <td class="context-item-value">%Q{(&quot;[#{PUBIDCHAR}']*&quot;|'[#{PUBIDCHAR}]*')}</td>
        </tr>
        <tr class="top-aligned-row context-row">
          <td class="context-item-name">EXTERNALID</td>
          <td>=</td>
          <td class="context-item-value">&quot;(?:(?:(SYSTEM)\\s+#{SYSTEMLITERAL})|(?:(PUBLIC)\\s+#{PUBIDLITERAL}\\s+#{SYSTEMLITERAL}))&quot;</td>
        </tr>
        <tr class="top-aligned-row context-row">
          <td class="context-item-name">NDATADECL</td>
          <td>=</td>
          <td class="context-item-value">&quot;\\s+NDATA\\s+#{NAME}&quot;</td>
        </tr>
        <tr class="top-aligned-row context-row">
          <td class="context-item-name">PEREFERENCE</td>
          <td>=</td>
          <td class="context-item-value">&quot;%#{NAME};&quot;</td>
        </tr>
        <tr class="top-aligned-row context-row">
          <td class="context-item-name">ENTITYVALUE</td>
          <td>=</td>
          <td class="context-item-value">%Q{((?:&quot;(?:[^%&amp;&quot;]|#{PEREFERENCE}|#{REFERENCE})*&quot;)|(?:'([^%&amp;']|#{PEREFERENCE}|#{REFERENCE})*'))}</td>
        </tr>
        <tr class="top-aligned-row context-row">
          <td class="context-item-name">PEDEF</td>
          <td>=</td>
          <td class="context-item-value">&quot;(?:#{ENTITYVALUE}|#{EXTERNALID})&quot;</td>
        </tr>
        <tr class="top-aligned-row context-row">
          <td class="context-item-name">ENTITYDEF</td>
          <td>=</td>
          <td class="context-item-value">&quot;(?:#{ENTITYVALUE}|(?:#{EXTERNALID}(#{NDATADECL})?))&quot;</td>
        </tr>
        <tr class="top-aligned-row context-row">
          <td class="context-item-name">PEDECL</td>
          <td>=</td>
          <td class="context-item-value">&quot;&lt;!ENTITY\\s+(%)\\s+#{NAME}\\s+#{PEDEF}\\s*&gt;&quot;</td>
        </tr>
        <tr class="top-aligned-row context-row">
          <td class="context-item-name">GEDECL</td>
          <td>=</td>
          <td class="context-item-value">&quot;&lt;!ENTITY\\s+#{NAME}\\s+#{ENTITYDEF}\\s*&gt;&quot;</td>
        </tr>
        <tr class="top-aligned-row context-row">
          <td class="context-item-name">ENTITYDECL</td>
          <td>=</td>
          <td class="context-item-value">/\s*(?:#{GEDECL})|(?:#{PEDECL})/um</td>
        </tr>
        <tr class="top-aligned-row context-row">
          <td class="context-item-name">EREFERENCE</td>
          <td>=</td>
          <td class="context-item-value">/&amp;(?!#{NAME};)/</td>
        </tr>
        <tr class="top-aligned-row context-row">
          <td class="context-item-name">DEFAULT_ENTITIES</td>
          <td>=</td>
          <td class="context-item-value">{          'gt' =&gt; [/&amp;gt;/, '&amp;gt;', '&gt;', /&gt;/],          'lt' =&gt; [/&amp;lt;/, '&amp;lt;', '&lt;', /&lt;/],          'quot' =&gt; [/&amp;quot;/, '&amp;quot;', '&quot;', /&quot;/],          &quot;apos&quot; =&gt; [/&amp;apos;/, &quot;&amp;apos;&quot;, &quot;'&quot;, /'/]</td>
        </tr>
        <tr class="top-aligned-row context-row">
          <td class="context-item-name">MISSING_ATTRIBUTE_QUOTES</td>
          <td>=</td>
          <td class="context-item-value">/^&lt;#{NAME_STR}\s+#{NAME_STR}\s*=\s*[^&quot;']/um</td>
          <td width="3em">&nbsp;</td>
          <td class="context-item-desc">
These are patterns to identify common markup errors, to make the error
messages more informative.

</td>
        </tr>
        </table>
      </div>
    </div>



    <div id="attribute-list">
      <h3 class="section-bar">Attributes</h3>

      <div class="name-list">
        <table>
        <tr class="top-aligned-row context-row">
          <td class="context-item-name">source</td>
          <td class="context-item-value">&nbsp;[R]&nbsp;</td>
          <td class="context-item-desc"></td>
        </tr>
        </table>
      </div>
    </div>
      


    <!-- if method_list -->
    <div id="methods">
      <h3 class="section-bar">Public Class methods</h3>

      <div id="method-M002540" class="m-detail">
        <a name="M002540"></a>

        <div class="method-heading">
          <a href="#M002540" class="method-signature">
          <span class="method-name">new</span><span class="method-args">( source )</span>
          </a>
        </div>
      
        <div class="m-description">
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M002540-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M002540-source">
<pre>
<span class="ruby-comment cmt"># File rexml/parsers/baseparser.rb, line 109</span>
      <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">initialize</span>( <span class="ruby-identifier">source</span> )
        <span class="ruby-keyword kw">self</span>.<span class="ruby-identifier">stream</span> = <span class="ruby-identifier">source</span>
      <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>

      <h3 class="section-bar">Public Instance methods</h3>

      <div id="method-M002541" class="m-detail">
        <a name="M002541"></a>

        <div class="method-heading">
          <a href="#M002541" class="method-signature">
          <span class="method-name">add_listener</span><span class="method-args">( listener )</span>
          </a>
        </div>
      
        <div class="m-description">
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M002541-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M002541-source">
<pre>
<span class="ruby-comment cmt"># File rexml/parsers/baseparser.rb, line 113</span>
      <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">add_listener</span>( <span class="ruby-identifier">listener</span> )
        <span class="ruby-keyword kw">if</span> <span class="ruby-operator">!</span><span class="ruby-keyword kw">defined?</span>(<span class="ruby-ivar">@listeners</span>) <span class="ruby-keyword kw">or</span> <span class="ruby-operator">!</span><span class="ruby-ivar">@listeners</span>
          <span class="ruby-ivar">@listeners</span> = []
          <span class="ruby-identifier">instance_eval</span> <span class="ruby-value str">&quot;alias :_old_pull :pull\ndef pull\nevent = _old_pull\n@listeners.each do |listener|\nlistener.receive event\nend\nevent\nend\n&quot;</span>
        <span class="ruby-keyword kw">end</span>
        <span class="ruby-ivar">@listeners</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">listener</span>
      <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>

      <div id="method-M002544" class="m-detail">
        <a name="M002544"></a>

        <div class="method-heading">
          <a href="#M002544" class="method-signature">
          <span class="method-name">empty?</span><span class="method-args">()</span>
          </a>
        </div>
      
        <div class="m-description">
          <p>
Returns true if there are no more events
</p>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M002544-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M002544-source">
<pre>
<span class="ruby-comment cmt"># File rexml/parsers/baseparser.rb, line 153</span>
      <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">empty?</span>
        <span class="ruby-keyword kw">return</span> (<span class="ruby-ivar">@source</span>.<span class="ruby-identifier">empty?</span> <span class="ruby-keyword kw">and</span> <span class="ruby-ivar">@stack</span>.<span class="ruby-identifier">empty?</span>)
      <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>

      <div id="method-M002549" class="m-detail">
        <a name="M002549"></a>

        <div class="method-heading">
          <a href="#M002549" class="method-signature">
          <span class="method-name">entity</span><span class="method-args">( reference, entities )</span>
          </a>
        </div>
      
        <div class="m-description">
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M002549-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M002549-source">
<pre>
<span class="ruby-comment cmt"># File rexml/parsers/baseparser.rb, line 424</span>
      <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">entity</span>( <span class="ruby-identifier">reference</span>, <span class="ruby-identifier">entities</span> )
        <span class="ruby-identifier">value</span> = <span class="ruby-keyword kw">nil</span>
        <span class="ruby-identifier">value</span> = <span class="ruby-identifier">entities</span>[ <span class="ruby-identifier">reference</span> ] <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">entities</span>
        <span class="ruby-keyword kw">if</span> <span class="ruby-keyword kw">not</span> <span class="ruby-identifier">value</span>
          <span class="ruby-identifier">value</span> = <span class="ruby-constant">DEFAULT_ENTITIES</span>[ <span class="ruby-identifier">reference</span> ]
          <span class="ruby-identifier">value</span> = <span class="ruby-identifier">value</span>[<span class="ruby-value">2</span>] <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">value</span>
        <span class="ruby-keyword kw">end</span>
        <span class="ruby-identifier">unnormalize</span>( <span class="ruby-identifier">value</span>, <span class="ruby-identifier">entities</span> ) <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">value</span>
      <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>

      <div id="method-M002545" class="m-detail">
        <a name="M002545"></a>

        <div class="method-heading">
          <a href="#M002545" class="method-signature">
          <span class="method-name">has_next?</span><span class="method-args">()</span>
          </a>
        </div>
      
        <div class="m-description">
          <p>
Returns true if there are more events. Synonymous with !<a
href="BaseParser.html#M002544">empty?</a>
</p>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M002545-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M002545-source">
<pre>
<span class="ruby-comment cmt"># File rexml/parsers/baseparser.rb, line 158</span>
      <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">has_next?</span>
        <span class="ruby-keyword kw">return</span> <span class="ruby-operator">!</span>(<span class="ruby-ivar">@source</span>.<span class="ruby-identifier">empty?</span> <span class="ruby-keyword kw">and</span> <span class="ruby-ivar">@stack</span>.<span class="ruby-identifier">empty?</span>)
      <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>

      <div id="method-M002550" class="m-detail">
        <a name="M002550"></a>

        <div class="method-heading">
          <a href="#M002550" class="method-signature">
          <span class="method-name">normalize</span><span class="method-args">( input, entities=nil, entity_filter=nil )</span>
          </a>
        </div>
      
        <div class="m-description">
          <p>
Escapes all possible entities
</p>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M002550-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M002550-source">
<pre>
<span class="ruby-comment cmt"># File rexml/parsers/baseparser.rb, line 435</span>
      <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">normalize</span>( <span class="ruby-identifier">input</span>, <span class="ruby-identifier">entities</span>=<span class="ruby-keyword kw">nil</span>, <span class="ruby-identifier">entity_filter</span>=<span class="ruby-keyword kw">nil</span> )
        <span class="ruby-identifier">copy</span> = <span class="ruby-identifier">input</span>.<span class="ruby-identifier">clone</span>
        <span class="ruby-comment cmt"># Doing it like this rather than in a loop improves the speed</span>
        <span class="ruby-identifier">copy</span>.<span class="ruby-identifier">gsub!</span>( <span class="ruby-constant">EREFERENCE</span>, <span class="ruby-value str">'&amp;amp;'</span> )
        <span class="ruby-identifier">entities</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword kw">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">key</span>, <span class="ruby-identifier">value</span><span class="ruby-operator">|</span>
          <span class="ruby-identifier">copy</span>.<span class="ruby-identifier">gsub!</span>( <span class="ruby-identifier">value</span>, <span class="ruby-node">&quot;&amp;#{key};&quot;</span> ) <span class="ruby-keyword kw">unless</span> <span class="ruby-identifier">entity_filter</span> <span class="ruby-keyword kw">and</span> 
                                      <span class="ruby-identifier">entity_filter</span>.<span class="ruby-identifier">include?</span>(<span class="ruby-identifier">entity</span>)
        <span class="ruby-keyword kw">end</span> <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">entities</span>
        <span class="ruby-identifier">copy</span>.<span class="ruby-identifier">gsub!</span>( <span class="ruby-constant">EREFERENCE</span>, <span class="ruby-value str">'&amp;amp;'</span> )
        <span class="ruby-constant">DEFAULT_ENTITIES</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword kw">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">key</span>, <span class="ruby-identifier">value</span><span class="ruby-operator">|</span>
          <span class="ruby-identifier">copy</span>.<span class="ruby-identifier">gsub!</span>( <span class="ruby-identifier">value</span>[<span class="ruby-value">3</span>], <span class="ruby-identifier">value</span>[<span class="ruby-value">1</span>] )
        <span class="ruby-keyword kw">end</span>
        <span class="ruby-identifier">copy</span>
      <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>

      <div id="method-M002547" class="m-detail">
        <a name="M002547"></a>

        <div class="method-heading">
          <a href="#M002547" class="method-signature">
          <span class="method-name">peek</span><span class="method-args">(depth=0)</span>
          </a>
        </div>
      
        <div class="m-description">
          <p>
Peek at the <tt>depth</tt> event in the stack. The first element on the
stack is at depth 0. If <tt>depth</tt> is -1, will parse to the end of the
input stream and return the last event, which is always :end_document. Be
aware that this causes the stream to be parsed up to the <tt>depth</tt>
event, so you can effectively pre-parse the entire document (<a
href="BaseParser.html#M002548">pull</a> the entire thing into memory) using
this method.
</p>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M002547-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M002547-source">
<pre>
<span class="ruby-comment cmt"># File rexml/parsers/baseparser.rb, line 174</span>
      <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">peek</span> <span class="ruby-identifier">depth</span>=<span class="ruby-value">0</span>
        <span class="ruby-identifier">raise</span> <span class="ruby-node">%Q[Illegal argument &quot;#{depth}&quot;]</span> <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">depth</span> <span class="ruby-operator">&lt;</span> <span class="ruby-value">-1</span>
        <span class="ruby-identifier">temp</span> = []
        <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">depth</span> <span class="ruby-operator">==</span> <span class="ruby-value">-1</span>
          <span class="ruby-identifier">temp</span>.<span class="ruby-identifier">push</span>(<span class="ruby-identifier">pull</span>()) <span class="ruby-keyword kw">until</span> <span class="ruby-identifier">empty?</span>
        <span class="ruby-keyword kw">else</span>
          <span class="ruby-keyword kw">while</span> <span class="ruby-ivar">@stack</span>.<span class="ruby-identifier">size</span><span class="ruby-operator">+</span><span class="ruby-identifier">temp</span>.<span class="ruby-identifier">size</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">depth</span><span class="ruby-operator">+</span><span class="ruby-value">1</span>
            <span class="ruby-identifier">temp</span>.<span class="ruby-identifier">push</span>(<span class="ruby-identifier">pull</span>())
          <span class="ruby-keyword kw">end</span>
        <span class="ruby-keyword kw">end</span>
        <span class="ruby-ivar">@stack</span> <span class="ruby-operator">+=</span> <span class="ruby-identifier">temp</span> <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">temp</span>.<span class="ruby-identifier">size</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">0</span>
        <span class="ruby-ivar">@stack</span>[<span class="ruby-identifier">depth</span>]
      <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>

      <div id="method-M002543" class="m-detail">
        <a name="M002543"></a>

        <div class="method-heading">
          <a href="#M002543" class="method-signature">
          <span class="method-name">position</span><span class="method-args">()</span>
          </a>
        </div>
      
        <div class="m-description">
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M002543-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M002543-source">
<pre>
<span class="ruby-comment cmt"># File rexml/parsers/baseparser.rb, line 143</span>
      <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">position</span>
        <span class="ruby-keyword kw">if</span> <span class="ruby-ivar">@source</span>.<span class="ruby-identifier">respond_to?</span> <span class="ruby-identifier">:position</span>
          <span class="ruby-ivar">@source</span>.<span class="ruby-identifier">position</span>
        <span class="ruby-keyword kw">else</span>
          <span class="ruby-comment cmt"># FIXME</span>
          <span class="ruby-value">0</span>
        <span class="ruby-keyword kw">end</span>
      <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>

      <div id="method-M002548" class="m-detail">
        <a name="M002548"></a>

        <div class="method-heading">
          <a href="#M002548" class="method-signature">
          <span class="method-name">pull</span><span class="method-args">()</span>
          </a>
        </div>
      
        <div class="m-description">
          <p>
Returns the next event. This is a <tt><a
href="PullEvent.html">PullEvent</a></tt> object.
</p>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M002548-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M002548-source">
<pre>
<span class="ruby-comment cmt"># File rexml/parsers/baseparser.rb, line 189</span>
      <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">pull</span>
        <span class="ruby-keyword kw">if</span> <span class="ruby-ivar">@closed</span>
          <span class="ruby-identifier">x</span>, <span class="ruby-ivar">@closed</span> = <span class="ruby-ivar">@closed</span>, <span class="ruby-keyword kw">nil</span>
          <span class="ruby-keyword kw">return</span> [ <span class="ruby-identifier">:end_element</span>, <span class="ruby-identifier">x</span> ]
        <span class="ruby-keyword kw">end</span>
        <span class="ruby-keyword kw">return</span> [ <span class="ruby-identifier">:end_document</span> ] <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">empty?</span>
        <span class="ruby-keyword kw">return</span> <span class="ruby-ivar">@stack</span>.<span class="ruby-identifier">shift</span> <span class="ruby-keyword kw">if</span> <span class="ruby-ivar">@stack</span>.<span class="ruby-identifier">size</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">0</span>
        <span class="ruby-comment cmt">#STDERR.puts @source.encoding</span>
        <span class="ruby-ivar">@source</span>.<span class="ruby-identifier">read</span> <span class="ruby-keyword kw">if</span> <span class="ruby-ivar">@source</span>.<span class="ruby-identifier">buffer</span>.<span class="ruby-identifier">size</span><span class="ruby-operator">&lt;</span><span class="ruby-value">2</span>
        <span class="ruby-comment cmt">#STDERR.puts &quot;BUFFER = #{@source.buffer.inspect}&quot;</span>
        <span class="ruby-keyword kw">if</span> <span class="ruby-ivar">@document_status</span> <span class="ruby-operator">==</span> <span class="ruby-keyword kw">nil</span>
          <span class="ruby-comment cmt">#@source.consume( /^\s*/um )</span>
          <span class="ruby-identifier">word</span> = <span class="ruby-ivar">@source</span>.<span class="ruby-identifier">match</span>( <span class="ruby-regexp re">/^((?:\s+)|(?:&lt;[^&gt;]*&gt;))/</span><span class="ruby-identifier">um</span> )
          <span class="ruby-identifier">word</span> = <span class="ruby-identifier">word</span>[<span class="ruby-value">1</span>] <span class="ruby-keyword kw">unless</span> <span class="ruby-identifier">word</span>.<span class="ruby-identifier">nil?</span>
          <span class="ruby-comment cmt">#STDERR.puts &quot;WORD = #{word.inspect}&quot;</span>
          <span class="ruby-keyword kw">case</span> <span class="ruby-identifier">word</span>
          <span class="ruby-keyword kw">when</span> <span class="ruby-constant">COMMENT_START</span>
            <span class="ruby-keyword kw">return</span> [ <span class="ruby-identifier">:comment</span>, <span class="ruby-ivar">@source</span>.<span class="ruby-identifier">match</span>( <span class="ruby-constant">COMMENT_PATTERN</span>, <span class="ruby-keyword kw">true</span> )[<span class="ruby-value">1</span>] ]
          <span class="ruby-keyword kw">when</span> <span class="ruby-constant">XMLDECL_START</span>
            <span class="ruby-comment cmt">#STDERR.puts &quot;XMLDECL&quot;</span>
            <span class="ruby-identifier">results</span> = <span class="ruby-ivar">@source</span>.<span class="ruby-identifier">match</span>( <span class="ruby-constant">XMLDECL_PATTERN</span>, <span class="ruby-keyword kw">true</span> )[<span class="ruby-value">1</span>]
            <span class="ruby-identifier">version</span> = <span class="ruby-constant">VERSION</span>.<span class="ruby-identifier">match</span>( <span class="ruby-identifier">results</span> )
            <span class="ruby-identifier">version</span> = <span class="ruby-identifier">version</span>[<span class="ruby-value">1</span>] <span class="ruby-keyword kw">unless</span> <span class="ruby-identifier">version</span>.<span class="ruby-identifier">nil?</span>
            <span class="ruby-identifier">encoding</span> = <span class="ruby-constant">ENCODING</span>.<span class="ruby-identifier">match</span>(<span class="ruby-identifier">results</span>)
            <span class="ruby-identifier">encoding</span> = <span class="ruby-identifier">encoding</span>[<span class="ruby-value">1</span>] <span class="ruby-keyword kw">unless</span> <span class="ruby-identifier">encoding</span>.<span class="ruby-identifier">nil?</span>
            <span class="ruby-ivar">@source</span>.<span class="ruby-identifier">encoding</span> = <span class="ruby-identifier">encoding</span>
            <span class="ruby-identifier">standalone</span> = <span class="ruby-constant">STANDALONE</span>.<span class="ruby-identifier">match</span>(<span class="ruby-identifier">results</span>)
            <span class="ruby-identifier">standalone</span> = <span class="ruby-identifier">standalone</span>[<span class="ruby-value">1</span>] <span class="ruby-keyword kw">unless</span> <span class="ruby-identifier">standalone</span>.<span class="ruby-identifier">nil?</span>
            <span class="ruby-keyword kw">return</span> [ <span class="ruby-identifier">:xmldecl</span>, <span class="ruby-identifier">version</span>, <span class="ruby-identifier">encoding</span>, <span class="ruby-identifier">standalone</span> ]
          <span class="ruby-keyword kw">when</span> <span class="ruby-constant">INSTRUCTION_START</span>
            <span class="ruby-keyword kw">return</span> [ <span class="ruby-identifier">:processing_instruction</span>, <span class="ruby-operator">*</span><span class="ruby-ivar">@source</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">INSTRUCTION_PATTERN</span>, <span class="ruby-keyword kw">true</span>)[<span class="ruby-value">1</span>,<span class="ruby-value">2</span>] ]
          <span class="ruby-keyword kw">when</span> <span class="ruby-constant">DOCTYPE_START</span>
            <span class="ruby-identifier">md</span> = <span class="ruby-ivar">@source</span>.<span class="ruby-identifier">match</span>( <span class="ruby-constant">DOCTYPE_PATTERN</span>, <span class="ruby-keyword kw">true</span> )
            <span class="ruby-ivar">@nsstack</span>.<span class="ruby-identifier">unshift</span>(<span class="ruby-identifier">curr_ns</span>=<span class="ruby-constant">Set</span>.<span class="ruby-identifier">new</span>)
            <span class="ruby-identifier">identity</span> = <span class="ruby-identifier">md</span>[<span class="ruby-value">1</span>]
            <span class="ruby-identifier">close</span> = <span class="ruby-identifier">md</span>[<span class="ruby-value">2</span>]
            <span class="ruby-identifier">identity</span> <span class="ruby-operator">=~</span> <span class="ruby-constant">IDENTITY</span>
            <span class="ruby-identifier">name</span> = <span class="ruby-identifier">$1</span>
            <span class="ruby-identifier">raise</span> <span class="ruby-constant">REXML</span><span class="ruby-operator">::</span><span class="ruby-constant">ParseException</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value str">&quot;DOCTYPE is missing a name&quot;</span>) <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">name</span>.<span class="ruby-identifier">nil?</span>
            <span class="ruby-identifier">pub_sys</span> = <span class="ruby-identifier">$2</span>.<span class="ruby-identifier">nil?</span> <span class="ruby-value">? </span><span class="ruby-keyword kw">nil</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">$2</span>.<span class="ruby-identifier">strip</span>
            <span class="ruby-identifier">long_name</span> = <span class="ruby-identifier">$4</span>.<span class="ruby-identifier">nil?</span> <span class="ruby-value">? </span><span class="ruby-keyword kw">nil</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">$4</span>.<span class="ruby-identifier">strip</span>
            <span class="ruby-identifier">uri</span> = <span class="ruby-identifier">$6</span>.<span class="ruby-identifier">nil?</span> <span class="ruby-value">? </span><span class="ruby-keyword kw">nil</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">$6</span>.<span class="ruby-identifier">strip</span>
            <span class="ruby-identifier">args</span> = [ <span class="ruby-identifier">:start_doctype</span>, <span class="ruby-identifier">name</span>, <span class="ruby-identifier">pub_sys</span>, <span class="ruby-identifier">long_name</span>, <span class="ruby-identifier">uri</span> ]
            <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">close</span> <span class="ruby-operator">==</span> <span class="ruby-value str">&quot;&gt;&quot;</span>
              <span class="ruby-ivar">@document_status</span> = <span class="ruby-identifier">:after_doctype</span>
              <span class="ruby-ivar">@source</span>.<span class="ruby-identifier">read</span> <span class="ruby-keyword kw">if</span> <span class="ruby-ivar">@source</span>.<span class="ruby-identifier">buffer</span>.<span class="ruby-identifier">size</span><span class="ruby-operator">&lt;</span><span class="ruby-value">2</span>
              <span class="ruby-identifier">md</span> = <span class="ruby-ivar">@source</span>.<span class="ruby-identifier">match</span>(<span class="ruby-regexp re">/^\s*/</span><span class="ruby-identifier">um</span>, <span class="ruby-keyword kw">true</span>)
              <span class="ruby-ivar">@stack</span> <span class="ruby-operator">&lt;&lt;</span> [ <span class="ruby-identifier">:end_doctype</span> ]
            <span class="ruby-keyword kw">else</span>
              <span class="ruby-ivar">@document_status</span> = <span class="ruby-identifier">:in_doctype</span>
            <span class="ruby-keyword kw">end</span>
            <span class="ruby-keyword kw">return</span> <span class="ruby-identifier">args</span>
          <span class="ruby-keyword kw">when</span> <span class="ruby-regexp re">/^\s+/</span>
          <span class="ruby-keyword kw">else</span>
            <span class="ruby-ivar">@document_status</span> = <span class="ruby-identifier">:after_doctype</span>
            <span class="ruby-ivar">@source</span>.<span class="ruby-identifier">read</span> <span class="ruby-keyword kw">if</span> <span class="ruby-ivar">@source</span>.<span class="ruby-identifier">buffer</span>.<span class="ruby-identifier">size</span><span class="ruby-operator">&lt;</span><span class="ruby-value">2</span>
            <span class="ruby-identifier">md</span> = <span class="ruby-ivar">@source</span>.<span class="ruby-identifier">match</span>(<span class="ruby-regexp re">/\s*/</span><span class="ruby-identifier">um</span>, <span class="ruby-keyword kw">true</span>)
          <span class="ruby-keyword kw">end</span>
        <span class="ruby-keyword kw">end</span>
        <span class="ruby-keyword kw">if</span> <span class="ruby-ivar">@document_status</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">:in_doctype</span>
          <span class="ruby-identifier">md</span> = <span class="ruby-ivar">@source</span>.<span class="ruby-identifier">match</span>(<span class="ruby-regexp re">/\s*(.*?&gt;)/</span><span class="ruby-identifier">um</span>)
          <span class="ruby-keyword kw">case</span> <span class="ruby-identifier">md</span>[<span class="ruby-value">1</span>]
          <span class="ruby-keyword kw">when</span> <span class="ruby-constant">SYSTEMENTITY</span> 
            <span class="ruby-identifier">match</span> = <span class="ruby-ivar">@source</span>.<span class="ruby-identifier">match</span>( <span class="ruby-constant">SYSTEMENTITY</span>, <span class="ruby-keyword kw">true</span> )[<span class="ruby-value">1</span>]
            <span class="ruby-keyword kw">return</span> [ <span class="ruby-identifier">:externalentity</span>, <span class="ruby-identifier">match</span> ]

          <span class="ruby-keyword kw">when</span> <span class="ruby-constant">ELEMENTDECL_START</span>
            <span class="ruby-keyword kw">return</span> [ <span class="ruby-identifier">:elementdecl</span>, <span class="ruby-ivar">@source</span>.<span class="ruby-identifier">match</span>( <span class="ruby-constant">ELEMENTDECL_PATTERN</span>, <span class="ruby-keyword kw">true</span> )[<span class="ruby-value">1</span>] ]

          <span class="ruby-keyword kw">when</span> <span class="ruby-constant">ENTITY_START</span>
            <span class="ruby-identifier">match</span> = <span class="ruby-ivar">@source</span>.<span class="ruby-identifier">match</span>( <span class="ruby-constant">ENTITYDECL</span>, <span class="ruby-keyword kw">true</span> ).<span class="ruby-identifier">to_a</span>.<span class="ruby-identifier">compact</span>
            <span class="ruby-identifier">match</span>[<span class="ruby-value">0</span>] = <span class="ruby-identifier">:entitydecl</span>
            <span class="ruby-identifier">ref</span> = <span class="ruby-keyword kw">false</span>
            <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">match</span>[<span class="ruby-value">1</span>] <span class="ruby-operator">==</span> <span class="ruby-value str">'%'</span>
              <span class="ruby-identifier">ref</span> = <span class="ruby-keyword kw">true</span>
              <span class="ruby-identifier">match</span>.<span class="ruby-identifier">delete_at</span> <span class="ruby-value">1</span>
            <span class="ruby-keyword kw">end</span>
            <span class="ruby-comment cmt"># Now we have to sort out what kind of entity reference this is</span>
            <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">match</span>[<span class="ruby-value">2</span>] <span class="ruby-operator">==</span> <span class="ruby-value str">'SYSTEM'</span>
              <span class="ruby-comment cmt"># External reference</span>
              <span class="ruby-identifier">match</span>[<span class="ruby-value">3</span>] = <span class="ruby-identifier">match</span>[<span class="ruby-value">3</span>][<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">-2</span>] <span class="ruby-comment cmt"># PUBID</span>
              <span class="ruby-identifier">match</span>.<span class="ruby-identifier">delete_at</span>(<span class="ruby-value">4</span>) <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">match</span>.<span class="ruby-identifier">size</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">4</span> <span class="ruby-comment cmt"># Chop out NDATA decl</span>
              <span class="ruby-comment cmt"># match is [ :entity, name, SYSTEM, pubid(, ndata)? ]</span>
            <span class="ruby-keyword kw">elsif</span> <span class="ruby-identifier">match</span>[<span class="ruby-value">2</span>] <span class="ruby-operator">==</span> <span class="ruby-value str">'PUBLIC'</span>
              <span class="ruby-comment cmt"># External reference</span>
              <span class="ruby-identifier">match</span>[<span class="ruby-value">3</span>] = <span class="ruby-identifier">match</span>[<span class="ruby-value">3</span>][<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">-2</span>] <span class="ruby-comment cmt"># PUBID</span>
              <span class="ruby-identifier">match</span>[<span class="ruby-value">4</span>] = <span class="ruby-identifier">match</span>[<span class="ruby-value">4</span>][<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">-2</span>] <span class="ruby-comment cmt"># HREF</span>
              <span class="ruby-comment cmt"># match is [ :entity, name, PUBLIC, pubid, href ]</span>
            <span class="ruby-keyword kw">else</span>
              <span class="ruby-identifier">match</span>[<span class="ruby-value">2</span>] = <span class="ruby-identifier">match</span>[<span class="ruby-value">2</span>][<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">-2</span>]
              <span class="ruby-identifier">match</span>.<span class="ruby-identifier">pop</span> <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">match</span>.<span class="ruby-identifier">size</span> <span class="ruby-operator">==</span> <span class="ruby-value">4</span>
              <span class="ruby-comment cmt"># match is [ :entity, name, value ]</span>
            <span class="ruby-keyword kw">end</span>
            <span class="ruby-identifier">match</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-value str">'%'</span> <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">ref</span>
            <span class="ruby-keyword kw">return</span> <span class="ruby-identifier">match</span>
          <span class="ruby-keyword kw">when</span> <span class="ruby-constant">ATTLISTDECL_START</span>
            <span class="ruby-identifier">md</span> = <span class="ruby-ivar">@source</span>.<span class="ruby-identifier">match</span>( <span class="ruby-constant">ATTLISTDECL_PATTERN</span>, <span class="ruby-keyword kw">true</span> )
            <span class="ruby-identifier">raise</span> <span class="ruby-constant">REXML</span><span class="ruby-operator">::</span><span class="ruby-constant">ParseException</span>.<span class="ruby-identifier">new</span>( <span class="ruby-value str">&quot;Bad ATTLIST declaration!&quot;</span>, <span class="ruby-ivar">@source</span> ) <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">md</span>.<span class="ruby-identifier">nil?</span>
            <span class="ruby-identifier">element</span> = <span class="ruby-identifier">md</span>[<span class="ruby-value">1</span>]
            <span class="ruby-identifier">contents</span> = <span class="ruby-identifier">md</span>[<span class="ruby-value">0</span>]

            <span class="ruby-identifier">pairs</span> = {}
            <span class="ruby-identifier">values</span> = <span class="ruby-identifier">md</span>[<span class="ruby-value">0</span>].<span class="ruby-identifier">scan</span>( <span class="ruby-constant">ATTDEF_RE</span> )
            <span class="ruby-identifier">values</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword kw">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">attdef</span><span class="ruby-operator">|</span>
              <span class="ruby-keyword kw">unless</span> <span class="ruby-identifier">attdef</span>[<span class="ruby-value">3</span>] <span class="ruby-operator">==</span> <span class="ruby-value str">&quot;#IMPLIED&quot;</span>
                <span class="ruby-identifier">attdef</span>.<span class="ruby-identifier">compact!</span>
                <span class="ruby-identifier">val</span> = <span class="ruby-identifier">attdef</span>[<span class="ruby-value">3</span>]
                <span class="ruby-identifier">val</span> = <span class="ruby-identifier">attdef</span>[<span class="ruby-value">4</span>] <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">val</span> <span class="ruby-operator">==</span> <span class="ruby-value str">&quot;#FIXED &quot;</span>
                <span class="ruby-identifier">pairs</span>[<span class="ruby-identifier">attdef</span>[<span class="ruby-value">0</span>]] = <span class="ruby-identifier">val</span>
                <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">attdef</span>[<span class="ruby-value">0</span>] <span class="ruby-operator">=~</span> <span class="ruby-regexp re">/^xmlns:(.*)/</span>
                  <span class="ruby-ivar">@nsstack</span>[<span class="ruby-value">0</span>] <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">$1</span>
                <span class="ruby-keyword kw">end</span>
              <span class="ruby-keyword kw">end</span>
            <span class="ruby-keyword kw">end</span>
            <span class="ruby-keyword kw">return</span> [ <span class="ruby-identifier">:attlistdecl</span>, <span class="ruby-identifier">element</span>, <span class="ruby-identifier">pairs</span>, <span class="ruby-identifier">contents</span> ]
          <span class="ruby-keyword kw">when</span> <span class="ruby-constant">NOTATIONDECL_START</span>
            <span class="ruby-identifier">md</span> = <span class="ruby-keyword kw">nil</span>
            <span class="ruby-keyword kw">if</span> <span class="ruby-ivar">@source</span>.<span class="ruby-identifier">match</span>( <span class="ruby-constant">PUBLIC</span> )
              <span class="ruby-identifier">md</span> = <span class="ruby-ivar">@source</span>.<span class="ruby-identifier">match</span>( <span class="ruby-constant">PUBLIC</span>, <span class="ruby-keyword kw">true</span> )
              <span class="ruby-identifier">vals</span> = [<span class="ruby-identifier">md</span>[<span class="ruby-value">1</span>],<span class="ruby-identifier">md</span>[<span class="ruby-value">2</span>],<span class="ruby-identifier">md</span>[<span class="ruby-value">4</span>],<span class="ruby-identifier">md</span>[<span class="ruby-value">6</span>]]
            <span class="ruby-keyword kw">elsif</span> <span class="ruby-ivar">@source</span>.<span class="ruby-identifier">match</span>( <span class="ruby-constant">SYSTEM</span> )
              <span class="ruby-identifier">md</span> = <span class="ruby-ivar">@source</span>.<span class="ruby-identifier">match</span>( <span class="ruby-constant">SYSTEM</span>, <span class="ruby-keyword kw">true</span> )
              <span class="ruby-identifier">vals</span> = [<span class="ruby-identifier">md</span>[<span class="ruby-value">1</span>],<span class="ruby-identifier">md</span>[<span class="ruby-value">2</span>],<span class="ruby-keyword kw">nil</span>,<span class="ruby-identifier">md</span>[<span class="ruby-value">4</span>]]
            <span class="ruby-keyword kw">else</span>
              <span class="ruby-identifier">raise</span> <span class="ruby-constant">REXML</span><span class="ruby-operator">::</span><span class="ruby-constant">ParseException</span>.<span class="ruby-identifier">new</span>( <span class="ruby-value str">&quot;error parsing notation: no matching pattern&quot;</span>, <span class="ruby-ivar">@source</span> )
            <span class="ruby-keyword kw">end</span>
            <span class="ruby-keyword kw">return</span> [ <span class="ruby-identifier">:notationdecl</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">vals</span> ]
          <span class="ruby-keyword kw">when</span> <span class="ruby-constant">CDATA_END</span>
            <span class="ruby-ivar">@document_status</span> = <span class="ruby-identifier">:after_doctype</span>
            <span class="ruby-ivar">@source</span>.<span class="ruby-identifier">match</span>( <span class="ruby-constant">CDATA_END</span>, <span class="ruby-keyword kw">true</span> )
            <span class="ruby-keyword kw">return</span> [ <span class="ruby-identifier">:end_doctype</span> ]
          <span class="ruby-keyword kw">end</span>
        <span class="ruby-keyword kw">end</span>
        <span class="ruby-keyword kw">begin</span>
          <span class="ruby-keyword kw">if</span> <span class="ruby-ivar">@source</span>.<span class="ruby-identifier">buffer</span>[<span class="ruby-value">0</span>] <span class="ruby-operator">==</span> <span class="ruby-value">?&lt;</span>
            <span class="ruby-keyword kw">if</span> <span class="ruby-ivar">@source</span>.<span class="ruby-identifier">buffer</span>[<span class="ruby-value">1</span>] <span class="ruby-operator">==</span> <span class="ruby-value">?/</span>
              <span class="ruby-ivar">@nsstack</span>.<span class="ruby-identifier">shift</span>
              <span class="ruby-identifier">last_tag</span> = <span class="ruby-ivar">@tags</span>.<span class="ruby-identifier">pop</span>
              <span class="ruby-comment cmt">#md = @source.match_to_consume( '&gt;', CLOSE_MATCH)</span>
              <span class="ruby-identifier">md</span> = <span class="ruby-ivar">@source</span>.<span class="ruby-identifier">match</span>( <span class="ruby-constant">CLOSE_MATCH</span>, <span class="ruby-keyword kw">true</span> )
              <span class="ruby-identifier">raise</span> <span class="ruby-constant">REXML</span><span class="ruby-operator">::</span><span class="ruby-constant">ParseException</span>.<span class="ruby-identifier">new</span>( <span class="ruby-value str">&quot;Missing end tag for &quot;</span><span class="ruby-operator">+</span>
                <span class="ruby-node">&quot;'#{last_tag}' (got \&quot;#{md[1]}\&quot;)&quot;</span>, 
                <span class="ruby-ivar">@source</span>) <span class="ruby-keyword kw">unless</span> <span class="ruby-identifier">last_tag</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">md</span>[<span class="ruby-value">1</span>]
              <span class="ruby-keyword kw">return</span> [ <span class="ruby-identifier">:end_element</span>, <span class="ruby-identifier">last_tag</span> ]
            <span class="ruby-keyword kw">elsif</span> <span class="ruby-ivar">@source</span>.<span class="ruby-identifier">buffer</span>[<span class="ruby-value">1</span>] <span class="ruby-operator">==</span> <span class="ruby-value">?!</span>
              <span class="ruby-identifier">md</span> = <span class="ruby-ivar">@source</span>.<span class="ruby-identifier">match</span>(<span class="ruby-regexp re">/\A(\s*[^&gt;]*&gt;)/</span><span class="ruby-identifier">um</span>)
              <span class="ruby-comment cmt">#STDERR.puts &quot;SOURCE BUFFER = #{source.buffer}, #{source.buffer.size}&quot;</span>
              <span class="ruby-identifier">raise</span> <span class="ruby-constant">REXML</span><span class="ruby-operator">::</span><span class="ruby-constant">ParseException</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value str">&quot;Malformed node&quot;</span>, <span class="ruby-ivar">@source</span>) <span class="ruby-keyword kw">unless</span> <span class="ruby-identifier">md</span>
              <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">md</span>[<span class="ruby-value">0</span>][<span class="ruby-value">2</span>] <span class="ruby-operator">==</span> <span class="ruby-value">?-</span>
                <span class="ruby-identifier">md</span> = <span class="ruby-ivar">@source</span>.<span class="ruby-identifier">match</span>( <span class="ruby-constant">COMMENT_PATTERN</span>, <span class="ruby-keyword kw">true</span> )
                <span class="ruby-keyword kw">return</span> [ <span class="ruby-identifier">:comment</span>, <span class="ruby-identifier">md</span>[<span class="ruby-value">1</span>] ] <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">md</span>
              <span class="ruby-keyword kw">else</span>
                <span class="ruby-identifier">md</span> = <span class="ruby-ivar">@source</span>.<span class="ruby-identifier">match</span>( <span class="ruby-constant">CDATA_PATTERN</span>, <span class="ruby-keyword kw">true</span> )
                <span class="ruby-keyword kw">return</span> [ <span class="ruby-identifier">:cdata</span>, <span class="ruby-identifier">md</span>[<span class="ruby-value">1</span>] ] <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">md</span>
              <span class="ruby-keyword kw">end</span>
              <span class="ruby-identifier">raise</span> <span class="ruby-constant">REXML</span><span class="ruby-operator">::</span><span class="ruby-constant">ParseException</span>.<span class="ruby-identifier">new</span>( <span class="ruby-value str">&quot;Declarations can only occur &quot;</span><span class="ruby-operator">+</span>
                <span class="ruby-value str">&quot;in the doctype declaration.&quot;</span>, <span class="ruby-ivar">@source</span>)
            <span class="ruby-keyword kw">elsif</span> <span class="ruby-ivar">@source</span>.<span class="ruby-identifier">buffer</span>[<span class="ruby-value">1</span>] <span class="ruby-operator">==</span> <span class="ruby-value">??</span>
              <span class="ruby-identifier">md</span> = <span class="ruby-ivar">@source</span>.<span class="ruby-identifier">match</span>( <span class="ruby-constant">INSTRUCTION_PATTERN</span>, <span class="ruby-keyword kw">true</span> )
              <span class="ruby-keyword kw">return</span> [ <span class="ruby-identifier">:processing_instruction</span>, <span class="ruby-identifier">md</span>[<span class="ruby-value">1</span>], <span class="ruby-identifier">md</span>[<span class="ruby-value">2</span>] ] <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">md</span>
              <span class="ruby-identifier">raise</span> <span class="ruby-constant">REXML</span><span class="ruby-operator">::</span><span class="ruby-constant">ParseException</span>.<span class="ruby-identifier">new</span>( <span class="ruby-value str">&quot;Bad instruction declaration&quot;</span>,
                <span class="ruby-ivar">@source</span>)
            <span class="ruby-keyword kw">else</span>
              <span class="ruby-comment cmt"># Get the next tag</span>
              <span class="ruby-identifier">md</span> = <span class="ruby-ivar">@source</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">TAG_MATCH</span>, <span class="ruby-keyword kw">true</span>)
              <span class="ruby-keyword kw">unless</span> <span class="ruby-identifier">md</span>
                <span class="ruby-comment cmt"># Check for missing attribute quotes</span>
                <span class="ruby-identifier">raise</span> <span class="ruby-constant">REXML</span><span class="ruby-operator">::</span><span class="ruby-constant">ParseException</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value str">&quot;missing attribute quote&quot;</span>, <span class="ruby-ivar">@source</span>) <span class="ruby-keyword kw">if</span> <span class="ruby-ivar">@source</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">MISSING_ATTRIBUTE_QUOTES</span> )
                <span class="ruby-identifier">raise</span> <span class="ruby-constant">REXML</span><span class="ruby-operator">::</span><span class="ruby-constant">ParseException</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value str">&quot;malformed XML: missing tag start&quot;</span>, <span class="ruby-ivar">@source</span>) 
              <span class="ruby-keyword kw">end</span>
              <span class="ruby-identifier">attributes</span> = {}
              <span class="ruby-identifier">prefixes</span> = <span class="ruby-constant">Set</span>.<span class="ruby-identifier">new</span>
              <span class="ruby-identifier">prefixes</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">md</span>[<span class="ruby-value">2</span>] <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">md</span>[<span class="ruby-value">2</span>]
              <span class="ruby-ivar">@nsstack</span>.<span class="ruby-identifier">unshift</span>(<span class="ruby-identifier">curr_ns</span>=<span class="ruby-constant">Set</span>.<span class="ruby-identifier">new</span>)
              <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">md</span>[<span class="ruby-value">4</span>].<span class="ruby-identifier">size</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">0</span>
                <span class="ruby-identifier">attrs</span> = <span class="ruby-identifier">md</span>[<span class="ruby-value">4</span>].<span class="ruby-identifier">scan</span>( <span class="ruby-constant">ATTRIBUTE_PATTERN</span> )
                <span class="ruby-identifier">raise</span> <span class="ruby-constant">REXML</span><span class="ruby-operator">::</span><span class="ruby-constant">ParseException</span>.<span class="ruby-identifier">new</span>( <span class="ruby-node">&quot;error parsing attributes: [#{attrs.join ', '}], excess = \&quot;#$'\&quot;&quot;</span>, <span class="ruby-ivar">@source</span>) <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">$'</span> <span class="ruby-keyword kw">and</span> <span class="ruby-identifier">$'</span>.<span class="ruby-identifier">strip</span>.<span class="ruby-identifier">size</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">0</span>
                <span class="ruby-identifier">attrs</span>.<span class="ruby-identifier">each</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">a</span>,<span class="ruby-identifier">b</span>,<span class="ruby-identifier">c</span>,<span class="ruby-identifier">d</span>,<span class="ruby-identifier">e</span><span class="ruby-operator">|</span> 
                  <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">b</span> <span class="ruby-operator">==</span> <span class="ruby-value str">&quot;xmlns&quot;</span>
                    <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">c</span> <span class="ruby-operator">==</span> <span class="ruby-value str">&quot;xml&quot;</span>
                      <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">d</span> <span class="ruby-operator">!=</span> <span class="ruby-value str">&quot;http://www.w3.org/XML/1998/namespace&quot;</span>
                        <span class="ruby-identifier">msg</span> = <span class="ruby-value str">&quot;The 'xml' prefix must not be bound to any other namespace &quot;</span><span class="ruby-operator">+</span>
                        <span class="ruby-value str">&quot;(http://www.w3.org/TR/REC-xml-names/#ns-decl)&quot;</span>
                        <span class="ruby-identifier">raise</span> <span class="ruby-constant">REXML</span><span class="ruby-operator">::</span><span class="ruby-constant">ParseException</span>.<span class="ruby-identifier">new</span>( <span class="ruby-identifier">msg</span>, <span class="ruby-ivar">@source</span>, <span class="ruby-keyword kw">self</span> )
                      <span class="ruby-keyword kw">end</span>
                    <span class="ruby-keyword kw">elsif</span> <span class="ruby-identifier">c</span> <span class="ruby-operator">==</span> <span class="ruby-value str">&quot;xmlns&quot;</span>
                      <span class="ruby-identifier">msg</span> = <span class="ruby-value str">&quot;The 'xmlns' prefix must not be declared &quot;</span><span class="ruby-operator">+</span>
                      <span class="ruby-value str">&quot;(http://www.w3.org/TR/REC-xml-names/#ns-decl)&quot;</span>
                      <span class="ruby-identifier">raise</span> <span class="ruby-constant">REXML</span><span class="ruby-operator">::</span><span class="ruby-constant">ParseException</span>.<span class="ruby-identifier">new</span>( <span class="ruby-identifier">msg</span>, <span class="ruby-ivar">@source</span>, <span class="ruby-keyword kw">self</span>)
                    <span class="ruby-keyword kw">end</span>
                    <span class="ruby-identifier">curr_ns</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">c</span>
                  <span class="ruby-keyword kw">elsif</span> <span class="ruby-identifier">b</span>
                    <span class="ruby-identifier">prefixes</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">b</span> <span class="ruby-keyword kw">unless</span> <span class="ruby-identifier">b</span> <span class="ruby-operator">==</span> <span class="ruby-value str">&quot;xml&quot;</span>
                  <span class="ruby-keyword kw">end</span>
                  <span class="ruby-identifier">attributes</span>[<span class="ruby-identifier">a</span>] = <span class="ruby-identifier">e</span> 
                }
              <span class="ruby-keyword kw">end</span>
        
              <span class="ruby-comment cmt"># Verify that all of the prefixes have been defined</span>
              <span class="ruby-keyword kw">for</span> <span class="ruby-identifier">prefix</span> <span class="ruby-keyword kw">in</span> <span class="ruby-identifier">prefixes</span>
                <span class="ruby-keyword kw">unless</span> <span class="ruby-ivar">@nsstack</span>.<span class="ruby-identifier">find</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">k</span><span class="ruby-operator">|</span> <span class="ruby-identifier">k</span>.<span class="ruby-identifier">member?</span>(<span class="ruby-identifier">prefix</span>)}
                  <span class="ruby-identifier">raise</span> <span class="ruby-constant">UndefinedNamespaceException</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">prefix</span>,<span class="ruby-ivar">@source</span>,<span class="ruby-keyword kw">self</span>)
                <span class="ruby-keyword kw">end</span>
              <span class="ruby-keyword kw">end</span>

              <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">md</span>[<span class="ruby-value">6</span>]
                <span class="ruby-ivar">@closed</span> = <span class="ruby-identifier">md</span>[<span class="ruby-value">1</span>]
                <span class="ruby-ivar">@nsstack</span>.<span class="ruby-identifier">shift</span>
              <span class="ruby-keyword kw">else</span>
                <span class="ruby-ivar">@tags</span>.<span class="ruby-identifier">push</span>( <span class="ruby-identifier">md</span>[<span class="ruby-value">1</span>] )
              <span class="ruby-keyword kw">end</span>
              <span class="ruby-keyword kw">return</span> [ <span class="ruby-identifier">:start_element</span>, <span class="ruby-identifier">md</span>[<span class="ruby-value">1</span>], <span class="ruby-identifier">attributes</span> ]
            <span class="ruby-keyword kw">end</span>
          <span class="ruby-keyword kw">else</span>
            <span class="ruby-identifier">md</span> = <span class="ruby-ivar">@source</span>.<span class="ruby-identifier">match</span>( <span class="ruby-constant">TEXT_PATTERN</span>, <span class="ruby-keyword kw">true</span> )
            <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">md</span>[<span class="ruby-value">0</span>].<span class="ruby-identifier">length</span> <span class="ruby-operator">==</span> <span class="ruby-value">0</span>
              <span class="ruby-ivar">@source</span>.<span class="ruby-identifier">match</span>( <span class="ruby-regexp re">/(\s+)/</span>, <span class="ruby-keyword kw">true</span> )
            <span class="ruby-keyword kw">end</span>
            <span class="ruby-comment cmt">#STDERR.puts &quot;GOT #{md[1].inspect}&quot; unless md[0].length == 0</span>
            <span class="ruby-comment cmt">#return [ :text, &quot;&quot; ] if md[0].length == 0</span>
            <span class="ruby-comment cmt"># unnormalized = Text::unnormalize( md[1], self )</span>
            <span class="ruby-comment cmt"># return PullEvent.new( :text, md[1], unnormalized )</span>
            <span class="ruby-keyword kw">return</span> [ <span class="ruby-identifier">:text</span>, <span class="ruby-identifier">md</span>[<span class="ruby-value">1</span>] ]
          <span class="ruby-keyword kw">end</span>
        <span class="ruby-keyword kw">rescue</span> <span class="ruby-constant">REXML</span><span class="ruby-operator">::</span><span class="ruby-constant">UndefinedNamespaceException</span>
          <span class="ruby-identifier">raise</span>
        <span class="ruby-keyword kw">rescue</span> <span class="ruby-constant">REXML</span><span class="ruby-operator">::</span><span class="ruby-constant">ParseException</span>
          <span class="ruby-identifier">raise</span>
        <span class="ruby-keyword kw">rescue</span> <span class="ruby-constant">Exception</span>, <span class="ruby-constant">NameError</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">error</span>
          <span class="ruby-identifier">raise</span> <span class="ruby-constant">REXML</span><span class="ruby-operator">::</span><span class="ruby-constant">ParseException</span>.<span class="ruby-identifier">new</span>( <span class="ruby-value str">&quot;Exception parsing&quot;</span>,
            <span class="ruby-ivar">@source</span>, <span class="ruby-keyword kw">self</span>, (<span class="ruby-identifier">error</span> <span class="ruby-value">? </span><span class="ruby-identifier">error</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">$!</span>) )
        <span class="ruby-keyword kw">end</span>
        <span class="ruby-keyword kw">return</span> [ <span class="ruby-identifier">:dummy</span> ]
      <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>

      <div id="method-M002542" class="m-detail">
        <a name="M002542"></a>

        <div class="method-heading">
          <a href="#M002542" class="method-signature">
          <span class="method-name">stream=</span><span class="method-args">( source )</span>
          </a>
        </div>
      
        <div class="m-description">
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M002542-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M002542-source">
<pre>
<span class="ruby-comment cmt"># File rexml/parsers/baseparser.rb, line 133</span>
      <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">stream=</span>( <span class="ruby-identifier">source</span> )
        <span class="ruby-ivar">@source</span> = <span class="ruby-constant">SourceFactory</span>.<span class="ruby-identifier">create_from</span>( <span class="ruby-identifier">source</span> )
        <span class="ruby-ivar">@closed</span> = <span class="ruby-keyword kw">nil</span>
        <span class="ruby-ivar">@document_status</span> = <span class="ruby-keyword kw">nil</span>
        <span class="ruby-ivar">@tags</span> = []
        <span class="ruby-ivar">@stack</span> = []
        <span class="ruby-ivar">@entities</span> = []
        <span class="ruby-ivar">@nsstack</span> = []
      <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>

      <div id="method-M002551" class="m-detail">
        <a name="M002551"></a>

        <div class="method-heading">
          <a href="#M002551" class="method-signature">
          <span class="method-name">unnormalize</span><span class="method-args">( string, entities=nil, filter=nil )</span>
          </a>
        </div>
      
        <div class="m-description">
          <p>
Unescapes all possible entities
</p>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M002551-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M002551-source">
<pre>
<span class="ruby-comment cmt"># File rexml/parsers/baseparser.rb, line 451</span>
      <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">unnormalize</span>( <span class="ruby-identifier">string</span>, <span class="ruby-identifier">entities</span>=<span class="ruby-keyword kw">nil</span>, <span class="ruby-identifier">filter</span>=<span class="ruby-keyword kw">nil</span> )
        <span class="ruby-identifier">rv</span> = <span class="ruby-identifier">string</span>.<span class="ruby-identifier">clone</span>
        <span class="ruby-identifier">rv</span>.<span class="ruby-identifier">gsub!</span>( <span class="ruby-regexp re">/\r\n?/</span>, <span class="ruby-value str">&quot;\n&quot;</span> )
        <span class="ruby-identifier">matches</span> = <span class="ruby-identifier">rv</span>.<span class="ruby-identifier">scan</span>( <span class="ruby-constant">REFERENCE_RE</span> )
        <span class="ruby-keyword kw">return</span> <span class="ruby-identifier">rv</span> <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">matches</span>.<span class="ruby-identifier">size</span> <span class="ruby-operator">==</span> <span class="ruby-value">0</span>
        <span class="ruby-identifier">rv</span>.<span class="ruby-identifier">gsub!</span>( <span class="ruby-regexp re">/&amp;#0*((?:\d+)|(?:x[a-fA-F0-9]+));/</span> ) {<span class="ruby-operator">|</span><span class="ruby-identifier">m</span><span class="ruby-operator">|</span>
          <span class="ruby-identifier">m</span>=<span class="ruby-identifier">$1</span>
          <span class="ruby-identifier">m</span> = <span class="ruby-node">&quot;0#{m}&quot;</span> <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">m</span>[<span class="ruby-value">0</span>] <span class="ruby-operator">==</span> <span class="ruby-value">?x</span>
          [<span class="ruby-constant">Integer</span>(<span class="ruby-identifier">m</span>)].<span class="ruby-identifier">pack</span>(<span class="ruby-value str">'U*'</span>)
        }
        <span class="ruby-identifier">matches</span>.<span class="ruby-identifier">collect!</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">x</span><span class="ruby-operator">|</span><span class="ruby-identifier">x</span>[<span class="ruby-value">0</span>]}.<span class="ruby-identifier">compact!</span>
        <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">matches</span>.<span class="ruby-identifier">size</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">0</span>
          <span class="ruby-identifier">matches</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword kw">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">entity_reference</span><span class="ruby-operator">|</span>
            <span class="ruby-keyword kw">unless</span> <span class="ruby-identifier">filter</span> <span class="ruby-keyword kw">and</span> <span class="ruby-identifier">filter</span>.<span class="ruby-identifier">include?</span>(<span class="ruby-identifier">entity_reference</span>)
              <span class="ruby-identifier">entity_value</span> = <span class="ruby-identifier">entity</span>( <span class="ruby-identifier">entity_reference</span>, <span class="ruby-identifier">entities</span> )
              <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">entity_value</span>
                <span class="ruby-identifier">re</span> = <span class="ruby-node">/&amp;#{entity_reference};/</span>
                <span class="ruby-identifier">rv</span>.<span class="ruby-identifier">gsub!</span>( <span class="ruby-identifier">re</span>, <span class="ruby-identifier">entity_value</span> )
              <span class="ruby-keyword kw">end</span>
            <span class="ruby-keyword kw">end</span>
          <span class="ruby-keyword kw">end</span>
          <span class="ruby-identifier">matches</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword kw">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">entity_reference</span><span class="ruby-operator">|</span>
            <span class="ruby-keyword kw">unless</span> <span class="ruby-identifier">filter</span> <span class="ruby-keyword kw">and</span> <span class="ruby-identifier">filter</span>.<span class="ruby-identifier">include?</span>(<span class="ruby-identifier">entity_reference</span>)
              <span class="ruby-identifier">er</span> = <span class="ruby-constant">DEFAULT_ENTITIES</span>[<span class="ruby-identifier">entity_reference</span>]
              <span class="ruby-identifier">rv</span>.<span class="ruby-identifier">gsub!</span>( <span class="ruby-identifier">er</span>[<span class="ruby-value">0</span>], <span class="ruby-identifier">er</span>[<span class="ruby-value">2</span>] ) <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">er</span>
            <span class="ruby-keyword kw">end</span>
          <span class="ruby-keyword kw">end</span>
          <span class="ruby-identifier">rv</span>.<span class="ruby-identifier">gsub!</span>( <span class="ruby-regexp re">/&amp;amp;/</span>, <span class="ruby-value str">'&amp;'</span> )
        <span class="ruby-keyword kw">end</span>
        <span class="ruby-identifier">rv</span>
      <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>

      <div id="method-M002546" class="m-detail">
        <a name="M002546"></a>

        <div class="method-heading">
          <a href="#M002546" class="method-signature">
          <span class="method-name">unshift</span><span class="method-args">(token)</span>
          </a>
        </div>
      
        <div class="m-description">
          <p>
Push an event back on the head of the stream. This method has
(theoretically) infinite depth.
</p>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M002546-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M002546-source">
<pre>
<span class="ruby-comment cmt"># File rexml/parsers/baseparser.rb, line 164</span>
      <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">unshift</span> <span class="ruby-identifier">token</span>
        <span class="ruby-ivar">@stack</span>.<span class="ruby-identifier">unshift</span>(<span class="ruby-identifier">token</span>)
      <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>


    </div>


  </div>


<div id="validator-badges">
  <p><small><a href="http://validator.w3.org/check/referer">[Validate]</a></small></p>
</div>
<div id='credits' style='font-size:smaller' >
<!-- 1  --><p> <a href='http://www.ruby-doc.org'>ruby-doc.org</a> is hosted and maintained by <a href='http://www.jamesbritt.com'>James Britt</a> and <a href='http://www.happycamperstudios.com'>Happy Camper Studios</a>, a <a href='http://www.happycamperstudios.com'> Ruby application development company in Phoenix, Arizona</a>. The site was created in 2002 as part of the Ruby Documentation Project to promote the Ruby language and to help other Ruby hackers.</p>
 <p>Documentation content on ruby-doc.org is provided by <a href='http://www.ruby-doc.org/about'>remarkable members</a> of the Ruby community.</p>
<p>For more information on the Ruby programming language, visit <a href='http://www.ruby-lang.org'>ruby-lang.org</a>.</p>
<p>Want to help improve Ruby's API docs? See <a href='/documentation-guidelines.html'> Ruby Documentation Guidelines</a>.</p>
</div>

</body>
</html>