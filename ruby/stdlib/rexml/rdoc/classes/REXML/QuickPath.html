<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html 
     PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
     "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>Class: REXML::QuickPath</title>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
  <meta http-equiv="Content-Script-Type" content="text/javascript" />
  <link rel="stylesheet" href="../.././rdoc-style.css" type="text/css" media="screen" />
  <script type="text/javascript">
  // <![CDATA[

  function popupCode( url ) {
    window.open(url, "Code", "resizable=yes,scrollbars=yes,toolbar=no,status=no,height=150,width=400")
  }

  function toggleCode( id ) {
    if ( document.getElementById )
      elem = document.getElementById( id );
    else if ( document.all )
      elem = eval( "document.all." + id );
    else
      return false;

    elemStyle = elem.style;
    
    if ( elemStyle.display != "block" ) {
      elemStyle.display = "block"
    } else {
      elemStyle.display = "none"
    }

    return true;
  }
  
  // Make codeblocks hidden by default
  document.writeln( "<style type=\"text/css\">div.method-source-code { display: none }</style>" )
  
  // ]]>
  </script>

</head>
<body>



    <div id="classHeader">
        <table class="header-table">
        <tr class="top-aligned-row">
          <td><strong>Class</strong></td>
          <td class="class-name-in-header">REXML::QuickPath</td>
        </tr>
        <tr class="top-aligned-row">
            <td><strong>In:</strong></td>
            <td>
                <a href="../../files/rexml/quickpath_rb.html">
                rexml/quickpath.rb
                </a>
        <br />
            </td>
        </tr>

        <tr class="top-aligned-row">
            <td><strong>Parent:</strong></td>
            <td>
                <a href="../Object.html">
                Object
               </a>
            </td>
        </tr>
        </table>
    </div>
  <!-- banner header -->

  <div id="bodyContent">



  <div id="contextContent">



   </div>

    <div id="method-list">
      <h3 class="section-bar">Methods</h3>

      <div class="name-list">
      <a href="#M002784">attribute</a>&nbsp;&nbsp;
      <a href="#M002782">axe</a>&nbsp;&nbsp;
      <a href="#M002779">each</a>&nbsp;&nbsp;
      <a href="#M002781">filter</a>&nbsp;&nbsp;
      <a href="#M002778">first</a>&nbsp;&nbsp;
      <a href="#M002787">function</a>&nbsp;&nbsp;
      <a href="#M002780">match</a>&nbsp;&nbsp;
      <a href="#M002786">method_missing</a>&nbsp;&nbsp;
      <a href="#M002785">name</a>&nbsp;&nbsp;
      <a href="#M002788">parse_args</a>&nbsp;&nbsp;
      <a href="#M002783">predicate</a>&nbsp;&nbsp;
      </div>
    </div>

  </div>


    <!-- if includes -->
    <div id="includes">
      <h3 class="section-bar">Included Modules</h3>

      <div id="includes-list">
        <span class="include-name"><a href="Functions.html">Functions</a></span>
        <span class="include-name"><a href="XMLTokens.html">XMLTokens</a></span>
      </div>
    </div>

    <div id="section">


    <div id="constants-list">
      <h3 class="section-bar">Constants</h3>

      <div class="name-list">
        <table summary="Constants">
        <tr class="top-aligned-row context-row">
          <td class="context-item-name">EMPTY_HASH</td>
          <td>=</td>
          <td class="context-item-value">{}</td>
        </tr>
        </table>
      </div>
    </div>



      


    <!-- if method_list -->
    <div id="methods">
      <h3 class="section-bar">Public Class methods</h3>

      <div id="method-M002784" class="m-detail">
        <a name="M002784"></a>

        <div class="method-heading">
          <a href="#M002784" class="method-signature">
          <span class="method-name">attribute</span><span class="method-args">( name )</span>
          </a>
        </div>
      
        <div class="m-description">
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M002784-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M002784-source">
<pre>
<span class="ruby-comment cmt"># File rexml/quickpath.rb, line 206</span>
                <span class="ruby-keyword kw">def</span> <span class="ruby-constant">QuickPath</span><span class="ruby-operator">::</span><span class="ruby-identifier">attribute</span>( <span class="ruby-identifier">name</span> )
                        <span class="ruby-keyword kw">return</span> <span class="ruby-constant">Functions</span>.<span class="ruby-identifier">node</span>.<span class="ruby-identifier">attributes</span>[<span class="ruby-identifier">name</span>] <span class="ruby-keyword kw">if</span> <span class="ruby-constant">Functions</span>.<span class="ruby-identifier">node</span>.<span class="ruby-identifier">kind_of?</span> <span class="ruby-constant">Element</span>
                <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>

      <div id="method-M002782" class="m-detail">
        <a name="M002782"></a>

        <div class="method-heading">
          <a href="#M002782" class="method-signature">
          <span class="method-name">axe</span><span class="method-args">( elements, axe_name, rest )</span>
          </a>
        </div>
      
        <div class="m-description">
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M002782-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M002782-source">
<pre>
<span class="ruby-comment cmt"># File rexml/quickpath.rb, line 106</span>
                <span class="ruby-keyword kw">def</span> <span class="ruby-constant">QuickPath</span><span class="ruby-operator">::</span><span class="ruby-identifier">axe</span>( <span class="ruby-identifier">elements</span>, <span class="ruby-identifier">axe_name</span>, <span class="ruby-identifier">rest</span> )
                        <span class="ruby-identifier">matches</span> = []
                        <span class="ruby-identifier">matches</span> = <span class="ruby-identifier">filter</span>( <span class="ruby-identifier">elements</span>.<span class="ruby-identifier">dup</span>, <span class="ruby-identifier">rest</span> ) <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">axe_name</span> <span class="ruby-operator">=~</span> <span class="ruby-regexp re">/-or-self$/</span><span class="ruby-identifier">u</span>
                        <span class="ruby-keyword kw">case</span> <span class="ruby-identifier">axe_name</span>
                        <span class="ruby-keyword kw">when</span> <span class="ruby-regexp re">/^descendant/</span><span class="ruby-identifier">u</span>
                                <span class="ruby-identifier">elements</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword kw">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">element</span><span class="ruby-operator">|</span>
                                        <span class="ruby-identifier">matches</span> <span class="ruby-operator">|=</span> <span class="ruby-identifier">filter</span>( <span class="ruby-identifier">element</span>.<span class="ruby-identifier">to_a</span>, <span class="ruby-node">&quot;descendant-or-self::#{rest}&quot;</span> ) <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">element</span>.<span class="ruby-identifier">kind_of?</span> <span class="ruby-constant">Element</span>
                                <span class="ruby-keyword kw">end</span>
                        <span class="ruby-keyword kw">when</span> <span class="ruby-regexp re">/^ancestor/</span><span class="ruby-identifier">u</span>
                                <span class="ruby-identifier">elements</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword kw">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">element</span><span class="ruby-operator">|</span>
                                        <span class="ruby-keyword kw">while</span> <span class="ruby-identifier">element</span>.<span class="ruby-identifier">parent</span>
                                                <span class="ruby-identifier">matches</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">element</span>.<span class="ruby-identifier">parent</span>
                                                <span class="ruby-identifier">element</span> = <span class="ruby-identifier">element</span>.<span class="ruby-identifier">parent</span>
                                        <span class="ruby-keyword kw">end</span>
                                <span class="ruby-keyword kw">end</span>
                                <span class="ruby-identifier">matches</span> = <span class="ruby-identifier">filter</span>( <span class="ruby-identifier">matches</span>, <span class="ruby-identifier">rest</span> )
                        <span class="ruby-keyword kw">when</span> <span class="ruby-value str">&quot;self&quot;</span>
                                <span class="ruby-identifier">matches</span> = <span class="ruby-identifier">filter</span>( <span class="ruby-identifier">elements</span>, <span class="ruby-identifier">rest</span> )
                        <span class="ruby-keyword kw">when</span> <span class="ruby-value str">&quot;child&quot;</span>
                                <span class="ruby-identifier">elements</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword kw">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">element</span><span class="ruby-operator">|</span>
                                        <span class="ruby-identifier">matches</span> <span class="ruby-operator">|=</span> <span class="ruby-identifier">filter</span>( <span class="ruby-identifier">element</span>.<span class="ruby-identifier">to_a</span>, <span class="ruby-identifier">rest</span> ) <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">element</span>.<span class="ruby-identifier">kind_of?</span> <span class="ruby-constant">Element</span>
                                <span class="ruby-keyword kw">end</span>
                        <span class="ruby-keyword kw">when</span> <span class="ruby-value str">&quot;attribute&quot;</span>
                                <span class="ruby-identifier">elements</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword kw">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">element</span><span class="ruby-operator">|</span>
                                        <span class="ruby-identifier">matches</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">element</span>.<span class="ruby-identifier">attributes</span>[ <span class="ruby-identifier">rest</span> ] <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">element</span>.<span class="ruby-identifier">kind_of?</span> <span class="ruby-constant">Element</span>
                                <span class="ruby-keyword kw">end</span>
                        <span class="ruby-keyword kw">when</span> <span class="ruby-value str">&quot;parent&quot;</span>
                                <span class="ruby-identifier">matches</span> = <span class="ruby-identifier">filter</span>(<span class="ruby-identifier">elements</span>.<span class="ruby-identifier">collect</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">element</span><span class="ruby-operator">|</span> <span class="ruby-identifier">element</span>.<span class="ruby-identifier">parent</span>}.<span class="ruby-identifier">uniq</span>, <span class="ruby-identifier">rest</span>)
                        <span class="ruby-keyword kw">when</span> <span class="ruby-value str">&quot;following-sibling&quot;</span>
                                <span class="ruby-identifier">matches</span> = <span class="ruby-identifier">filter</span>(<span class="ruby-identifier">elements</span>.<span class="ruby-identifier">collect</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">element</span><span class="ruby-operator">|</span> <span class="ruby-identifier">element</span>.<span class="ruby-identifier">next_sibling</span>}.<span class="ruby-identifier">uniq</span>,
                                        <span class="ruby-identifier">rest</span>)
                        <span class="ruby-keyword kw">when</span> <span class="ruby-value str">&quot;previous-sibling&quot;</span>
                                <span class="ruby-identifier">matches</span> = <span class="ruby-identifier">filter</span>(<span class="ruby-identifier">elements</span>.<span class="ruby-identifier">collect</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">element</span><span class="ruby-operator">|</span> 
                                        <span class="ruby-identifier">element</span>.<span class="ruby-identifier">previous_sibling</span>}.<span class="ruby-identifier">uniq</span>, <span class="ruby-identifier">rest</span> )
                        <span class="ruby-keyword kw">end</span>
                        <span class="ruby-keyword kw">return</span> <span class="ruby-identifier">matches</span>.<span class="ruby-identifier">uniq</span>
                <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>

      <div id="method-M002779" class="m-detail">
        <a name="M002779"></a>

        <div class="method-heading">
          <a href="#M002779" class="method-signature">
          <span class="method-name">each</span><span class="method-args">(element, path, namespaces=EMPTY_HASH, &amp;block)</span>
          </a>
        </div>
      
        <div class="m-description">
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M002779-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M002779-source">
<pre>
<span class="ruby-comment cmt"># File rexml/quickpath.rb, line 15</span>
                <span class="ruby-keyword kw">def</span> <span class="ruby-constant">QuickPath</span><span class="ruby-operator">::</span><span class="ruby-identifier">each</span> <span class="ruby-identifier">element</span>, <span class="ruby-identifier">path</span>, <span class="ruby-identifier">namespaces</span>=<span class="ruby-constant">EMPTY_HASH</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>
                        <span class="ruby-identifier">path</span> = <span class="ruby-value str">&quot;*&quot;</span> <span class="ruby-keyword kw">unless</span> <span class="ruby-identifier">path</span>
                        <span class="ruby-identifier">match</span>(<span class="ruby-identifier">element</span>, <span class="ruby-identifier">path</span>, <span class="ruby-identifier">namespaces</span>).<span class="ruby-identifier">each</span>( <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span> )
                <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>

      <div id="method-M002781" class="m-detail">
        <a name="M002781"></a>

        <div class="method-heading">
          <a href="#M002781" class="method-signature">
          <span class="method-name">filter</span><span class="method-args">(elements, path)</span>
          </a>
        </div>
      
        <div class="m-description">
          <p>
Given an array of nodes it filters the array based on the path. The result
is that when this method returns, the array will contain elements which <a
href="QuickPath.html#M002780">match</a> the path
</p>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M002781-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M002781-source">
<pre>
<span class="ruby-comment cmt"># File rexml/quickpath.rb, line 48</span>
                <span class="ruby-keyword kw">def</span> <span class="ruby-constant">QuickPath</span><span class="ruby-operator">::</span><span class="ruby-identifier">filter</span> <span class="ruby-identifier">elements</span>, <span class="ruby-identifier">path</span>
                        <span class="ruby-keyword kw">return</span> <span class="ruby-identifier">elements</span> <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">path</span>.<span class="ruby-identifier">nil?</span> <span class="ruby-keyword kw">or</span> <span class="ruby-identifier">path</span> <span class="ruby-operator">==</span> <span class="ruby-value str">''</span> <span class="ruby-keyword kw">or</span> <span class="ruby-identifier">elements</span>.<span class="ruby-identifier">size</span> <span class="ruby-operator">==</span> <span class="ruby-value">0</span>
                        <span class="ruby-keyword kw">case</span> <span class="ruby-identifier">path</span>
                        <span class="ruby-keyword kw">when</span> <span class="ruby-regexp re">/^\/\//</span><span class="ruby-identifier">u</span>                                                                                        <span class="ruby-comment cmt"># Descendant</span>
                                <span class="ruby-keyword kw">return</span> <span class="ruby-identifier">axe</span>( <span class="ruby-identifier">elements</span>, <span class="ruby-value str">&quot;descendant-or-self&quot;</span>, <span class="ruby-identifier">$'</span> )
                        <span class="ruby-keyword kw">when</span> <span class="ruby-regexp re">/^\/?\b(\w[-\w]*)\b::/</span><span class="ruby-identifier">u</span>                                                 <span class="ruby-comment cmt"># Axe</span>
                                <span class="ruby-identifier">axe_name</span> = <span class="ruby-identifier">$1</span>
                                <span class="ruby-identifier">rest</span> = <span class="ruby-identifier">$'</span>
                                <span class="ruby-keyword kw">return</span> <span class="ruby-identifier">axe</span>( <span class="ruby-identifier">elements</span>, <span class="ruby-identifier">$1</span>, <span class="ruby-identifier">$'</span> )
                        <span class="ruby-keyword kw">when</span> <span class="ruby-regexp re">/^\/(?=\b([:!\w][-\.\w]*:)?[-!\*\.\w]*\b([^:(]|$)|\*)/</span><span class="ruby-identifier">u</span> <span class="ruby-comment cmt"># Child</span>
                                <span class="ruby-identifier">rest</span> = <span class="ruby-identifier">$'</span>
                                <span class="ruby-identifier">results</span> = []
                                <span class="ruby-identifier">elements</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword kw">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">element</span><span class="ruby-operator">|</span>
                                        <span class="ruby-identifier">results</span> <span class="ruby-operator">|=</span> <span class="ruby-identifier">filter</span>( <span class="ruby-identifier">element</span>.<span class="ruby-identifier">to_a</span>, <span class="ruby-identifier">rest</span> )
                                <span class="ruby-keyword kw">end</span>
                                <span class="ruby-keyword kw">return</span> <span class="ruby-identifier">results</span>
                        <span class="ruby-keyword kw">when</span> <span class="ruby-regexp re">/^\/?(\w[-\w]*)\(/</span><span class="ruby-identifier">u</span>                                                     <span class="ruby-comment cmt"># / Function</span>
                                <span class="ruby-keyword kw">return</span> <span class="ruby-identifier">function</span>( <span class="ruby-identifier">elements</span>, <span class="ruby-identifier">$1</span>, <span class="ruby-identifier">$'</span> )
                        <span class="ruby-keyword kw">when</span> <span class="ruby-constant">Namespace</span><span class="ruby-operator">::</span><span class="ruby-constant">NAMESPLIT</span>            <span class="ruby-comment cmt"># Element name</span>
                                <span class="ruby-identifier">name</span> = <span class="ruby-identifier">$2</span>
                                <span class="ruby-identifier">ns</span> = <span class="ruby-identifier">$1</span>
                                <span class="ruby-identifier">rest</span> = <span class="ruby-identifier">$'</span>
                                <span class="ruby-identifier">elements</span>.<span class="ruby-identifier">delete_if</span> <span class="ruby-keyword kw">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">element</span><span class="ruby-operator">|</span>
                                        <span class="ruby-operator">!</span>(<span class="ruby-identifier">element</span>.<span class="ruby-identifier">kind_of?</span> <span class="ruby-constant">Element</span> <span class="ruby-keyword kw">and</span> 
                                                (<span class="ruby-identifier">element</span>.<span class="ruby-identifier">expanded_name</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">name</span> <span class="ruby-keyword kw">or</span>
                                                 (<span class="ruby-identifier">element</span>.<span class="ruby-identifier">name</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">name</span> <span class="ruby-keyword kw">and</span>
                                                  <span class="ruby-identifier">element</span>.<span class="ruby-identifier">namespace</span> <span class="ruby-operator">==</span> <span class="ruby-constant">Functions</span>.<span class="ruby-identifier">namespace_context</span>[<span class="ruby-identifier">ns</span>])))
                                <span class="ruby-keyword kw">end</span>
                                <span class="ruby-keyword kw">return</span> <span class="ruby-identifier">filter</span>( <span class="ruby-identifier">elements</span>, <span class="ruby-identifier">rest</span> )
                        <span class="ruby-keyword kw">when</span> <span class="ruby-regexp re">/^\/\[/</span><span class="ruby-identifier">u</span>
                                <span class="ruby-identifier">matches</span> = []
                                <span class="ruby-identifier">elements</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword kw">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">element</span><span class="ruby-operator">|</span>
                                        <span class="ruby-identifier">matches</span> <span class="ruby-operator">|=</span> <span class="ruby-identifier">predicate</span>( <span class="ruby-identifier">element</span>.<span class="ruby-identifier">to_a</span>, <span class="ruby-identifier">path</span>[<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">-1</span>] ) <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">element</span>.<span class="ruby-identifier">kind_of?</span> <span class="ruby-constant">Element</span>
                                <span class="ruby-keyword kw">end</span>
                                <span class="ruby-keyword kw">return</span> <span class="ruby-identifier">matches</span>
                        <span class="ruby-keyword kw">when</span> <span class="ruby-regexp re">/^\[/</span><span class="ruby-identifier">u</span>                                                                                          <span class="ruby-comment cmt"># Predicate</span>
                                <span class="ruby-keyword kw">return</span> <span class="ruby-identifier">predicate</span>( <span class="ruby-identifier">elements</span>, <span class="ruby-identifier">path</span> )
                        <span class="ruby-keyword kw">when</span> <span class="ruby-regexp re">/^\/?\.\.\./</span><span class="ruby-identifier">u</span>                                                                           <span class="ruby-comment cmt"># Ancestor</span>
                                <span class="ruby-keyword kw">return</span> <span class="ruby-identifier">axe</span>( <span class="ruby-identifier">elements</span>, <span class="ruby-value str">&quot;ancestor&quot;</span>, <span class="ruby-identifier">$'</span> )
                        <span class="ruby-keyword kw">when</span> <span class="ruby-regexp re">/^\/?\.\./</span><span class="ruby-identifier">u</span>                                                                                     <span class="ruby-comment cmt"># Parent</span>
                                <span class="ruby-keyword kw">return</span> <span class="ruby-identifier">filter</span>( <span class="ruby-identifier">elements</span>.<span class="ruby-identifier">collect</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">e</span><span class="ruby-operator">|</span><span class="ruby-identifier">e</span>.<span class="ruby-identifier">parent</span>}, <span class="ruby-identifier">$'</span> )
                        <span class="ruby-keyword kw">when</span> <span class="ruby-regexp re">/^\/?\./</span><span class="ruby-identifier">u</span>                                                                                               <span class="ruby-comment cmt"># Self</span>
                                <span class="ruby-keyword kw">return</span> <span class="ruby-identifier">filter</span>( <span class="ruby-identifier">elements</span>, <span class="ruby-identifier">$'</span> )
                        <span class="ruby-keyword kw">when</span> <span class="ruby-regexp re">/^\*/</span><span class="ruby-identifier">u</span>                                                                                                  <span class="ruby-comment cmt"># Any</span>
                                <span class="ruby-identifier">results</span> = []
                                <span class="ruby-identifier">elements</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword kw">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">element</span><span class="ruby-operator">|</span>
                                        <span class="ruby-identifier">results</span> <span class="ruby-operator">|=</span> <span class="ruby-identifier">filter</span>( [<span class="ruby-identifier">element</span>], <span class="ruby-identifier">$'</span> ) <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">element</span>.<span class="ruby-identifier">kind_of?</span> <span class="ruby-constant">Element</span>
                                        <span class="ruby-comment cmt">#if element.kind_of? Element</span>
                                        <span class="ruby-comment cmt">#  children = element.to_a</span>
                                        <span class="ruby-comment cmt">#  children.delete_if { |child| !child.kind_of?(Element) }</span>
                                        <span class="ruby-comment cmt">#  results |= filter( children, $' )</span>
                                        <span class="ruby-comment cmt">#end</span>
                                <span class="ruby-keyword kw">end</span>
                                <span class="ruby-keyword kw">return</span> <span class="ruby-identifier">results</span>
                        <span class="ruby-keyword kw">end</span>
                        <span class="ruby-keyword kw">return</span> []
                <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>

      <div id="method-M002778" class="m-detail">
        <a name="M002778"></a>

        <div class="method-heading">
          <a href="#M002778" class="method-signature">
          <span class="method-name">first</span><span class="method-args">(element, path, namespaces=EMPTY_HASH)</span>
          </a>
        </div>
      
        <div class="m-description">
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M002778-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M002778-source">
<pre>
<span class="ruby-comment cmt"># File rexml/quickpath.rb, line 11</span>
                <span class="ruby-keyword kw">def</span> <span class="ruby-constant">QuickPath</span><span class="ruby-operator">::</span><span class="ruby-identifier">first</span> <span class="ruby-identifier">element</span>, <span class="ruby-identifier">path</span>, <span class="ruby-identifier">namespaces</span>=<span class="ruby-constant">EMPTY_HASH</span>
                        <span class="ruby-identifier">match</span>(<span class="ruby-identifier">element</span>, <span class="ruby-identifier">path</span>, <span class="ruby-identifier">namespaces</span>)[<span class="ruby-value">0</span>]
                <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>

      <div id="method-M002787" class="m-detail">
        <a name="M002787"></a>

        <div class="method-heading">
          <a href="#M002787" class="method-signature">
          <span class="method-name">function</span><span class="method-args">( elements, fname, rest )</span>
          </a>
        </div>
      
        <div class="m-description">
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M002787-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M002787-source">
<pre>
<span class="ruby-comment cmt"># File rexml/quickpath.rb, line 222</span>
                <span class="ruby-keyword kw">def</span> <span class="ruby-constant">QuickPath</span><span class="ruby-operator">::</span><span class="ruby-identifier">function</span>( <span class="ruby-identifier">elements</span>, <span class="ruby-identifier">fname</span>, <span class="ruby-identifier">rest</span> )
                        <span class="ruby-identifier">args</span> = <span class="ruby-identifier">parse_args</span>( <span class="ruby-identifier">elements</span>, <span class="ruby-identifier">rest</span> )
                        <span class="ruby-constant">Functions</span>.<span class="ruby-identifier">pair</span> = [<span class="ruby-value">0</span>, <span class="ruby-identifier">elements</span>.<span class="ruby-identifier">size</span>]
                        <span class="ruby-identifier">results</span> = []
                        <span class="ruby-identifier">elements</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword kw">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">element</span><span class="ruby-operator">|</span>
                                <span class="ruby-constant">Functions</span>.<span class="ruby-identifier">pair</span>[<span class="ruby-value">0</span>] <span class="ruby-operator">+=</span> <span class="ruby-value">1</span>
                                <span class="ruby-constant">Functions</span>.<span class="ruby-identifier">node</span> = <span class="ruby-identifier">element</span>
                                <span class="ruby-identifier">res</span> = <span class="ruby-constant">Functions</span>.<span class="ruby-identifier">send</span>( <span class="ruby-identifier">fname</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">args</span> )
                                <span class="ruby-keyword kw">case</span> <span class="ruby-identifier">res</span>
                                <span class="ruby-keyword kw">when</span> <span class="ruby-keyword kw">true</span>
                                        <span class="ruby-identifier">results</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">element</span>
                                <span class="ruby-keyword kw">when</span> <span class="ruby-constant">Fixnum</span>
                                        <span class="ruby-identifier">results</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">element</span> <span class="ruby-keyword kw">if</span> <span class="ruby-constant">Functions</span>.<span class="ruby-identifier">pair</span>[<span class="ruby-value">0</span>] <span class="ruby-operator">==</span> <span class="ruby-identifier">res</span>
                                <span class="ruby-keyword kw">end</span>
                        <span class="ruby-keyword kw">end</span>
                        <span class="ruby-keyword kw">return</span> <span class="ruby-identifier">results</span>
                <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>

      <div id="method-M002780" class="m-detail">
        <a name="M002780"></a>

        <div class="method-heading">
          <a href="#M002780" class="method-signature">
          <span class="method-name">match</span><span class="method-args">(element, path, namespaces=EMPTY_HASH)</span>
          </a>
        </div>
      
        <div class="m-description">
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M002780-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M002780-source">
<pre>
<span class="ruby-comment cmt"># File rexml/quickpath.rb, line 20</span>
                <span class="ruby-keyword kw">def</span> <span class="ruby-constant">QuickPath</span><span class="ruby-operator">::</span><span class="ruby-identifier">match</span> <span class="ruby-identifier">element</span>, <span class="ruby-identifier">path</span>, <span class="ruby-identifier">namespaces</span>=<span class="ruby-constant">EMPTY_HASH</span>
                        <span class="ruby-identifier">raise</span> <span class="ruby-value str">&quot;nil is not a valid xpath&quot;</span> <span class="ruby-keyword kw">unless</span> <span class="ruby-identifier">path</span>
                        <span class="ruby-identifier">results</span> = <span class="ruby-keyword kw">nil</span>
                        <span class="ruby-constant">Functions</span><span class="ruby-operator">::</span><span class="ruby-identifier">namespace_context</span> = <span class="ruby-identifier">namespaces</span>
                        <span class="ruby-keyword kw">case</span> <span class="ruby-identifier">path</span>
                        <span class="ruby-keyword kw">when</span> <span class="ruby-regexp re">/^\/([^\/]|$)/</span><span class="ruby-identifier">u</span>
                                <span class="ruby-comment cmt"># match on root</span>
                                <span class="ruby-identifier">path</span> = <span class="ruby-identifier">path</span>[<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">-1</span>]
                                <span class="ruby-keyword kw">return</span> [<span class="ruby-identifier">element</span>.<span class="ruby-identifier">root</span>.<span class="ruby-identifier">parent</span>] <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">path</span> <span class="ruby-operator">==</span> <span class="ruby-value str">''</span>
                                <span class="ruby-identifier">results</span> = <span class="ruby-identifier">filter</span>([<span class="ruby-identifier">element</span>.<span class="ruby-identifier">root</span>], <span class="ruby-identifier">path</span>)
                        <span class="ruby-keyword kw">when</span> <span class="ruby-regexp re">/^[-\w]*::/</span><span class="ruby-identifier">u</span>
                                <span class="ruby-identifier">results</span> = <span class="ruby-identifier">filter</span>([<span class="ruby-identifier">element</span>], <span class="ruby-identifier">path</span>)
                        <span class="ruby-keyword kw">when</span> <span class="ruby-regexp re">/^\*/</span><span class="ruby-identifier">u</span>
                                <span class="ruby-identifier">results</span> = <span class="ruby-identifier">filter</span>(<span class="ruby-identifier">element</span>.<span class="ruby-identifier">to_a</span>, <span class="ruby-identifier">path</span>)
                        <span class="ruby-keyword kw">when</span> <span class="ruby-regexp re">/^[\[!\w:]/</span><span class="ruby-identifier">u</span>
                                <span class="ruby-comment cmt"># match on child</span>
                                <span class="ruby-identifier">matches</span> = []
                                <span class="ruby-identifier">children</span> = <span class="ruby-identifier">element</span>.<span class="ruby-identifier">to_a</span>
                                <span class="ruby-identifier">results</span> = <span class="ruby-identifier">filter</span>(<span class="ruby-identifier">children</span>, <span class="ruby-identifier">path</span>)
                        <span class="ruby-keyword kw">else</span>
                                <span class="ruby-identifier">results</span> = <span class="ruby-identifier">filter</span>([<span class="ruby-identifier">element</span>], <span class="ruby-identifier">path</span>)
                        <span class="ruby-keyword kw">end</span>
                        <span class="ruby-keyword kw">return</span> <span class="ruby-identifier">results</span>
                <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>

      <div id="method-M002786" class="m-detail">
        <a name="M002786"></a>

        <div class="method-heading">
          <a href="#M002786" class="method-signature">
          <span class="method-name">method_missing</span><span class="method-args">( id, *args )</span>
          </a>
        </div>
      
        <div class="m-description">
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M002786-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M002786-source">
<pre>
<span class="ruby-comment cmt"># File rexml/quickpath.rb, line 214</span>
                <span class="ruby-keyword kw">def</span> <span class="ruby-constant">QuickPath</span><span class="ruby-operator">::</span><span class="ruby-identifier">method_missing</span>( <span class="ruby-identifier">id</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">args</span> )
                        <span class="ruby-keyword kw">begin</span>
                                <span class="ruby-constant">Functions</span>.<span class="ruby-identifier">send</span>( <span class="ruby-identifier">id</span>.<span class="ruby-identifier">id2name</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">args</span> )
                        <span class="ruby-keyword kw">rescue</span> <span class="ruby-constant">Exception</span>
                                <span class="ruby-identifier">raise</span> <span class="ruby-node">&quot;METHOD: #{id.id2name}(#{args.join ', '})\n#{$!.message}&quot;</span>
                        <span class="ruby-keyword kw">end</span>
                <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>

      <div id="method-M002785" class="m-detail">
        <a name="M002785"></a>

        <div class="method-heading">
          <a href="#M002785" class="method-signature">
          <span class="method-name">name</span><span class="method-args">()</span>
          </a>
        </div>
      
        <div class="m-description">
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M002785-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M002785-source">
<pre>
<span class="ruby-comment cmt"># File rexml/quickpath.rb, line 210</span>
                <span class="ruby-keyword kw">def</span> <span class="ruby-constant">QuickPath</span><span class="ruby-operator">::</span><span class="ruby-identifier">name</span>()
                        <span class="ruby-keyword kw">return</span> <span class="ruby-constant">Functions</span>.<span class="ruby-identifier">node</span>.<span class="ruby-identifier">name</span> <span class="ruby-keyword kw">if</span> <span class="ruby-constant">Functions</span>.<span class="ruby-identifier">node</span>.<span class="ruby-identifier">kind_of?</span> <span class="ruby-constant">Element</span>
                <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>

      <div id="method-M002788" class="m-detail">
        <a name="M002788"></a>

        <div class="method-heading">
          <a href="#M002788" class="method-signature">
          <span class="method-name">parse_args</span><span class="method-args">( element, string )</span>
          </a>
        </div>
      
        <div class="m-description">
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M002788-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M002788-source">
<pre>
<span class="ruby-comment cmt"># File rexml/quickpath.rb, line 240</span>
                <span class="ruby-keyword kw">def</span> <span class="ruby-constant">QuickPath</span><span class="ruby-operator">::</span><span class="ruby-identifier">parse_args</span>( <span class="ruby-identifier">element</span>, <span class="ruby-identifier">string</span> )
                        <span class="ruby-comment cmt"># /.*?(?:\)|,)/</span>
                        <span class="ruby-identifier">arguments</span> = []
                        <span class="ruby-identifier">buffer</span> = <span class="ruby-value str">&quot;&quot;</span>
                        <span class="ruby-keyword kw">while</span> <span class="ruby-identifier">string</span> <span class="ruby-keyword kw">and</span> <span class="ruby-identifier">string</span> <span class="ruby-operator">!=</span> <span class="ruby-value str">&quot;&quot;</span>
                                <span class="ruby-identifier">c</span> = <span class="ruby-identifier">string</span>[<span class="ruby-value">0</span>]
                                <span class="ruby-identifier">string</span>.<span class="ruby-identifier">sub!</span>(<span class="ruby-regexp re">/^./</span><span class="ruby-identifier">u</span>, <span class="ruby-value str">&quot;&quot;</span>)
                                <span class="ruby-keyword kw">case</span> <span class="ruby-identifier">c</span>
                                <span class="ruby-keyword kw">when</span> <span class="ruby-value">?,</span>
                                        <span class="ruby-comment cmt"># if depth = 1, then we start a new argument</span>
                                        <span class="ruby-identifier">arguments</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">evaluate</span>( <span class="ruby-identifier">buffer</span> )
                                        <span class="ruby-comment cmt">#arguments &lt;&lt; evaluate( string[0..count] )</span>
                                <span class="ruby-keyword kw">when</span> <span class="ruby-value">?(</span>
                                        <span class="ruby-comment cmt"># start a new method call</span>
                                        <span class="ruby-identifier">function</span>( <span class="ruby-identifier">element</span>, <span class="ruby-identifier">buffer</span>, <span class="ruby-identifier">string</span> )
                                        <span class="ruby-identifier">buffer</span> = <span class="ruby-value str">&quot;&quot;</span>
                                <span class="ruby-keyword kw">when</span> <span class="ruby-value">?)</span>
                                        <span class="ruby-comment cmt"># close the method call and return arguments</span>
                                        <span class="ruby-keyword kw">return</span> <span class="ruby-identifier">arguments</span>
                                <span class="ruby-keyword kw">else</span>
                                        <span class="ruby-identifier">buffer</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">c</span>
                                <span class="ruby-keyword kw">end</span>
                        <span class="ruby-keyword kw">end</span>
                        <span class="ruby-value str">&quot;&quot;</span>
                <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>

      <div id="method-M002783" class="m-detail">
        <a name="M002783"></a>

        <div class="method-heading">
          <a href="#M002783" class="method-signature">
          <span class="method-name">predicate</span><span class="method-args">( elements, path )</span>
          </a>
        </div>
      
        <div class="m-description">
          <p>
A <a href="QuickPath.html#M002783">predicate</a> filters a node-set with
respect to an axis to produce a new node-set. For <a
href="QuickPath.html#M002779">each</a> node in the node-set to be filtered,
the PredicateExpr is evaluated with that node as the context node, with the
number of nodes in the node-set as the context size, and with the proximity
position of the node in the node-set with respect to the axis as the
context position; if PredicateExpr evaluates to true for that node, the
node is included in the new node-set; otherwise, it is not included.
</p>
<p>
A PredicateExpr is evaluated by evaluating the Expr and converting the
result to a boolean. If the result is a number, the result will be
converted to true if the number is equal to the context position and will
be converted to false otherwise; if the result is not a number, then the
result will be converted as if by a call to the boolean <a
href="QuickPath.html#M002787">function</a>. Thus a location path para[3] is
equivalent to para[position()=3].
</p>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M002783-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M002783-source">
<pre>
<span class="ruby-comment cmt"># File rexml/quickpath.rb, line 160</span>
                <span class="ruby-keyword kw">def</span> <span class="ruby-constant">QuickPath</span><span class="ruby-operator">::</span><span class="ruby-identifier">predicate</span>( <span class="ruby-identifier">elements</span>, <span class="ruby-identifier">path</span> ) 
                        <span class="ruby-identifier">ind</span> = <span class="ruby-value">1</span>
                        <span class="ruby-identifier">bcount</span> = <span class="ruby-value">1</span>
                        <span class="ruby-keyword kw">while</span> <span class="ruby-identifier">bcount</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">0</span>
                                <span class="ruby-identifier">bcount</span> <span class="ruby-operator">+=</span> <span class="ruby-value">1</span> <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">path</span>[<span class="ruby-identifier">ind</span>] <span class="ruby-operator">==</span> <span class="ruby-value">?[</span>
                                <span class="ruby-identifier">bcount</span> <span class="ruby-operator">-=</span> <span class="ruby-value">1</span> <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">path</span>[<span class="ruby-identifier">ind</span>] <span class="ruby-operator">==</span> <span class="ruby-value">?]</span>
                                <span class="ruby-identifier">ind</span> <span class="ruby-operator">+=</span> <span class="ruby-value">1</span>
                        <span class="ruby-keyword kw">end</span>
                        <span class="ruby-identifier">ind</span> <span class="ruby-operator">-=</span> <span class="ruby-value">1</span>
                        <span class="ruby-identifier">predicate</span> = <span class="ruby-identifier">path</span>[<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-identifier">ind</span><span class="ruby-operator">-</span><span class="ruby-value">1</span>]
                        <span class="ruby-identifier">rest</span> = <span class="ruby-identifier">path</span>[<span class="ruby-identifier">ind</span><span class="ruby-operator">+</span><span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">-1</span>]

                        <span class="ruby-comment cmt"># have to change 'a [=&lt;&gt;] b [=&lt;&gt;] c' into 'a [=&lt;&gt;] b and b [=&lt;&gt;] c'</span>
                        <span class="ruby-identifier">predicate</span>.<span class="ruby-identifier">gsub!</span>( <span class="ruby-regexp re">/([^\s(and)(or)&lt;&gt;=]+)\s*([&lt;&gt;=])\s*([^\s(and)(or)&lt;&gt;=]+)\s*([&lt;&gt;=])\s*([^\s(and)(or)&lt;&gt;=]+)/</span><span class="ruby-identifier">u</span> ) { 
                                <span class="ruby-value str">&quot;#$1 #$2 #$3 and #$3 #$4 #$5&quot;</span>
                        }
                        <span class="ruby-comment cmt"># Let's do some Ruby trickery to avoid some work:</span>
                        <span class="ruby-identifier">predicate</span>.<span class="ruby-identifier">gsub!</span>( <span class="ruby-regexp re">/&amp;/</span><span class="ruby-identifier">u</span>, <span class="ruby-value str">&quot;&amp;&amp;&quot;</span> )
                        <span class="ruby-identifier">predicate</span>.<span class="ruby-identifier">gsub!</span>( <span class="ruby-regexp re">/=/</span><span class="ruby-identifier">u</span>, <span class="ruby-value str">&quot;==&quot;</span> )
                        <span class="ruby-identifier">predicate</span>.<span class="ruby-identifier">gsub!</span>( <span class="ruby-regexp re">/@(\w[-\w.]*)/</span><span class="ruby-identifier">u</span> ) {
                                <span class="ruby-value str">&quot;attribute(\&quot;#$1\&quot;)&quot;</span> 
                        }
                        <span class="ruby-identifier">predicate</span>.<span class="ruby-identifier">gsub!</span>( <span class="ruby-regexp re">/\bmod\b/</span><span class="ruby-identifier">u</span>, <span class="ruby-value str">&quot;%&quot;</span> )
                        <span class="ruby-identifier">predicate</span>.<span class="ruby-identifier">gsub!</span>( <span class="ruby-regexp re">/\b(\w[-\w.]*\()/</span><span class="ruby-identifier">u</span> ) {
                                <span class="ruby-identifier">fname</span> = <span class="ruby-identifier">$1</span>
                                <span class="ruby-identifier">fname</span>.<span class="ruby-identifier">gsub</span>( <span class="ruby-regexp re">/-/</span><span class="ruby-identifier">u</span>, <span class="ruby-value str">&quot;_&quot;</span> )
                        }
                        
                        <span class="ruby-constant">Functions</span>.<span class="ruby-identifier">pair</span> = [ <span class="ruby-value">0</span>, <span class="ruby-identifier">elements</span>.<span class="ruby-identifier">size</span> ]
                        <span class="ruby-identifier">results</span> = []
                        <span class="ruby-identifier">elements</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword kw">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">element</span><span class="ruby-operator">|</span>
                                <span class="ruby-constant">Functions</span>.<span class="ruby-identifier">pair</span>[<span class="ruby-value">0</span>] <span class="ruby-operator">+=</span> <span class="ruby-value">1</span>
                                <span class="ruby-constant">Functions</span>.<span class="ruby-identifier">node</span> = <span class="ruby-identifier">element</span>
                                <span class="ruby-identifier">res</span> = <span class="ruby-identifier">eval</span>( <span class="ruby-identifier">predicate</span> )
                                <span class="ruby-keyword kw">case</span> <span class="ruby-identifier">res</span>
                                <span class="ruby-keyword kw">when</span> <span class="ruby-keyword kw">true</span>
                                        <span class="ruby-identifier">results</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">element</span>
                                <span class="ruby-keyword kw">when</span> <span class="ruby-constant">Fixnum</span>
                                        <span class="ruby-identifier">results</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">element</span> <span class="ruby-keyword kw">if</span> <span class="ruby-constant">Functions</span>.<span class="ruby-identifier">pair</span>[<span class="ruby-value">0</span>] <span class="ruby-operator">==</span> <span class="ruby-identifier">res</span>
                                <span class="ruby-keyword kw">when</span> <span class="ruby-constant">String</span>
                                        <span class="ruby-identifier">results</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">element</span>
                                <span class="ruby-keyword kw">end</span>
                        <span class="ruby-keyword kw">end</span>
                        <span class="ruby-keyword kw">return</span> <span class="ruby-identifier">filter</span>( <span class="ruby-identifier">results</span>, <span class="ruby-identifier">rest</span> )
                <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>


    </div>


  </div>


<div id="validator-badges">
  <p><small><a href="http://validator.w3.org/check/referer">[Validate]</a></small></p>
</div>
<div id='credits' style='font-size:smaller' >
 <!-- 0 --> <p> <a href='http://www.ruby-doc.org'>ruby-doc.org</a> is hosted and run  by <a href='http://www.jamesbritt.com'>James Britt</a> and <a href='http://www.happycamperstudios.com'>Happy Camper Studios</a>, a <a href='http://www.happycamperstudios.com'> Ruby application development company in Phoenix, Arizona</a>. Ruby-doc.org was created in 2002 to promote the Ruby language and to help other Ruby hackers.</p>
 <p>Documentation content on ruby-doc.org is provided by <a href='http://www.ruby-doc.org/about'>remarkable members</a> of the Ruby community.</p>
<p>For more information on the Ruby programming language, visit <a href='http://www.ruby-lang.org'>ruby-lang.org</a>.</p>
<p>Want to help improve Ruby's API docs? See <a href='/documentation-guidelines.html'> Ruby Documentation Guidelines</a>.</p>
</div>

</body>
</html>