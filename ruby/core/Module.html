<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html 
     PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
     "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>Class: Module</title>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
  <meta http-equiv="Content-Script-Type" content="text/javascript" />
  <link rel="stylesheet" href=".././rdoc-style.css" type="text/css" media="screen" />
  <script type="text/javascript">
  // <![CDATA[

  function popupCode( url ) {
    window.open(url, "Code", "resizable=yes,scrollbars=yes,toolbar=no,status=no,height=150,width=400")
  }

  function toggleCode( id ) {
    if ( document.getElementById )
      elem = document.getElementById( id );
    else if ( document.all )
      elem = eval( "document.all." + id );
    else
      return false;

    elemStyle = elem.style;
    
    if ( elemStyle.display != "block" ) {
      elemStyle.display = "block"
    } else {
      elemStyle.display = "none"
    }

    return true;
  }
  
  // Make codeblocks hidden by default
  document.writeln( "<style type=\"text/css\">div.method-source-code { display: none }</style>" )
  
  // ]]>
  </script>

</head>
<body>



    <div id="classHeader">
        <table class="header-table">
        <tr class="top-aligned-row">
          <td><strong>Class</strong></td>
          <td class="class-name-in-header">Module</td>
        </tr>
        <tr class="top-aligned-row">
            <td><strong>In:</strong></td>
            <td>
                <a href="../files/object_c.html">
                object.c
                </a>
        <br />
            </td>
        </tr>

        </table>
    </div>
  <!-- banner header -->

  <div id="bodyContent">



  <div id="contextContent">

    <div id="description">
      <p>
A <tt><a href="Module.html">Module</a></tt> is a collection of methods and
<a href="Module.html#M001656">constants</a>. The methods in a module may be
instance methods or module methods. Instance methods appear as methods in a
class when the module is <a href="Module.html#M001660">included</a>, module
methods do not. Conversely, module methods may be called without creating
an encapsulating object, while instance methods may not. (See <tt><a
href="Module.html#M001642">Module#module_function</a></tt>)
</p>
<p>
In the descriptions that follow, the parameter <em>syml</em> refers to a
symbol, which is either a quoted string or a <tt><a
href="Symbol.html">Symbol</a></tt> (such as <tt>:<a
href="Module.html#M001676">name</a></tt>).
</p>
<pre>
   module Mod
     include Math
     CONST = 1
     def meth
       #  ...
     end
   end
   Mod.class              #=&gt; Module
   Mod.constants          #=&gt; [&quot;E&quot;, &quot;PI&quot;, &quot;CONST&quot;]
   Mod.instance_methods   #=&gt; [&quot;meth&quot;]
</pre>

    </div>


   </div>

    <div id="method-list">
      <h3 class="section-bar">Methods</h3>

      <div class="name-list">
      <a href="#M001669">&lt;</a>&nbsp;&nbsp;
      <a href="#M001670">&lt;=</a>&nbsp;&nbsp;
      <a href="#M001668">&lt;=&gt;</a>&nbsp;&nbsp;
      <a href="#M001667">==</a>&nbsp;&nbsp;
      <a href="#M001666">===</a>&nbsp;&nbsp;
      <a href="#M001671">&gt;</a>&nbsp;&nbsp;
      <a href="#M001672">&gt;=</a>&nbsp;&nbsp;
      <a href="#M001653">alias_method</a>&nbsp;&nbsp;
      <a href="#M001677">ancestors</a>&nbsp;&nbsp;
      <a href="#M001636">append_features</a>&nbsp;&nbsp;
      <a href="#M001678">attr</a>&nbsp;&nbsp;
      <a href="#M001681">attr_accessor</a>&nbsp;&nbsp;
      <a href="#M001679">attr_reader</a>&nbsp;&nbsp;
      <a href="#M001680">attr_writer</a>&nbsp;&nbsp;
      <a href="#M001657">autoload</a>&nbsp;&nbsp;
      <a href="#M001658">autoload?</a>&nbsp;&nbsp;
      <a href="#M001650">class_eval</a>&nbsp;&nbsp;
      <a href="#M001687">class_variable_defined?</a>&nbsp;&nbsp;
      <a href="#M001696">class_variable_get</a>&nbsp;&nbsp;
      <a href="#M001697">class_variable_set</a>&nbsp;&nbsp;
      <a href="#M001694">class_variables</a>&nbsp;&nbsp;
      <a href="#M001691">const_defined?</a>&nbsp;&nbsp;
      <a href="#M001689">const_get</a>&nbsp;&nbsp;
      <a href="#M001693">const_missing</a>&nbsp;&nbsp;
      <a href="#M001690">const_set</a>&nbsp;&nbsp;
      <a href="#M001656">constants</a>&nbsp;&nbsp;
      <a href="#M001688">constants</a>&nbsp;&nbsp;
      <a href="#M001654">define_method</a>&nbsp;&nbsp;
      <a href="#M001637">extend_object</a>&nbsp;&nbsp;
      <a href="#M001661">extended</a>&nbsp;&nbsp;
      <a href="#M001665">freeze</a>&nbsp;&nbsp;
      <a href="#M001638">include</a>&nbsp;&nbsp;
      <a href="#M001675">include?</a>&nbsp;&nbsp;
      <a href="#M001660">included</a>&nbsp;&nbsp;
      <a href="#M001674">included_modules</a>&nbsp;&nbsp;
      <a href="#M001659">instance_method</a>&nbsp;&nbsp;
      <a href="#M001683">instance_methods</a>&nbsp;&nbsp;
      <a href="#M001662">method_added</a>&nbsp;&nbsp;
      <a href="#M001643">method_defined?</a>&nbsp;&nbsp;
      <a href="#M001663">method_removed</a>&nbsp;&nbsp;
      <a href="#M001664">method_undefined</a>&nbsp;&nbsp;
      <a href="#M001649">module_eval</a>&nbsp;&nbsp;
      <a href="#M001642">module_function</a>&nbsp;&nbsp;
      <a href="#M001676">name</a>&nbsp;&nbsp;
      <a href="#M001655">nesting</a>&nbsp;&nbsp;
      <a href="#M001682">new</a>&nbsp;&nbsp;
      <a href="#M001641">private</a>&nbsp;&nbsp;
      <a href="#M001648">private_class_method</a>&nbsp;&nbsp;
      <a href="#M001686">private_instance_methods</a>&nbsp;&nbsp;
      <a href="#M001645">private_method_defined?</a>&nbsp;&nbsp;
      <a href="#M001640">protected</a>&nbsp;&nbsp;
      <a href="#M001685">protected_instance_methods</a>&nbsp;&nbsp;
      <a href="#M001646">protected_method_defined?</a>&nbsp;&nbsp;
      <a href="#M001639">public</a>&nbsp;&nbsp;
      <a href="#M001647">public_class_method</a>&nbsp;&nbsp;
      <a href="#M001684">public_instance_methods</a>&nbsp;&nbsp;
      <a href="#M001644">public_method_defined?</a>&nbsp;&nbsp;
      <a href="#M001695">remove_class_variable</a>&nbsp;&nbsp;
      <a href="#M001692">remove_const</a>&nbsp;&nbsp;
      <a href="#M001651">remove_method</a>&nbsp;&nbsp;
      <a href="#M001673">to_s</a>&nbsp;&nbsp;
      <a href="#M001652">undef_method</a>&nbsp;&nbsp;
      </div>
    </div>

  </div>


    <!-- if includes -->

    <div id="section">





      


    <!-- if method_list -->
    <div id="methods">
      <h3 class="section-bar">Public Class methods</h3>

      <div id="method-M001656" class="method-detail">
        <a name="M001656"></a>

        <div class="method-heading">
          <a href="Module.src/M001656.html" target="Code" class="method-signature"
            onclick="popupCode('Module.src/M001656.html');return false;">
          <span class="method-name">Module.constants   => array<br />
</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Returns an array of the names of all <a
href="Module.html#M001656">constants</a> defined in the system. This list
includes the names of all modules and classes.
</p>
<pre>
   p Module.constants.sort[1..5]
</pre>
<p>
<em>produces:</em>
</p>
<pre>
   [&quot;ARGV&quot;, &quot;ArgumentError&quot;, &quot;Array&quot;, &quot;Bignum&quot;, &quot;Binding&quot;]
</pre>
        </div>
      </div>

      <div id="method-M001655" class="method-detail">
        <a name="M001655"></a>

        <div class="method-heading">
          <a href="Module.src/M001655.html" target="Code" class="method-signature"
            onclick="popupCode('Module.src/M001655.html');return false;">
          <span class="method-name">Module.nesting    => array<br />
</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Returns the list of <tt>Modules</tt> nested at the point of call.
</p>
<pre>
   module M1
     module M2
       $a = Module.nesting
     end
   end
   $a           #=&gt; [M1::M2, M1]
   $a[0].name   #=&gt; &quot;M1::M2&quot;
</pre>
        </div>
      </div>

      <div id="method-M001682" class="method-detail">
        <a name="M001682"></a>

        <div class="method-heading">
          <a href="Module.src/M001682.html" target="Code" class="method-signature"
            onclick="popupCode('Module.src/M001682.html');return false;">
          <span class="method-name">Module.new                  => mod<br />
Module.new {|mod| block }   => mod<br />
</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Creates a <a href="Module.html#M001682">new</a> anonymous module. If a
block is given, it is passed the module object, and the block is evaluated
in the context of this module using <tt><a
href="Module.html#M001649">module_eval</a></tt>.
</p>
<pre>
   Fred = Module.new do
     def meth1
       &quot;hello&quot;
     end
     def meth2
       &quot;bye&quot;
     end
   end
   a = &quot;my string&quot;
   a.extend(Fred)   #=&gt; &quot;my string&quot;
   a.meth1          #=&gt; &quot;hello&quot;
   a.meth2          #=&gt; &quot;bye&quot;
</pre>
        </div>
      </div>

      <h3 class="section-bar">Public Instance methods</h3>

      <div id="method-M001669" class="method-detail">
        <a name="M001669"></a>

        <div class="method-heading">
          <a href="Module.src/M001669.html" target="Code" class="method-signature"
            onclick="popupCode('Module.src/M001669.html');return false;">
          <span class="method-name">mod < other   =>  true, false, or nil<br />
</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Returns true if <em>mod</em> is a subclass of <em>other</em>. Returns
<tt>nil</tt> if there&#8216;s no relationship between the two. (Think of
the relationship in terms of the class definition: &quot;class A&lt;B&quot;
implies &quot;A&lt;B&quot;).
</p>
        </div>
      </div>

      <div id="method-M001670" class="method-detail">
        <a name="M001670"></a>

        <div class="method-heading">
          <a href="Module.src/M001670.html" target="Code" class="method-signature"
            onclick="popupCode('Module.src/M001670.html');return false;">
          <span class="method-name">mod <= other   =>  true, false, or nil<br />
</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Returns true if <em>mod</em> is a subclass of <em>other</em> or is the same
as <em>other</em>. Returns <tt>nil</tt> if there&#8216;s no relationship
between the two. (Think of the relationship in terms of the class
definition: &quot;class A&lt;B&quot; implies &quot;A&lt;B&quot;).
</p>
        </div>
      </div>

      <div id="method-M001668" class="method-detail">
        <a name="M001668"></a>

        <div class="method-heading">
          <a href="Module.src/M001668.html" target="Code" class="method-signature"
            onclick="popupCode('Module.src/M001668.html');return false;">
          <span class="method-name">mod <=> other_mod   => -1, 0, +1, or nil<br />
</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Comparison&#8212;Returns -1 if <em>mod</em> includes <em>other_mod</em>, 0
if <em>mod</em> is the same as <em>other_mod</em>, and +1 if <em>mod</em>
is <a href="Module.html#M001660">included</a> by <em>other_mod</em> or if
<em>mod</em> has no relationship with <em>other_mod</em>. Returns
<tt>nil</tt> if <em>other_mod</em> is not a module.
</p>
        </div>
      </div>

      <div id="method-M001667" class="method-detail">
        <a name="M001667"></a>

        <div class="method-heading">
          <a href="Module.src/M001667.html" target="Code" class="method-signature"
            onclick="popupCode('Module.src/M001667.html');return false;">
          <span class="method-name">obj == other        => true or false<br />
obj.equal?(other)   => true or false<br />
obj.eql?(other)     => true or false<br />
</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Equality&#8212;At the <tt><a href="Object.html">Object</a></tt> level,
<tt>==</tt> returns <tt>true</tt> only if <em>obj</em> and <em>other</em>
are the same object. Typically, this method is overridden in descendent
classes to provide class-specific meaning.
</p>
<p>
Unlike <tt>==</tt>, the <tt>equal?</tt> method should never be overridden
by subclasses: it is used to determine object identity (that is,
<tt>a.equal?(b)</tt> iff <tt>a</tt> is the same object as <tt>b</tt>).
</p>
<p>
The <tt>eql?</tt> method returns <tt>true</tt> if <em>obj</em> and
<em>anObject</em> have the same value. Used by <tt><a
href="Hash.html">Hash</a></tt> to test members for equality. For objects of
class <tt><a href="Object.html">Object</a></tt>, <tt>eql?</tt> is
synonymous with <tt>==</tt>. Subclasses normally continue this tradition,
but there are exceptions. <tt><a href="Numeric.html">Numeric</a></tt>
types, for example, perform type conversion across <tt>==</tt>, but not
across <tt>eql?</tt>, so:
</p>
<pre>
   1 == 1.0     #=&gt; true
   1.eql? 1.0   #=&gt; false
</pre>
        </div>
      </div>

      <div id="method-M001666" class="method-detail">
        <a name="M001666"></a>

        <div class="method-heading">
          <a href="Module.src/M001666.html" target="Code" class="method-signature"
            onclick="popupCode('Module.src/M001666.html');return false;">
          <span class="method-name">mod === obj    => true or false<br />
</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Case Equality&#8212;Returns <tt>true</tt> if <em>anObject</em> is an
instance of <em>mod</em> or one of <em>mod</em>&#8216;s descendents. Of
limited use for modules, but can be used in <tt>case</tt> statements to
classify objects by class.
</p>
        </div>
      </div>

      <div id="method-M001671" class="method-detail">
        <a name="M001671"></a>

        <div class="method-heading">
          <a href="Module.src/M001671.html" target="Code" class="method-signature"
            onclick="popupCode('Module.src/M001671.html');return false;">
          <span class="method-name">mod > other   =>  true, false, or nil<br />
</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Returns true if <em>mod</em> is an ancestor of <em>other</em>. Returns
<tt>nil</tt> if there&#8216;s no relationship between the two. (Think of
the relationship in terms of the class definition: &quot;class A&lt;B&quot;
implies &quot;B&gt;A&quot;).
</p>
        </div>
      </div>

      <div id="method-M001672" class="method-detail">
        <a name="M001672"></a>

        <div class="method-heading">
          <a href="Module.src/M001672.html" target="Code" class="method-signature"
            onclick="popupCode('Module.src/M001672.html');return false;">
          <span class="method-name">mod >= other   =>  true, false, or nil<br />
</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Returns true if <em>mod</em> is an ancestor of <em>other</em>, or the two
modules are the same. Returns <tt>nil</tt> if there&#8216;s no relationship
between the two. (Think of the relationship in terms of the class
definition: &quot;class A&lt;B&quot; implies &quot;B&gt;A&quot;).
</p>
        </div>
      </div>

      <div id="method-M001653" class="method-detail">
        <a name="M001653"></a>

        <div class="method-heading">
          <a href="Module.src/M001653.html" target="Code" class="method-signature"
            onclick="popupCode('Module.src/M001653.html');return false;">
          <span class="method-name">alias_method(new_name, old_name)   => self<br />
</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Makes <em>new_name</em> a <a href="Module.html#M001682">new</a> copy of the
method <em>old_name</em>. This can be used to retain access to methods that
are overridden.
</p>
<pre>
   module Mod
     alias_method :orig_exit, :exit
     def exit(code=0)
       puts &quot;Exiting with code #{code}&quot;
       orig_exit(code)
     end
   end
   include Mod
   exit(99)
</pre>
<p>
<em>produces:</em>
</p>
<pre>
   Exiting with code 99
</pre>
        </div>
      </div>

      <div id="method-M001677" class="method-detail">
        <a name="M001677"></a>

        <div class="method-heading">
          <a href="Module.src/M001677.html" target="Code" class="method-signature"
            onclick="popupCode('Module.src/M001677.html');return false;">
          <span class="method-name">mod.ancestors &rarr; array<br />
</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Returns a list of modules <a href="Module.html#M001660">included</a> in
<em>mod</em> (including <em>mod</em> itself).
</p>
<pre>
   module Mod
     include Math
     include Comparable
   end

   Mod.ancestors    #=&gt; [Mod, Comparable, Math]
   Math.ancestors   #=&gt; [Math]
</pre>
        </div>
      </div>

      <div id="method-M001636" class="method-detail">
        <a name="M001636"></a>

        <div class="method-heading">
          <a href="Module.src/M001636.html" target="Code" class="method-signature"
            onclick="popupCode('Module.src/M001636.html');return false;">
          <span class="method-name">append_features(mod)   => mod<br />
</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
When this module is <a href="Module.html#M001660">included</a> in another,
Ruby calls <tt><a href="Module.html#M001636">append_features</a></tt> in
this module, passing it the receiving module in <em>mod</em>. Ruby&#8216;s
default implementation is to add the <a
href="Module.html#M001656">constants</a>, methods, and module variables of
this module to <em>mod</em> if this module has not already been added to
<em>mod</em> or one of its <a href="Module.html#M001677">ancestors</a>. See
also <tt><a href="Module.html#M001638">Module#include</a></tt>.
</p>
        </div>
      </div>

      <div id="method-M001678" class="method-detail">
        <a name="M001678"></a>

        <div class="method-heading">
          <a href="Module.src/M001678.html" target="Code" class="method-signature"
            onclick="popupCode('Module.src/M001678.html');return false;">
          <span class="method-name">attr(symbol, writable=false)    => nil<br />
</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Defines a named attribute for this module, where the <a
href="Module.html#M001676">name</a> is <em>symbol.</em><tt>id2name</tt>,
creating an instance variable (<tt>@<a
href="Module.html#M001676">name</a></tt>) and a corresponding access method
to read it. If the optional <em>writable</em> argument is <tt>true</tt>,
also creates a method called <tt>name=</tt> to set the attribute.
</p>
<pre>
   module Mod
     attr  :size, true
   end
</pre>
<p>
<em>is equivalent to:</em>
</p>
<pre>
   module Mod
     def size
       @size
     end
     def size=(val)
       @size = val
     end
   end
</pre>
        </div>
      </div>

      <div id="method-M001681" class="method-detail">
        <a name="M001681"></a>

        <div class="method-heading">
          <a href="Module.src/M001681.html" target="Code" class="method-signature"
            onclick="popupCode('Module.src/M001681.html');return false;">
          <span class="method-name">attr_accessor(symbol, ...)    => nil<br />
</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Equivalent to calling ``<tt><a
href="Module.html#M001678">attr</a></tt><em>symbol</em><tt>,
true</tt>&#8217;&#8217; on each <em>symbol</em> in turn.
</p>
<pre>
   module Mod
     attr_accessor(:one, :two)
   end
   Mod.instance_methods.sort   #=&gt; [&quot;one&quot;, &quot;one=&quot;, &quot;two&quot;, &quot;two=&quot;]
</pre>
        </div>
      </div>

      <div id="method-M001679" class="method-detail">
        <a name="M001679"></a>

        <div class="method-heading">
          <a href="Module.src/M001679.html" target="Code" class="method-signature"
            onclick="popupCode('Module.src/M001679.html');return false;">
          <span class="method-name">attr_reader(symbol, ...)    => nil<br />
</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Creates instance variables and corresponding methods that return the value
of each instance variable. Equivalent to calling ``<tt><a
href="Module.html#M001678">attr</a></tt><em>:<a
href="Module.html#M001676">name</a></em>&#8217;&#8217; on each <a
href="Module.html#M001676">name</a> in turn.
</p>
        </div>
      </div>

      <div id="method-M001680" class="method-detail">
        <a name="M001680"></a>

        <div class="method-heading">
          <a href="Module.src/M001680.html" target="Code" class="method-signature"
            onclick="popupCode('Module.src/M001680.html');return false;">
          <span class="method-name">attr_writer(symbol, ...)    => nil<br />
</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Creates an accessor method to allow assignment to the attribute
<em>aSymbol</em><tt>.id2name</tt>.
</p>
        </div>
      </div>

      <div id="method-M001657" class="method-detail">
        <a name="M001657"></a>

        <div class="method-heading">
          <a href="Module.src/M001657.html" target="Code" class="method-signature"
            onclick="popupCode('Module.src/M001657.html');return false;">
          <span class="method-name">mod.autoload(name, filename)   => nil<br />
</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Registers <em>filename</em> to be loaded (using <tt>Kernel::require</tt>)
the first time that <em><a href="Module.html#M001676">name</a></em> (which
may be a <tt><a href="String.html">String</a></tt> or a symbol) is accessed
in the namespace of <em>mod</em>.
</p>
<pre>
   module A
   end
   A.autoload(:B, &quot;b&quot;)
   A::B.doit            # autoloads &quot;b&quot;
</pre>
        </div>
      </div>

      <div id="method-M001658" class="method-detail">
        <a name="M001658"></a>

        <div class="method-heading">
          <a href="Module.src/M001658.html" target="Code" class="method-signature"
            onclick="popupCode('Module.src/M001658.html');return false;">
          <span class="method-name">mod.autoload?(name)   => String or nil<br />
</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Returns <em>filename</em> to be loaded if <em><a
href="Module.html#M001676">name</a></em> is registered as <tt><a
href="Module.html#M001657">autoload</a></tt> in the namespace of
<em>mod</em>.
</p>
<pre>
   module A
   end
   A.autoload(:B, &quot;b&quot;)
   A.autoload?(:B)            # =&gt; &quot;b&quot;
</pre>
        </div>
      </div>

      <div id="method-M001650" class="method-detail">
        <a name="M001650"></a>

        <div class="method-heading">
          <a href="Module.src/M001650.html" target="Code" class="method-signature"
            onclick="popupCode('Module.src/M001650.html');return false;">
          <span class="method-name">mod.class_eval(string [, filename [, lineno]])  => obj<br />
mod.module_eval {|| block }                     => obj<br />
</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Evaluates the string or block in the context of <em>mod</em>. This can be
used to add methods to a class. <tt><a
href="Module.html#M001649">module_eval</a></tt> returns the result of
evaluating its argument. The optional <em>filename</em> and <em>lineno</em>
parameters set the text for error messages.
</p>
<pre>
   class Thing
   end
   a = %q{def hello() &quot;Hello there!&quot; end}
   Thing.module_eval(a)
   puts Thing.new.hello()
   Thing.module_eval(&quot;invalid code&quot;, &quot;dummy&quot;, 123)
</pre>
<p>
<em>produces:</em>
</p>
<pre>
   Hello there!
   dummy:123:in `module_eval': undefined local variable
       or method `code' for Thing:Class
</pre>
        </div>
      </div>

      <div id="method-M001687" class="method-detail">
        <a name="M001687"></a>

        <div class="method-heading">
          <a href="Module.src/M001687.html" target="Code" class="method-signature"
            onclick="popupCode('Module.src/M001687.html');return false;">
          <span class="method-name">obj.class_variable_defined?(symbol)    => true or false<br />
</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Returns <tt>true</tt> if the given class variable is defined in
<em>obj</em>.
</p>
<pre>
   class Fred
     @@foo = 99
   end
   Fred.class_variable_defined?(:@@foo)    #=&gt; true
   Fred.class_variable_defined?(:@@bar)    #=&gt; false
</pre>
        </div>
      </div>

      <div id="method-M001696" class="method-detail">
        <a name="M001696"></a>

        <div class="method-heading">
          <a href="Module.src/M001696.html" target="Code" class="method-signature"
            onclick="popupCode('Module.src/M001696.html');return false;">
          <span class="method-name">mod.class_variable_get(symbol)    => obj<br />
</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Returns the value of the given class variable (or throws a <tt><a
href="NameError.html">NameError</a></tt> exception). The <tt>@@</tt> part
of the variable <a href="Module.html#M001676">name</a> should be <a
href="Module.html#M001660">included</a> for regular class variables
</p>
<pre>
   class Fred
     @@foo = 99
   end

   def Fred.foo
     class_variable_get(:@@foo)     #=&gt; 99
   end
</pre>
        </div>
      </div>

      <div id="method-M001697" class="method-detail">
        <a name="M001697"></a>

        <div class="method-heading">
          <a href="Module.src/M001697.html" target="Code" class="method-signature"
            onclick="popupCode('Module.src/M001697.html');return false;">
          <span class="method-name">obj.class_variable_set(symbol, obj)    => obj<br />
</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Sets the class variable names by <em>symbol</em> to <em>object</em>.
</p>
<pre>
   class Fred
     @@foo = 99
     def foo
       @@foo
     end
   end

   def Fred.foo
     class_variable_set(:@@foo, 101)      #=&gt; 101
   end
   Fred.foo
   Fred.new.foo                             #=&gt; 101
</pre>
        </div>
      </div>

      <div id="method-M001694" class="method-detail">
        <a name="M001694"></a>

        <div class="method-heading">
          <a href="Module.src/M001694.html" target="Code" class="method-signature"
            onclick="popupCode('Module.src/M001694.html');return false;">
          <span class="method-name">mod.class_variables   => array<br />
</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Returns an array of the names of class variables in <em>mod</em> and the <a
href="Module.html#M001677">ancestors</a> of <em>mod</em>.
</p>
<pre>
   class One
     @@var1 = 1
   end
   class Two &lt; One
     @@var2 = 2
   end
   One.class_variables   #=&gt; [&quot;@@var1&quot;]
   Two.class_variables   #=&gt; [&quot;@@var2&quot;, &quot;@@var1&quot;]
</pre>
        </div>
      </div>

      <div id="method-M001691" class="method-detail">
        <a name="M001691"></a>

        <div class="method-heading">
          <a href="Module.src/M001691.html" target="Code" class="method-signature"
            onclick="popupCode('Module.src/M001691.html');return false;">
          <span class="method-name">mod.const_defined?(sym)   => true or false<br />
</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Returns <tt>true</tt> if a constant with the given <a
href="Module.html#M001676">name</a> is defined by <em>mod</em>.
</p>
<pre>
   Math.const_defined? &quot;PI&quot;   #=&gt; true
</pre>
        </div>
      </div>

      <div id="method-M001689" class="method-detail">
        <a name="M001689"></a>

        <div class="method-heading">
          <a href="Module.src/M001689.html" target="Code" class="method-signature"
            onclick="popupCode('Module.src/M001689.html');return false;">
          <span class="method-name">mod.const_get(sym)    => obj<br />
</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Returns the value of the named constant in <em>mod</em>.
</p>
<pre>
   Math.const_get(:PI)   #=&gt; 3.14159265358979
</pre>
        </div>
      </div>

      <div id="method-M001693" class="method-detail">
        <a name="M001693"></a>

        <div class="method-heading">
          <a href="Module.src/M001693.html" target="Code" class="method-signature"
            onclick="popupCode('Module.src/M001693.html');return false;">
          <span class="method-name">mod.const_missing(sym)    => obj<br />
</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Invoked when a reference is made to an undefined constant in <em>mod</em>.
It is passed a symbol for the undefined constant, and returns a value to be
used for that constant. The following code is a (very bad) example: if
reference is made to an undefined constant, it attempts to load a file
whose <a href="Module.html#M001676">name</a> is the lowercase version of
the constant (thus class <tt>Fred</tt> is assumed to be in file
<tt>fred.rb</tt>). If found, it returns the value of the loaded class. It
therefore implements a perverse kind of <a
href="Module.html#M001657">autoload</a> facility.
</p>
<pre>
  def Object.const_missing(name)
    @looked_for ||= {}
    str_name = name.to_s
    raise &quot;Class not found: #{name}&quot; if @looked_for[str_name]
    @looked_for[str_name] = 1
    file = str_name.downcase
    require file
    klass = const_get(name)
    return klass if klass
    raise &quot;Class not found: #{name}&quot;
  end
</pre>
        </div>
      </div>

      <div id="method-M001690" class="method-detail">
        <a name="M001690"></a>

        <div class="method-heading">
          <a href="Module.src/M001690.html" target="Code" class="method-signature"
            onclick="popupCode('Module.src/M001690.html');return false;">
          <span class="method-name">mod.const_set(sym, obj)    => obj<br />
</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Sets the named constant to the given object, returning that object. Creates
a <a href="Module.html#M001682">new</a> constant if no constant with the
given <a href="Module.html#M001676">name</a> previously existed.
</p>
<pre>
   Math.const_set(&quot;HIGH_SCHOOL_PI&quot;, 22.0/7.0)   #=&gt; 3.14285714285714
   Math::HIGH_SCHOOL_PI - Math::PI              #=&gt; 0.00126448926734968
</pre>
        </div>
      </div>

      <div id="method-M001688" class="method-detail">
        <a name="M001688"></a>

        <div class="method-heading">
          <a href="Module.src/M001688.html" target="Code" class="method-signature"
            onclick="popupCode('Module.src/M001688.html');return false;">
          <span class="method-name">mod.constants    => array<br />
</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Returns an array of the names of the <a
href="Module.html#M001656">constants</a> accessible in <em>mod</em>. This
includes the names of <a href="Module.html#M001656">constants</a> in any <a
href="Module.html#M001660">included</a> modules (example at start of
section).
</p>
        </div>
      </div>

      <div id="method-M001654" class="method-detail">
        <a name="M001654"></a>

        <div class="method-heading">
          <a href="Module.src/M001654.html" target="Code" class="method-signature"
            onclick="popupCode('Module.src/M001654.html');return false;">
          <span class="method-name">define_method(symbol, method)     => new_method<br />
define_method(symbol) { block }   => proc<br />
</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Defines an instance method in the receiver. The <em>method</em> parameter
can be a <tt><a href="Proc.html">Proc</a></tt> or <tt><a
href="Method.html">Method</a></tt> object. If a block is specified, it is
used as the method body. This block is evaluated using
<tt>instance_eval</tt>, a point that is tricky to demonstrate because
<tt><a href="Module.html#M001654">define_method</a></tt> is <a
href="Module.html#M001641">private</a>. (This is why we resort to the
<tt>send</tt> hack in this example.)
</p>
<pre>
   class A
     def fred
       puts &quot;In Fred&quot;
     end
     def create_method(name, &amp;block)
       self.class.send(:define_method, name, &amp;block)
     end
     define_method(:wilma) { puts &quot;Charge it!&quot; }
   end
   class B &lt; A
     define_method(:barney, instance_method(:fred))
   end
   a = B.new
   a.barney
   a.wilma
   a.create_method(:betty) { p self }
   a.betty
</pre>
<p>
<em>produces:</em>
</p>
<pre>
   In Fred
   Charge it!
   #&lt;B:0x401b39e8&gt;
</pre>
        </div>
      </div>

      <div id="method-M001637" class="method-detail">
        <a name="M001637"></a>

        <div class="method-heading">
          <a href="Module.src/M001637.html" target="Code" class="method-signature"
            onclick="popupCode('Module.src/M001637.html');return false;">
          <span class="method-name">extend_object(obj)    => obj<br />
</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Extends the specified object by adding this module&#8216;s <a
href="Module.html#M001656">constants</a> and methods (which are added as
singleton methods). This is the callback method used by <tt><a
href="Object.html#M000335">Object#extend</a></tt>.
</p>
<pre>
   module Picky
     def Picky.extend_object(o)
       if String === o
         puts &quot;Can't add Picky to a String&quot;
       else
         puts &quot;Picky added to #{o.class}&quot;
         super
       end
     end
   end
   (s = Array.new).extend Picky  # Call Object.extend
   (s = &quot;quick brown fox&quot;).extend Picky
</pre>
<p>
<em>produces:</em>
</p>
<pre>
   Picky added to Array
   Can't add Picky to a String
</pre>
        </div>
      </div>

      <div id="method-M001661" class="method-detail">
        <a name="M001661"></a>

        <div class="method-heading">
          <a href="Module.src/M001661.html" target="Code" class="method-signature"
            onclick="popupCode('Module.src/M001661.html');return false;">
          <span class="method-name">extended</span><span class="method-args">(p1)</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Not documented
</p>
        </div>
      </div>

      <div id="method-M001665" class="method-detail">
        <a name="M001665"></a>

        <div class="method-heading">
          <a href="Module.src/M001665.html" target="Code" class="method-signature"
            onclick="popupCode('Module.src/M001665.html');return false;">
          <span class="method-name">mod.freeze<br />
</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Prevents further modifications to <em>mod</em>.
</p>
        </div>
      </div>

      <div id="method-M001638" class="method-detail">
        <a name="M001638"></a>

        <div class="method-heading">
          <a href="Module.src/M001638.html" target="Code" class="method-signature"
            onclick="popupCode('Module.src/M001638.html');return false;">
          <span class="method-name">include(module, ...)    => self<br />
</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Invokes <tt><a href="Module.html#M001636">Module.append_features</a></tt>
on each parameter in turn.
</p>
        </div>
      </div>

      <div id="method-M001675" class="method-detail">
        <a name="M001675"></a>

        <div class="method-heading">
          <a href="Module.src/M001675.html" target="Code" class="method-signature"
            onclick="popupCode('Module.src/M001675.html');return false;">
          <span class="method-name">mod.include?(module)    => true or false<br />
</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Returns <tt>true</tt> if <em>module</em> is <a
href="Module.html#M001660">included</a> in <em>mod</em> or one of
<em>mod</em>&#8216;s <a href="Module.html#M001677">ancestors</a>.
</p>
<pre>
   module A
   end
   class B
     include A
   end
   class C &lt; B
   end
   B.include?(A)   #=&gt; true
   C.include?(A)   #=&gt; true
   A.include?(A)   #=&gt; false
</pre>
        </div>
      </div>

      <div id="method-M001660" class="method-detail">
        <a name="M001660"></a>

        <div class="method-heading">
          <a href="Module.src/M001660.html" target="Code" class="method-signature"
            onclick="popupCode('Module.src/M001660.html');return false;">
          <span class="method-name">included( othermod )<br />
</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Callback invoked whenever the receiver is <a
href="Module.html#M001660">included</a> in another module or class. This
should be used in preference to <tt><a
href="Module.html#M001636">Module.append_features</a></tt> if your code
wants to perform some action when a module is <a
href="Module.html#M001660">included</a> in another.
</p>
<pre>
       module A
         def A.included(mod)
           puts &quot;#{self} included in #{mod}&quot;
         end
       end
       module Enumerable
         include A
       end
</pre>
        </div>
      </div>

      <div id="method-M001674" class="method-detail">
        <a name="M001674"></a>

        <div class="method-heading">
          <a href="Module.src/M001674.html" target="Code" class="method-signature"
            onclick="popupCode('Module.src/M001674.html');return false;">
          <span class="method-name">mod.included_modules &rarr; array<br />
</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Returns the list of modules <a href="Module.html#M001660">included</a> in
<em>mod</em>.
</p>
<pre>
   module Mixin
   end

   module Outer
     include Mixin
   end

   Mixin.included_modules   #=&gt; []
   Outer.included_modules   #=&gt; [Mixin]
</pre>
        </div>
      </div>

      <div id="method-M001659" class="method-detail">
        <a name="M001659"></a>

        <div class="method-heading">
          <a href="Module.src/M001659.html" target="Code" class="method-signature"
            onclick="popupCode('Module.src/M001659.html');return false;">
          <span class="method-name">mod.instance_method(symbol)   => unbound_method<br />
</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Returns an <tt><a href="UnboundMethod.html">UnboundMethod</a></tt>
representing the given instance method in <em>mod</em>.
</p>
<pre>
   class Interpreter
     def do_a() print &quot;there, &quot;; end
     def do_d() print &quot;Hello &quot;;  end
     def do_e() print &quot;!\n&quot;;     end
     def do_v() print &quot;Dave&quot;;    end
     Dispatcher = {
      ?a =&gt; instance_method(:do_a),
      ?d =&gt; instance_method(:do_d),
      ?e =&gt; instance_method(:do_e),
      ?v =&gt; instance_method(:do_v)
     }
     def interpret(string)
       string.each_byte {|b| Dispatcher[b].bind(self).call }
     end
   end

   interpreter = Interpreter.new
   interpreter.interpret('dave')
</pre>
<p>
<em>produces:</em>
</p>
<pre>
   Hello there, Dave!
</pre>
        </div>
      </div>

      <div id="method-M001683" class="method-detail">
        <a name="M001683"></a>

        <div class="method-heading">
          <a href="Module.src/M001683.html" target="Code" class="method-signature"
            onclick="popupCode('Module.src/M001683.html');return false;">
          <span class="method-name">mod.instance_methods(include_super=true)   => array<br />
</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Returns an array containing the names of <a
href="Module.html#M001639">public</a> instance methods in the receiver. For
a module, these are the <a href="Module.html#M001639">public</a> methods;
for a class, they are the instance (not singleton) methods. With no
argument, or with an argument that is <tt>false</tt>, the instance methods
in <em>mod</em> are returned, otherwise the methods in <em>mod</em> and
<em>mod</em>&#8216;s superclasses are returned.
</p>
<pre>
   module A
     def method1()  end
   end
   class B
     def method2()  end
   end
   class C &lt; B
     def method3()  end
   end

   A.instance_methods                #=&gt; [&quot;method1&quot;]
   B.instance_methods(false)         #=&gt; [&quot;method2&quot;]
   C.instance_methods(false)         #=&gt; [&quot;method3&quot;]
   C.instance_methods(true).length   #=&gt; 43
</pre>
        </div>
      </div>

      <div id="method-M001662" class="method-detail">
        <a name="M001662"></a>

        <div class="method-heading">
          <a href="Module.src/M001662.html" target="Code" class="method-signature"
            onclick="popupCode('Module.src/M001662.html');return false;">
          <span class="method-name">method_added</span><span class="method-args">(p1)</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Not documented
</p>
        </div>
      </div>

      <div id="method-M001643" class="method-detail">
        <a name="M001643"></a>

        <div class="method-heading">
          <a href="Module.src/M001643.html" target="Code" class="method-signature"
            onclick="popupCode('Module.src/M001643.html');return false;">
          <span class="method-name">mod.method_defined?(symbol)    => true or false<br />
</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Returns <tt>true</tt> if the named method is defined by <em>mod</em> (or
its <a href="Module.html#M001660">included</a> modules and, if <em>mod</em>
is a class, its <a href="Module.html#M001677">ancestors</a>). Public and <a
href="Module.html#M001640">protected</a> methods are matched.
</p>
<pre>
   module A
     def method1()  end
   end
   class B
     def method2()  end
   end
   class C &lt; B
     include A
     def method3()  end
   end

   A.method_defined? :method1    #=&gt; true
   C.method_defined? &quot;method1&quot;   #=&gt; true
   C.method_defined? &quot;method2&quot;   #=&gt; true
   C.method_defined? &quot;method3&quot;   #=&gt; true
   C.method_defined? &quot;method4&quot;   #=&gt; false
</pre>
        </div>
      </div>

      <div id="method-M001663" class="method-detail">
        <a name="M001663"></a>

        <div class="method-heading">
          <a href="Module.src/M001663.html" target="Code" class="method-signature"
            onclick="popupCode('Module.src/M001663.html');return false;">
          <span class="method-name">method_removed</span><span class="method-args">(p1)</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Not documented
</p>
        </div>
      </div>

      <div id="method-M001664" class="method-detail">
        <a name="M001664"></a>

        <div class="method-heading">
          <a href="Module.src/M001664.html" target="Code" class="method-signature"
            onclick="popupCode('Module.src/M001664.html');return false;">
          <span class="method-name">method_undefined</span><span class="method-args">(p1)</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Not documented
</p>
        </div>
      </div>

      <div id="method-M001649" class="method-detail">
        <a name="M001649"></a>

        <div class="method-heading">
          <a href="Module.src/M001649.html" target="Code" class="method-signature"
            onclick="popupCode('Module.src/M001649.html');return false;">
          <span class="method-name">mod.class_eval(string [, filename [, lineno]])  => obj<br />
mod.module_eval {|| block }                     => obj<br />
</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Evaluates the string or block in the context of <em>mod</em>. This can be
used to add methods to a class. <tt><a
href="Module.html#M001649">module_eval</a></tt> returns the result of
evaluating its argument. The optional <em>filename</em> and <em>lineno</em>
parameters set the text for error messages.
</p>
<pre>
   class Thing
   end
   a = %q{def hello() &quot;Hello there!&quot; end}
   Thing.module_eval(a)
   puts Thing.new.hello()
   Thing.module_eval(&quot;invalid code&quot;, &quot;dummy&quot;, 123)
</pre>
<p>
<em>produces:</em>
</p>
<pre>
   Hello there!
   dummy:123:in `module_eval': undefined local variable
       or method `code' for Thing:Class
</pre>
        </div>
      </div>

      <div id="method-M001642" class="method-detail">
        <a name="M001642"></a>

        <div class="method-heading">
          <a href="Module.src/M001642.html" target="Code" class="method-signature"
            onclick="popupCode('Module.src/M001642.html');return false;">
          <span class="method-name">module_function(symbol, ...)    => self<br />
</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Creates module functions for the named methods. These functions may be
called with the module as a receiver, and also become available as instance
methods to classes that mix in the module. <a href="Module.html">Module</a>
functions are copies of the original, and so may be changed independently.
The instance-method versions are made <a
href="Module.html#M001641">private</a>. If used with no arguments,
subsequently defined methods become module functions.
</p>
<pre>
   module Mod
     def one
       &quot;This is one&quot;
     end
     module_function :one
   end
   class Cls
     include Mod
     def callOne
       one
     end
   end
   Mod.one     #=&gt; &quot;This is one&quot;
   c = Cls.new
   c.callOne   #=&gt; &quot;This is one&quot;
   module Mod
     def one
       &quot;This is the new one&quot;
     end
   end
   Mod.one     #=&gt; &quot;This is one&quot;
   c.callOne   #=&gt; &quot;This is the new one&quot;
</pre>
        </div>
      </div>

      <div id="method-M001676" class="method-detail">
        <a name="M001676"></a>

        <div class="method-heading">
          <a href="Module.src/M001676.html" target="Code" class="method-signature"
            onclick="popupCode('Module.src/M001676.html');return false;">
          <span class="method-name">mod.name    => string<br />
</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Returns the <a href="Module.html#M001676">name</a> of the module
<em>mod</em>.
</p>
        </div>
      </div>

      <div id="method-M001641" class="method-detail">
        <a name="M001641"></a>

        <div class="method-heading">
          <a href="Module.src/M001641.html" target="Code" class="method-signature"
            onclick="popupCode('Module.src/M001641.html');return false;">
          <span class="method-name">private                 => self<br />
private(symbol, ...)    => self<br />
</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
With no arguments, sets the default visibility for subsequently defined
methods to <a href="Module.html#M001641">private</a>. With arguments, sets
the named methods to have <a href="Module.html#M001641">private</a>
visibility.
</p>
<pre>
   module Mod
     def a()  end
     def b()  end
     private
     def c()  end
     private :a
   end
   Mod.private_instance_methods   #=&gt; [&quot;a&quot;, &quot;c&quot;]
</pre>
        </div>
      </div>

      <div id="method-M001648" class="method-detail">
        <a name="M001648"></a>

        <div class="method-heading">
          <a href="Module.src/M001648.html" target="Code" class="method-signature"
            onclick="popupCode('Module.src/M001648.html');return false;">
          <span class="method-name">mod.private_class_method(symbol, ...)   => mod<br />
</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Makes existing class methods <a href="Module.html#M001641">private</a>.
Often used to hide the default constructor <tt><a
href="Module.html#M001682">new</a></tt>.
</p>
<pre>
   class SimpleSingleton  # Not thread safe
     private_class_method :new
     def SimpleSingleton.create(*args, &amp;block)
       @me = new(*args, &amp;block) if ! @me
       @me
     end
   end
</pre>
        </div>
      </div>

      <div id="method-M001686" class="method-detail">
        <a name="M001686"></a>

        <div class="method-heading">
          <a href="Module.src/M001686.html" target="Code" class="method-signature"
            onclick="popupCode('Module.src/M001686.html');return false;">
          <span class="method-name">mod.private_instance_methods(include_super=true)    => array<br />
</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Returns a list of the <a href="Module.html#M001641">private</a> instance
methods defined in <em>mod</em>. If the optional parameter is not
<tt>false</tt>, the methods of any <a
href="Module.html#M001677">ancestors</a> are <a
href="Module.html#M001660">included</a>.
</p>
<pre>
   module Mod
     def method1()  end
     private :method1
     def method2()  end
   end
   Mod.instance_methods           #=&gt; [&quot;method2&quot;]
   Mod.private_instance_methods   #=&gt; [&quot;method1&quot;]
</pre>
        </div>
      </div>

      <div id="method-M001645" class="method-detail">
        <a name="M001645"></a>

        <div class="method-heading">
          <a href="Module.src/M001645.html" target="Code" class="method-signature"
            onclick="popupCode('Module.src/M001645.html');return false;">
          <span class="method-name">mod.private_method_defined?(symbol)    => true or false<br />
</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Returns <tt>true</tt> if the named <a
href="Module.html#M001641">private</a> method is defined by _ mod_ (or its
<a href="Module.html#M001660">included</a> modules and, if <em>mod</em> is
a class, its <a href="Module.html#M001677">ancestors</a>).
</p>
<pre>
   module A
     def method1()  end
   end
   class B
     private
     def method2()  end
   end
   class C &lt; B
     include A
     def method3()  end
   end

   A.method_defined? :method1            #=&gt; true
   C.private_method_defined? &quot;method1&quot;   #=&gt; false
   C.private_method_defined? &quot;method2&quot;   #=&gt; true
   C.method_defined? &quot;method2&quot;           #=&gt; false
</pre>
        </div>
      </div>

      <div id="method-M001640" class="method-detail">
        <a name="M001640"></a>

        <div class="method-heading">
          <a href="Module.src/M001640.html" target="Code" class="method-signature"
            onclick="popupCode('Module.src/M001640.html');return false;">
          <span class="method-name">protected                => self<br />
protected(symbol, ...)   => self<br />
</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
With no arguments, sets the default visibility for subsequently defined
methods to <a href="Module.html#M001640">protected</a>. With arguments,
sets the named methods to have <a href="Module.html#M001640">protected</a>
visibility.
</p>
        </div>
      </div>

      <div id="method-M001685" class="method-detail">
        <a name="M001685"></a>

        <div class="method-heading">
          <a href="Module.src/M001685.html" target="Code" class="method-signature"
            onclick="popupCode('Module.src/M001685.html');return false;">
          <span class="method-name">mod.protected_instance_methods(include_super=true)   => array<br />
</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Returns a list of the <a href="Module.html#M001640">protected</a> instance
methods defined in <em>mod</em>. If the optional parameter is not
<tt>false</tt>, the methods of any <a
href="Module.html#M001677">ancestors</a> are <a
href="Module.html#M001660">included</a>.
</p>
        </div>
      </div>

      <div id="method-M001646" class="method-detail">
        <a name="M001646"></a>

        <div class="method-heading">
          <a href="Module.src/M001646.html" target="Code" class="method-signature"
            onclick="popupCode('Module.src/M001646.html');return false;">
          <span class="method-name">mod.protected_method_defined?(symbol)   => true or false<br />
</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Returns <tt>true</tt> if the named <a
href="Module.html#M001640">protected</a> method is defined by <em>mod</em>
(or its <a href="Module.html#M001660">included</a> modules and, if
<em>mod</em> is a class, its <a href="Module.html#M001677">ancestors</a>).
</p>
<pre>
   module A
     def method1()  end
   end
   class B
     protected
     def method2()  end
   end
   class C &lt; B
     include A
     def method3()  end
   end

   A.method_defined? :method1              #=&gt; true
   C.protected_method_defined? &quot;method1&quot;   #=&gt; false
   C.protected_method_defined? &quot;method2&quot;   #=&gt; true
   C.method_defined? &quot;method2&quot;             #=&gt; true
</pre>
        </div>
      </div>

      <div id="method-M001639" class="method-detail">
        <a name="M001639"></a>

        <div class="method-heading">
          <a href="Module.src/M001639.html" target="Code" class="method-signature"
            onclick="popupCode('Module.src/M001639.html');return false;">
          <span class="method-name">public                 => self<br />
public(symbol, ...)    => self<br />
</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
With no arguments, sets the default visibility for subsequently defined
methods to <a href="Module.html#M001639">public</a>. With arguments, sets
the named methods to have <a href="Module.html#M001639">public</a>
visibility.
</p>
        </div>
      </div>

      <div id="method-M001647" class="method-detail">
        <a name="M001647"></a>

        <div class="method-heading">
          <a href="Module.src/M001647.html" target="Code" class="method-signature"
            onclick="popupCode('Module.src/M001647.html');return false;">
          <span class="method-name">mod.public_class_method(symbol, ...)    => mod<br />
</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Makes a list of existing class methods <a
href="Module.html#M001639">public</a>.
</p>
        </div>
      </div>

      <div id="method-M001684" class="method-detail">
        <a name="M001684"></a>

        <div class="method-heading">
          <a href="Module.src/M001684.html" target="Code" class="method-signature"
            onclick="popupCode('Module.src/M001684.html');return false;">
          <span class="method-name">mod.public_instance_methods(include_super=true)   => array<br />
</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Returns a list of the <a href="Module.html#M001639">public</a> instance
methods defined in <em>mod</em>. If the optional parameter is not
<tt>false</tt>, the methods of any <a
href="Module.html#M001677">ancestors</a> are <a
href="Module.html#M001660">included</a>.
</p>
        </div>
      </div>

      <div id="method-M001644" class="method-detail">
        <a name="M001644"></a>

        <div class="method-heading">
          <a href="Module.src/M001644.html" target="Code" class="method-signature"
            onclick="popupCode('Module.src/M001644.html');return false;">
          <span class="method-name">mod.public_method_defined?(symbol)   => true or false<br />
</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Returns <tt>true</tt> if the named <a href="Module.html#M001639">public</a>
method is defined by <em>mod</em> (or its <a
href="Module.html#M001660">included</a> modules and, if <em>mod</em> is a
class, its <a href="Module.html#M001677">ancestors</a>).
</p>
<pre>
   module A
     def method1()  end
   end
   class B
     protected
     def method2()  end
   end
   class C &lt; B
     include A
     def method3()  end
   end

   A.method_defined? :method1           #=&gt; true
   C.public_method_defined? &quot;method1&quot;   #=&gt; true
   C.public_method_defined? &quot;method2&quot;   #=&gt; false
   C.method_defined? &quot;method2&quot;          #=&gt; true
</pre>
        </div>
      </div>

      <div id="method-M001695" class="method-detail">
        <a name="M001695"></a>

        <div class="method-heading">
          <a href="Module.src/M001695.html" target="Code" class="method-signature"
            onclick="popupCode('Module.src/M001695.html');return false;">
          <span class="method-name">remove_class_variable(sym)    => obj<br />
</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Removes the definition of the <em>sym</em>, returning that constant&#8216;s
value.
</p>
<pre>
   class Dummy
     @@var = 99
     puts @@var
     remove_class_variable(:@@var)
     puts(defined? @@var)
   end
</pre>
<p>
<em>produces:</em>
</p>
<pre>
   99
   nil
</pre>
        </div>
      </div>

      <div id="method-M001692" class="method-detail">
        <a name="M001692"></a>

        <div class="method-heading">
          <a href="Module.src/M001692.html" target="Code" class="method-signature"
            onclick="popupCode('Module.src/M001692.html');return false;">
          <span class="method-name">remove_const(sym)   => obj<br />
</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Removes the definition of the given constant, returning that
constant&#8216;s value. Predefined classes and singleton objects (such as
<em>true</em>) cannot be removed.
</p>
        </div>
      </div>

      <div id="method-M001651" class="method-detail">
        <a name="M001651"></a>

        <div class="method-heading">
          <a href="Module.src/M001651.html" target="Code" class="method-signature"
            onclick="popupCode('Module.src/M001651.html');return false;">
          <span class="method-name">remove_method(symbol)   => self<br />
</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Removes the method identified by <em>symbol</em> from the current class.
For an example, see <tt><a
href="Module.html#M001652">Module.undef_method</a></tt>.
</p>
        </div>
      </div>

      <div id="method-M001673" class="method-detail">
        <a name="M001673"></a>

        <div class="method-heading">
          <a href="Module.src/M001673.html" target="Code" class="method-signature"
            onclick="popupCode('Module.src/M001673.html');return false;">
          <span class="method-name">mod.to_s   => string<br />
</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Return a string representing this module or class. For basic classes and
modules, this is the <a href="Module.html#M001676">name</a>. For
singletons, we show information on the thing we&#8216;re attached to as
well.
</p>
        </div>
      </div>

      <div id="method-M001652" class="method-detail">
        <a name="M001652"></a>

        <div class="method-heading">
          <a href="Module.src/M001652.html" target="Code" class="method-signature"
            onclick="popupCode('Module.src/M001652.html');return false;">
          <span class="method-name">undef_method(symbol)    => self<br />
</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Prevents the current class from responding to calls to the named method.
Contrast this with <tt><a
href="Module.html#M001651">remove_method</a></tt>, which deletes the method
from the particular class; Ruby will still search superclasses and mixed-in
modules for a possible receiver.
</p>
<pre>
   class Parent
     def hello
       puts &quot;In parent&quot;
     end
   end
   class Child &lt; Parent
     def hello
       puts &quot;In child&quot;
     end
   end

   c = Child.new
   c.hello

   class Child
     remove_method :hello  # remove from child, still in parent
   end
   c.hello

   class Child
     undef_method :hello   # prevent any calls to 'hello'
   end
   c.hello
</pre>
<p>
<em>produces:</em>
</p>
<pre>
   In child
   In parent
   prog.rb:23: undefined method `hello' for #&lt;Child:0x401b3bb4&gt; (NoMethodError)
</pre>
        </div>
      </div>


    </div>


  </div>


<div id="validator-badges">
  <p><small><a href="http://validator.w3.org/check/referer">[Validate]</a></small></p>
</div>

<div style="font-size: smaller; text-align:center" id="credits">
 <!-- 2 --><p> <a href="http://www.ruby-doc.org">ruby-doc.org</a> is a service of <a href="http://www.jamesbritt.com">James Britt</a> and <a href="http://www.neurogami.com">Neurogami</a>, a <a href="http://www.neurogami.com"> Ruby application development company in Phoenix, AZ</a>. </p>
  <p><span>Documentation content on <a href="http://ruby-doc.org">ruby-doc.org</a> is provided by </span><a href="http://www.ruby-doc.org/about">remarkable members</a> of the Ruby community.</p>
  <p>For more information on the Ruby programming language, visit <a href="http://www.ruby-lang.org">ruby-lang.org</a>.</p>
  <p>Want to help improve Ruby's API docs? See <a href="/documentation-guidelines.html"> Ruby Documentation Guidelines</a>.</p>
  </div>



</body>
</html>