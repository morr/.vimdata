<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html 
     PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
     "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html>
<head>
  <title>sort_by (Enumerable)</title>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
  <link rel="stylesheet" href="../.././rdoc-style.css" type="text/css" media="screen" />
</head>
<body class="standalone-code">
  <pre>/*
 *  call-seq:
 *     enum.sort_by {| obj | block }    =&gt; array
 *  
 *  Sorts &lt;i&gt;enum&lt;/i&gt; using a set of keys generated by mapping the
 *  values in &lt;i&gt;enum&lt;/i&gt; through the given block.
 *     
 *     %w{ apple pear fig }.sort_by {|word| word.length}
                    #=&gt; [&quot;fig&quot;, &quot;pear&quot;, &quot;apple&quot;]
 *     
 *  The current implementation of &lt;code&gt;sort_by&lt;/code&gt; generates an
 *  array of tuples containing the original collection element and the
 *  mapped value. This makes &lt;code&gt;sort_by&lt;/code&gt; fairly expensive when
 *  the keysets are simple
 *     
 *     require 'benchmark'
 *     include Benchmark
 *     
 *     a = (1..100000).map {rand(100000)}
 *     
 *     bm(10) do |b|
 *       b.report(&quot;Sort&quot;)    { a.sort }
 *       b.report(&quot;Sort by&quot;) { a.sort_by {|a| a} }
 *     end
 *     
 *  &lt;em&gt;produces:&lt;/em&gt;
 *     
 *     user     system      total        real
 *     Sort        0.180000   0.000000   0.180000 (  0.175469)
 *     Sort by     1.980000   0.040000   2.020000 (  2.013586)
 *     
 *  However, consider the case where comparing the keys is a non-trivial
 *  operation. The following code sorts some files on modification time
 *  using the basic &lt;code&gt;sort&lt;/code&gt; method.
 *     
 *     files = Dir[&quot;*&quot;]
 *     sorted = files.sort {|a,b| File.new(a).mtime &lt;=&gt; File.new(b).mtime}
 *     sorted   #=&gt; [&quot;mon&quot;, &quot;tues&quot;, &quot;wed&quot;, &quot;thurs&quot;]
 *     
 *  This sort is inefficient: it generates two new &lt;code&gt;File&lt;/code&gt;
 *  objects during every comparison. A slightly better technique is to
 *  use the &lt;code&gt;Kernel#test&lt;/code&gt; method to generate the modification
 *  times directly.
 *     
 *     files = Dir[&quot;*&quot;]
 *     sorted = files.sort { |a,b|
 *       test(?M, a) &lt;=&gt; test(?M, b)
 *     }
 *     sorted   #=&gt; [&quot;mon&quot;, &quot;tues&quot;, &quot;wed&quot;, &quot;thurs&quot;]
 *     
 *  This still generates many unnecessary &lt;code&gt;Time&lt;/code&gt; objects. A
 *  more efficient technique is to cache the sort keys (modification
 *  times in this case) before the sort. Perl users often call this
 *  approach a Schwartzian Transform, after Randal Schwartz. We
 *  construct a temporary array, where each element is an array
 *  containing our sort key along with the filename. We sort this array,
 *  and then extract the filename from the result.
 *     
 *     sorted = Dir[&quot;*&quot;].collect { |f|
 *        [test(?M, f), f]
 *     }.sort.collect { |f| f[1] }
 *     sorted   #=&gt; [&quot;mon&quot;, &quot;tues&quot;, &quot;wed&quot;, &quot;thurs&quot;]
 *     
 *  This is exactly what &lt;code&gt;sort_by&lt;/code&gt; does internally.
 *     
 *     sorted = Dir[&quot;*&quot;].sort_by {|f| test(?M, f)}
 *     sorted   #=&gt; [&quot;mon&quot;, &quot;tues&quot;, &quot;wed&quot;, &quot;thurs&quot;]
 */

static VALUE
enum_sort_by(obj)
    VALUE obj;
{
    VALUE ary;
    long i;

    if (TYPE(obj) == T_ARRAY) {
        ary  = rb_ary_new2(RARRAY(obj)-&gt;len);
    }
    else {
        ary = rb_ary_new();
    }
    RBASIC(ary)-&gt;klass = 0;
    rb_iterate(rb_each, obj, sort_by_i, ary);
    if (RARRAY(ary)-&gt;len &gt; 1) {
        qsort(RARRAY(ary)-&gt;ptr, RARRAY(ary)-&gt;len, sizeof(VALUE), sort_by_cmp, 0);
    }
    if (RBASIC(ary)-&gt;klass) {
        rb_raise(rb_eRuntimeError, &quot;sort_by reentered&quot;);
    }
    for (i=0; i&lt;RARRAY(ary)-&gt;len; i++) {
        RARRAY(ary)-&gt;ptr[i] = RNODE(RARRAY(ary)-&gt;ptr[i])-&gt;u2.value;
    }
    RBASIC(ary)-&gt;klass = rb_cArray;
    return ary;
}</pre>
</body>
</html>