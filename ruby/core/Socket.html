<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html 
     PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
     "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>Class: Socket</title>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
  <meta http-equiv="Content-Script-Type" content="text/javascript" />
  <link rel="stylesheet" href=".././rdoc-style.css" type="text/css" media="screen" />
  <script type="text/javascript">
  // <![CDATA[

  function popupCode( url ) {
    window.open(url, "Code", "resizable=yes,scrollbars=yes,toolbar=no,status=no,height=150,width=400")
  }

  function toggleCode( id ) {
    if ( document.getElementById )
      elem = document.getElementById( id );
    else if ( document.all )
      elem = eval( "document.all." + id );
    else
      return false;

    elemStyle = elem.style;
    
    if ( elemStyle.display != "block" ) {
      elemStyle.display = "block"
    } else {
      elemStyle.display = "none"
    }

    return true;
  }
  
  // Make codeblocks hidden by default
  document.writeln( "<style type=\"text/css\">div.method-source-code { display: none }</style>" )
  
  // ]]>
  </script>

</head>
<body>



    <div id="classHeader">
        <table class="header-table">
        <tr class="top-aligned-row">
          <td><strong>Class</strong></td>
          <td class="class-name-in-header">Socket</td>
        </tr>
        <tr class="top-aligned-row">
            <td><strong>In:</strong></td>
            <td>
                <a href="../files/lib/ipaddr_rb.html">
                lib/ipaddr.rb
                </a>
        <br />
                <a href="../files/ext/socket/socket_c.html">
                ext/socket/socket.c
                </a>
        <br />
            </td>
        </tr>

        <tr class="top-aligned-row">
            <td><strong>Parent:</strong></td>
            <td>
                <a href="Object.html">
                Object
               </a>
            </td>
        </tr>
        </table>
    </div>
  <!-- banner header -->

  <div id="bodyContent">



  <div id="contextContent">

    <div id="description">
      <p>
<a href="Class.html">Class</a> <tt><a href="Socket.html">Socket</a></tt>
provides access to the underlying operating system socket implementations.
It can be used to provide more operating system specific functionality than
the protocol-specific socket classes but at the expense of greater
complexity. In particular, the class handles addresses using +struct
sockaddr+ structures packed into Ruby strings, which can be a joy to
manipulate.
</p>
<h3><a href="Exception.html">Exception</a> Handling</h3>
<p>
Ruby&#8216;s implementation of <tt><a href="Socket.html">Socket</a></tt>
causes an exception to be raised based on the error generated by the system
dependent implementation. This is why the methods are documented in a way
that isolate Unix-based system exceptions from Windows based exceptions. If
more information on particular exception is needed please refer to the Unix
manual pages or the Windows WinSock reference.
</p>
<h3>Documentation by</h3>
<ul>
<li>Zach Dennis

</li>
<li>Sam Roberts

</li>
<li><em>Programming Ruby</em> from The Pragmatic Bookshelf.

</li>
</ul>
<p>
Much material in this documentation is taken with permission from
<em>Programming Ruby</em> from The Pragmatic Bookshelf.
</p>

    </div>


   </div>

    <div id="method-list">
      <h3 class="section-bar">Methods</h3>

      <div class="name-list">
      <a href="#M002094">accept</a>&nbsp;&nbsp;
      <a href="#M002095">accept_nonblock</a>&nbsp;&nbsp;
      <a href="#M002092">bind</a>&nbsp;&nbsp;
      <a href="#M002090">connect</a>&nbsp;&nbsp;
      <a href="#M002091">connect_nonblock</a>&nbsp;&nbsp;
      <a href="#M002101">getaddrinfo</a>&nbsp;&nbsp;
      <a href="#M002099">gethostbyname</a>&nbsp;&nbsp;
      <a href="#M002100">getservbyname</a>&nbsp;&nbsp;
      <a href="#M002093">listen</a>&nbsp;&nbsp;
      <a href="#M002097">recvfrom</a>&nbsp;&nbsp;
      <a href="#M002098">recvfrom_nonblock</a>&nbsp;&nbsp;
      <a href="#M002096">sysaccept</a>&nbsp;&nbsp;
      </div>
    </div>

  </div>


    <!-- if includes -->

    <div id="section">

    <div id="class-list">
      <h3 class="section-bar">Classes and Modules</h3>

      Module <a href="Socket/Constants.html" class="link">Socket::Constants</a><br />

    </div>

    <div id="constants-list">
      <h3 class="section-bar">Constants</h3>

      <div class="name-list">
        <table summary="Constants">
        <tr class="top-aligned-row context-row">
          <td class="context-item-name">AF_INET6</td>
          <td>=</td>
          <td class="context-item-value">Object.new</td>
        </tr>
        </table>
      </div>
    </div>



      


    <!-- if method_list -->
    <div id="methods">
      <h3 class="section-bar">Public Class methods</h3>

      <div id="method-M002101" class="method-detail">
        <a name="M002101"></a>

        <div class="method-heading">
          <a href="Socket.src/M002101.html" target="Code" class="method-signature"
            onclick="popupCode('Socket.src/M002101.html');return false;">
          <span class="method-name"> Socket.getaddrinfo(host, service, family=nil, socktype=nil, protocol=nil, flags=nil) => addrinfo<br />
</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Return address information for <tt>host</tt> and <tt>port</tt>. The
remaining arguments are hints that limit the address information returned.
</p>
<p>
This method corresponds closely to the POSIX.1g <a
href="Socket.html#M002101">getaddrinfo</a>() definition.
</p>
<h3>Parameters</h3>
<ul>
<li><tt>host</tt> is a host name or an address string (dotted decimal for IPv4,
or a hex string for IPv6) for which to return information. A nil is also
allowed, its meaning depends on <tt>flags</tt>, see below.

</li>
<li><tt>service</tt> is a service name (&quot;http&quot;, &quot;ssh&quot;,
&#8230;), or a port number (80, 22, &#8230;), see <a
href="Socket.html#M002100">Socket.getservbyname</a> for more information. A
nil is also allowed, meaning zero.

</li>
<li><tt>family</tt> limits the output to a specific address family, one of the
Socket::AF_* constants. Socket::AF_INET (IPv4) and Socket::AF_INET6 (IPv6)
are the most commonly used families. You will usually pass either nil or
Socket::AF_UNSPEC, allowing the IPv6 information to be returned first if
<tt>host</tt> is reachable via IPv6, and IPv4 information otherwise. The
two strings &quot;AF_INET&quot; or &quot;AF_INET6&quot; are also allowed,
they are converted to their respective Socket::AF_* constants.

</li>
<li><tt>socktype</tt> limits the output to a specific type of socket, one of
the Socket::SOCK_* constants. Socket::SOCK_STREAM (for TCP) and
Socket::SOCK_DGRAM (for UDP) are the most commonly used socket types. If
nil, then information for all types of sockets supported by
<tt>service</tt> will be returned. You will usually know what type of
socket you intend to create, and should pass that socket type in.

</li>
<li><tt>protocol</tt> limits the output to a specific protocol numpber, one of
the Socket::IPPROTO_* constants. It is usually implied by the socket type
(Socket::SOCK_STREAM =&gt; Socket::IPPROTO_TCP, &#8230;), if you pass other
than nil you already know what this is for.

</li>
<li><tt>flags</tt> is one of the Socket::AI_* constants. They mean:

<ul>
<li>Socket::AI_PASSIVE: when set, if <tt>host</tt> is nil the &#8216;any&#8217;
address will be returned, Socket::INADDR_ANY or 0 for IPv4,
&quot;0::0&quot; or &quot;::&quot; for IPv6. This address is suitable for
use by servers that will <a href="Socket.html#M002092">bind</a> their
socket and do a passive <a href="Socket.html#M002093">listen</a>, thus the
name of the flag. Otherwise the local or loopback address will be returned,
this is &quot;127.0.0.1&quot; for IPv4 and &quot;::1&#8217; for IPv6.

</li>
<li>&#8230;

</li>
</ul>
</li>
</ul>
<h3>Returns</h3>
<p>
Returns an array of arrays, where each subarray contains:
</p>
<ul>
<li>address family, a string like &quot;AF_INET&quot; or &quot;AF_INET6&quot;

</li>
<li>port number, the port number for <tt>service</tt>

</li>
<li>host name, either a canonical name for <tt>host</tt>, or it&#8216;s address
in presentation format if the address could not be looked up.

</li>
<li>host IP, the address of <tt>host</tt> in presentation format

</li>
<li>address family, as a numeric value (one of the Socket::AF_* constants).

</li>
<li>socket type, as a numeric value (one of the Socket::SOCK_* constants).

</li>
<li>protocol number, as a numeric value (one of the Socket::IPPROTO_*
constants).

</li>
</ul>
<p>
The first four values are identical to what is commonly returned as an
address array, see <a href="IPSocket.html">IPSocket</a> for more
information.
</p>
<h3>Examples</h3>
<p>
Not all input combinations are valid, and while there are many
combinations, only a few cases are common.
</p>
<p>
A typical client will call <a href="Socket.html#M002101">getaddrinfo</a>
with the <tt>host</tt> and <tt>service</tt> it wants to <a
href="Socket.html#M002090">connect</a> to. It knows that it will attempt to
<a href="Socket.html#M002090">connect</a> with either TCP or UDP, and
specifies <tt>socktype</tt> accordingly. It loops through all returned
addresses, and try to <a href="Socket.html#M002090">connect</a> to them in
turn:
</p>
<pre>
  addrinfo = Socket::getaddrinfo('www.example.com', 'www', nil, Socket::SOCK_STREAM)
  addrinfo.each do |af, port, name, addr|
    begin
      sock = TCPSocket.new(addr, port)
      # ...
      exit 1
    rescue
    end
  end
</pre>
<p>
With UDP you don&#8216;t know if <a href="Socket.html#M002090">connect</a>
suceeded, but if communication fails, the next address can be tried.
</p>
<p>
A typical server will call <a href="Socket.html#M002101">getaddrinfo</a>
with a <tt>host</tt> of nil, the <tt>service</tt> it listens to, and a
<tt>flags</tt> of Socket::AI_PASSIVE. It will <a
href="Socket.html#M002093">listen</a> for connections on the first returned
address:
</p>
<pre>
  addrinfo = Socket::getaddrinfo(nil, 'www', nil, Socket::SOCK_STREAM, nil, Socket::AI_PASSIVE)
  af, port, name, addr = addrinfo.first
  sock = TCPServer(addr, port)
  while( client = s.accept )
    # ...
  end
</pre>
        </div>
      </div>

      <div id="method-M002099" class="method-detail">
        <a name="M002099"></a>

        <div class="method-heading">
          <a href="Socket.src/M002099.html" target="Code" class="method-signature"
            onclick="popupCode('Socket.src/M002099.html');return false;">
          <span class="method-name"> Socket.gethostbyname(host) => hostent<br />
</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Resolve <tt>host</tt> and return name and address information for it,
similarly to <a href="Socket.html#M002099">gethostbyname</a>(3).
<tt>host</tt> can be a domain name or the presentation format of an
address.
</p>
<p>
Returns an array of information similar to that found in a +struct
hostent+:
</p>
<pre>
  - cannonical name: the cannonical name for host in the DNS, or a
    string representing the address
  - aliases: an array of aliases for the canonical name, there may be no aliases
  - address family: usually one of Socket::AF_INET or Socket::AF_INET6
  - address: a string, the binary value of the +struct sockaddr+ for this name, in
    the indicated address family
  - ...: if there are multiple addresses for this host,  a series of
    strings/+struct sockaddr+s may follow, not all necessarily in the same
    address family. Note that the fact that they may not be all in the same
    address family is a departure from the behaviour of gethostbyname(3).
</pre>
<p>
Note: I believe that the fact that the multiple addresses returned are not
necessarily in the same address family may be a bug, since if this function
actually called <a href="Socket.html#M002099">gethostbyname</a>(3), ALL the
addresses returned in the trailing address list (h_addr_list from struct
hostent) would be of the same address family! Examples from my system, OS X
10.3:
</p>
<pre>
  [&quot;localhost&quot;, [], 30, &quot;\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001&quot;, &quot;\177\000\000\001&quot;]
    and
  [&quot;ensemble.local&quot;, [], 30, &quot;\376\200\000\004\000\000\000\000\002\003\223\377\376\255\010\214&quot;, &quot;\300\250{\232&quot; ]
</pre>
<p>
Similar information can be returned by <a
href="Socket.html#M002101">Socket.getaddrinfo</a> if called as:
</p>
<pre>
   Socket.getaddrinfo(+host+, 0, Socket::AF_UNSPEC, Socket::SOCK_STREAM, nil, Socket::AI_CANONNAME)
</pre>
<h2>Examples</h2>
<pre>
  Socket.gethostbyname &quot;example.com&quot;
  =&gt; [&quot;example.com&quot;, [], 2, &quot;\300\000\&quot;\246&quot;]
</pre>
<p>
This name has no DNS aliases, and a single IPv4 address.
</p>
<pre>
  Socket.gethostbyname &quot;smtp.telus.net&quot;
  =&gt; [&quot;smtp.svc.telus.net&quot;, [&quot;smtp.telus.net&quot;], 2, &quot;\307\271\334\371&quot;]
</pre>
<p>
This name is an an alias so the canonical name is returned, as well as the
alias and a single IPv4 address.
</p>
<pre>
  Socket.gethostbyname &quot;localhost&quot;
  =&gt; [&quot;localhost&quot;, [], 30, &quot;\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001&quot;, &quot;\177\000\000\001&quot;]
</pre>
<p>
This machine has no aliases, returns an IPv6 address, and has an additional
IPv4 address.
</p>
<p>
<tt>host</tt> can also be an IP address in presentation format, in which
case a reverse lookup is done on the address:
</p>
<pre>
  Socket.gethostbyname(&quot;127.0.0.1&quot;)
  =&gt; [&quot;localhost&quot;, [], 2, &quot;\177\000\000\001&quot;]

  Socket.gethostbyname(&quot;192.0.34.166&quot;)
  =&gt; [&quot;www.example.com&quot;, [], 2, &quot;\300\000\&quot;\246&quot;]
</pre>
<h2>See</h2>
<p>
See: <a href="Socket.html#M002101">Socket.getaddrinfo</a>
</p>
        </div>
      </div>

      <div id="method-M002100" class="method-detail">
        <a name="M002100"></a>

        <div class="method-heading">
          <a href="Socket.src/M002100.html" target="Code" class="method-signature"
            onclick="popupCode('Socket.src/M002100.html');return false;">
          <span class="method-name"> Socket.getservbyname(name, proto="tcp") => port<br />
</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
<tt>name</tt> is a service name (&quot;ftp&quot;, &quot;telnet&quot;,
&#8230;) and proto is a protocol name (&quot;udp&quot;, &quot;tcp&quot;,
&#8230;). &#8217;/etc/services&#8217; (or your system&#8216;s equivalent)
is searched for a service for <tt>name</tt> and <tt>proto</tt>, and the
port number is returned.
</p>
<p>
Note that unlike <a href="Socket.html#M002101">Socket.getaddrinfo</a>,
<tt>proto</tt> may not be specified using the Socket::SOCK_* constants, a
string must must be used.
</p>
        </div>
      </div>

      <h3 class="section-bar">Public Instance methods</h3>

      <div id="method-M002094" class="method-detail">
        <a name="M002094"></a>

        <div class="method-heading">
          <a href="Socket.src/M002094.html" target="Code" class="method-signature"
            onclick="popupCode('Socket.src/M002094.html');return false;">
          <span class="method-name">socket.accept => [ socket, string ]<br />
</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Accepts an incoming connection returning an array containing a new <a
href="Socket.html">Socket</a> object and a string holding the
<tt>struct</tt> sockaddr information about the caller.
</p>
<h3>Example</h3>
<pre>
     # In one script, start this first
     require 'socket'
     include Socket::Constants
     socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
     sockaddr = Socket.pack_sockaddr_in( 2200, 'localhost' )
     socket.bind( sockaddr )
     socket.listen( 5 )
     client, client_sockaddr = socket.accept
     puts &quot;The client said, '#{client.readline.chomp}'&quot;
     client.puts &quot;Hello from script one!&quot;
     socket.close

     # In another script, start this second
     require 'socket'
     include Socket::Constants
     socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
     sockaddr = Socket.pack_sockaddr_in( 2200, 'localhost' )
     socket.connect( sockaddr )
     socket.puts &quot;Hello from script 2.&quot;
     puts &quot;The server said, '#{socket.readline.chomp}'&quot;
     socket.close
</pre>
<h3>Unix-based Exceptions</h3>
<p>
On unix-based based systems the following system exceptions may be raised
if the call to <em><a href="Socket.html#M002094">accept</a></em> fails:
</p>
<ul>
<li>Errno::EAGAIN - O_NONBLOCK is set for the <tt>socket</tt> file descriptor
and no connections are parent to be accepted

</li>
<li>Errno::EWOULDBLOCK - same as Errno::EAGAIN

</li>
<li>Errno::EBADF - the <tt>socket</tt> is not a valid file descriptor

</li>
<li><a href="Errno/ECONNABORTED.html">Errno::ECONNABORTED</a> - a connection
has been aborted

</li>
<li>Errno::EFAULT - the socket&#8216;s internal address or address length
parameter cannot be access or written

</li>
<li>Errno::EINTR - the <em><a href="Socket.html#M002094">accept</a></em> method
was interrupted by a signal that was caught before a valid connection
arrived

</li>
<li>Errno::EINVAL - the <tt>socket</tt> is not accepting connections

</li>
<li>Errno::EMFILE - OPEN_MAX file descriptors are currently open in the calling
process

</li>
<li>Errno::ENOBUFS - no buffer space is available

</li>
<li>Errno::ENOMEM - there was insufficient memory available to complete the
operation

</li>
<li>Errno::ENOSR - there was insufficient STREAMS resources available to
complete the operation

</li>
<li>Errno::ENFILE - the maximum number of file descriptors in the system are
already open

</li>
<li>Errno::ENOTSOCK - the <tt>socket</tt> does not refer to a socket

</li>
<li>Errno::EOPNOTSUPP - the socket type for the calling <tt>socket</tt> does
not support <a href="Socket.html#M002094">accept</a> connections

</li>
<li><a href="Errno/EPROTO.html">Errno::EPROTO</a> - a protocol error has
occurred

</li>
</ul>
<h3>Windows Exceptions</h3>
<p>
On Windows systems the following system exceptions may be raised if the
call to <em><a href="Socket.html#M002094">accept</a></em> fails:
</p>
<ul>
<li><a href="Errno/ECONNRESET.html">Errno::ECONNRESET</a> - an incoming
connection was indicated, but was terminated by the remote peer prior to
accepting the connection

</li>
<li>Errno::EFAULT - the socket&#8216;s internal address or address length
parameter is too small or is not a valid part of the user space address

</li>
<li>Errno::EINVAL - the <em><a href="Socket.html#M002093">listen</a></em>
method was not invoked prior to calling <em><a
href="Socket.html#M002094">accept</a></em>

</li>
<li>Errno::EINPROGRESS - a blocking Windows Sockets 1.1 call is in progress or
the service provider is still processing a callback function

</li>
<li>Errno::EMFILE - the queue is not empty, upong etry to <em><a
href="Socket.html#M002094">accept</a></em> and there are no socket
descriptors available

</li>
<li>Errno::ENETDOWN - the network is down

</li>
<li>Errno::ENOBUFS - no buffer space is available

</li>
<li>Errno::ENOTSOCK - <tt>socket</tt> is not a socket

</li>
<li>Errno::EOPNOTSUPP - <tt>socket</tt> is not a type that supports
connection-oriented service.

</li>
<li>Errno::EWOULDBLOCK - <tt>socket</tt> is marked as nonblocking and no
connections are present to be accepted

</li>
</ul>
<h3>See</h3>
<ul>
<li><a href="Socket.html#M002094">accept</a> manual pages on unix-based systems

</li>
<li><a href="Socket.html#M002094">accept</a> function in Microsoft&#8216;s
Winsock functions reference

</li>
</ul>
        </div>
      </div>

      <div id="method-M002095" class="method-detail">
        <a name="M002095"></a>

        <div class="method-heading">
          <a href="Socket.src/M002095.html" target="Code" class="method-signature"
            onclick="popupCode('Socket.src/M002095.html');return false;">
          <span class="method-name">socket.accept_nonblock => [client_socket, client_sockaddr]<br />
</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Accepts an incoming connection using <a
href="Socket.html#M002094">accept</a>(2) after O_NONBLOCK is set for the
underlying file descriptor. It returns an array containg the accpeted
socket for the incoming connection, <em>client_socket</em>, and a string
that contains the <tt>struct</tt> sockaddr information about the caller,
<em>client_sockaddr</em>.
</p>
<h3>Example</h3>
<pre>
     # In one script, start this first
     require 'socket'
     include Socket::Constants
     socket = Socket.new(AF_INET, SOCK_STREAM, 0)
     sockaddr = Socket.sockaddr_in(2200, 'localhost')
     socket.bind(sockaddr)
     socket.listen(5)
     begin
       client_socket, client_sockaddr = socket.accept_nonblock
     rescue Errno::EAGAIN, Errno::ECONNABORTED, Errno::EPROTO, Errno::EINTR
       IO.select([socket])
       retry
     end
     puts &quot;The client said, '#{client_socket.readline.chomp}'&quot;
     client_socket.puts &quot;Hello from script one!&quot;
     socket.close

     # In another script, start this second
     require 'socket'
     include Socket::Constants
     socket = Socket.new(AF_INET, SOCK_STREAM, 0)
     sockaddr = Socket.sockaddr_in(2200, 'localhost')
     socket.connect(sockaddr)
     socket.puts &quot;Hello from script 2.&quot;
     puts &quot;The server said, '#{socket.readline.chomp}'&quot;
     socket.close
</pre>
<p>
Refer to <a href="Socket.html#M002094">Socket#accept</a> for the exceptions
that may be thrown if the call to <em><a
href="Socket.html#M002095">accept_nonblock</a></em> fails.
</p>
<p>
<a href="Socket.html#M002095">Socket#accept_nonblock</a> may raise any
error corresponding to <a href="Socket.html#M002094">accept</a>(2) failure,
including Errno::EAGAIN.
</p>
<h3>See</h3>
<ul>
<li><a href="Socket.html#M002094">Socket#accept</a>

</li>
</ul>
        </div>
      </div>

      <div id="method-M002092" class="method-detail">
        <a name="M002092"></a>

        <div class="method-heading">
          <a href="Socket.src/M002092.html" target="Code" class="method-signature"
            onclick="popupCode('Socket.src/M002092.html');return false;">
          <span class="method-name">socket.bind(server_sockaddr) => 0<br />
</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Binds to the given <tt>struct</tt> sockaddr.
</p>
<h3>Parameter</h3>
<ul>
<li><tt>server_sockaddr</tt> - the <tt>struct</tt> sockaddr contained in a
string

</li>
</ul>
<h3>Example</h3>
<pre>
     require 'socket'
     include Socket::Constants
     socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
     sockaddr = Socket.pack_sockaddr_in( 2200, 'localhost' )
     socket.bind( sockaddr )
</pre>
<h3>Unix-based Exceptions</h3>
<p>
On unix-based based systems the following system exceptions may be raised
if the call to <em><a href="Socket.html#M002092">bind</a></em> fails:
</p>
<ul>
<li>Errno::EACCES - the specified <em>sockaddr</em> is protected and the
current user does not have permission to <a
href="Socket.html#M002092">bind</a> to it

</li>
<li>Errno::EADDRINUSE - the specified <em>sockaddr</em> is already in use

</li>
<li>Errno::EADDRNOTAVAIL - the specified <em>sockaddr</em> is not available
from the local machine

</li>
<li>Errno::EAFNOSUPPORT - the specified <em>sockaddr</em> isnot a valid address
for the family of the calling <tt>socket</tt>

</li>
<li>Errno::EBADF - the <em>sockaddr</em> specified is not a valid file
descriptor

</li>
<li>Errno::EFAULT - the <em>sockaddr</em> argument cannot be accessed

</li>
<li>Errno::EINVAL - the <tt>socket</tt> is already bound to an address, and the
protocol does not support binding to the new <em>sockaddr</em> or the
<tt>socket</tt> has been shut down.

</li>
<li>Errno::EINVAL - the address length is not a valid length for the address
family

</li>
<li>Errno::ENAMETOOLONG - the pathname resolved had a length which exceeded
PATH_MAX

</li>
<li>Errno::ENOBUFS - no buffer space is available

</li>
<li>Errno::ENOSR - there were insufficient STREAMS resources available to
complete the operation

</li>
<li>Errno::ENOTSOCK - the <tt>socket</tt> does not refer to a socket

</li>
<li>Errno::EOPNOTSUPP - the socket type of the <tt>socket</tt> does not support
binding to an address

</li>
</ul>
<p>
On unix-based based systems if the address family of the calling
<tt>socket</tt> is Socket::AF_UNIX the follow exceptions may be raised if
the call to <em><a href="Socket.html#M002092">bind</a></em> fails:
</p>
<ul>
<li>Errno::EACCES - search permission is denied for a component of the prefix
path or write access to the <tt>socket</tt> is denided

</li>
<li>Errno::EDESTADDRREQ - the <em>sockaddr</em> argument is a null pointer

</li>
<li>Errno::EISDIR - same as Errno::EDESTADDRREQ

</li>
<li>Errno::EIO - an i/o error occurred

</li>
<li>Errno::ELOOP - too many symbolic links were encountered in translating the
pathname in <em>sockaddr</em>

</li>
<li>Errno::ENAMETOOLLONG - a component of a pathname exceeded NAME_MAX
characters, or an entired pathname exceeded PATH_MAX characters

</li>
<li>Errno::ENOENT - a component of the pathname does not name an existing file
or the pathname is an empty string

</li>
<li>Errno::ENOTDIR - a component of the path prefix of the pathname in
<em>sockaddr</em> is not a directory

</li>
<li>Errno::EROFS - the name would reside on a read only filesystem

</li>
</ul>
<h3>Windows Exceptions</h3>
<p>
On Windows systems the following system exceptions may be raised if the
call to <em><a href="Socket.html#M002092">bind</a></em> fails:
</p>
<ul>
<li>Errno::ENETDOWN&#8212; the network is down

</li>
<li>Errno::EACCES - the attempt to <a href="Socket.html#M002090">connect</a>
the datagram socket to the broadcast address failed

</li>
<li>Errno::EADDRINUSE - the socket&#8216;s local address is already in use

</li>
<li>Errno::EADDRNOTAVAIL - the specified address is not a valid address for
this computer

</li>
<li>Errno::EFAULT - the socket&#8216;s internal address or address length
parameter is too small or is not a valid part of the user space addressed

</li>
<li>Errno::EINVAL - the <tt>socket</tt> is already bound to an address

</li>
<li>Errno::ENOBUFS - no buffer space is available

</li>
<li>Errno::ENOTSOCK - the <tt>socket</tt> argument does not refer to a socket

</li>
</ul>
<h3>See</h3>
<ul>
<li><a href="Socket.html#M002092">bind</a> manual pages on unix-based systems

</li>
<li><a href="Socket.html#M002092">bind</a> function in Microsoft&#8216;s
Winsock functions reference

</li>
</ul>
        </div>
      </div>

      <div id="method-M002090" class="method-detail">
        <a name="M002090"></a>

        <div class="method-heading">
          <a href="Socket.src/M002090.html" target="Code" class="method-signature"
            onclick="popupCode('Socket.src/M002090.html');return false;">
          <span class="method-name">socket.connect(server_sockaddr) => 0<br />
</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Requests a connection to be made on the given <tt>server_sockaddr</tt>.
Returns 0 if successful, otherwise an exception is raised.
</p>
<h3>Parameter</h3>
<ul>
<li><tt>server_sockaddr</tt> - the <tt>struct</tt> sockaddr contained in a
string

</li>
</ul>
<h3>Example:</h3>
<pre>
     # Pull down Google's web page
     require 'socket'
     include Socket::Constants
     socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
     sockaddr = Socket.pack_sockaddr_in( 80, 'www.google.com' )
     socket.connect( sockaddr )
     socket.write( &quot;GET / HTTP/1.0\r\n\r\n&quot; )
     results = socket.read
</pre>
<h3>Unix-based Exceptions</h3>
<p>
On unix-based systems the following system exceptions may be raised if the
call to <em><a href="Socket.html#M002090">connect</a></em> fails:
</p>
<ul>
<li>Errno::EACCES - search permission is denied for a component of the prefix
path or write access to the <tt>socket</tt> is denided

</li>
<li>Errno::EADDRINUSE - the <em>sockaddr</em> is already in use

</li>
<li>Errno::EADDRNOTAVAIL - the specified <em>sockaddr</em> is not available
from the local machine

</li>
<li>Errno::EAFNOSUPPORT - the specified <em>sockaddr</em> is not a valid
address for the address family of the specified <tt>socket</tt>

</li>
<li>Errno::EALREADY - a connection is already in progress for the specified
socket

</li>
<li>Errno::EBADF - the <tt>socket</tt> is not a valid file descriptor

</li>
<li>Errno::ECONNREFUSED - the target <em>sockaddr</em> was not listening for
connections refused the connection request

</li>
<li><a href="Errno/ECONNRESET.html">Errno::ECONNRESET</a> - the remote host
reset the connection request

</li>
<li>Errno::EFAULT - the <em>sockaddr</em> cannot be accessed

</li>
<li>Errno::EHOSTUNREACH - the destination host cannot be reached (probably
because the host is down or a remote router cannot reach it)

</li>
<li>Errno::EINPROGRESS - the O_NONBLOCK is set for the <tt>socket</tt> and the
connection cnanot be immediately established; the connection will be
established asynchronously

</li>
<li>Errno::EINTR - the attempt to establish the connection was interrupted by
delivery of a signal that was caught; the connection will be established
asynchronously

</li>
<li>Errno::EISCONN - the specified <tt>socket</tt> is already connected

</li>
<li>Errno::EINVAL - the address length used for the <em>sockaddr</em> is not a
valid length for the address family or there is an invalid family in
<em>sockaddr</em>

</li>
<li>Errno::ENAMETOOLONG - the pathname resolved had a length which exceeded
PATH_MAX

</li>
<li>Errno::ENETDOWN - the local interface used to reach the destination is down

</li>
<li>Errno::ENETUNREACH - no route to the network is present

</li>
<li>Errno::ENOBUFS - no buffer space is available

</li>
<li>Errno::ENOSR - there were insufficient STREAMS resources available to
complete the operation

</li>
<li>Errno::ENOTSOCK - the <tt>socket</tt> argument does not refer to a socket

</li>
<li>Errno::EOPNOTSUPP - the calling <tt>socket</tt> is listening and cannot be
connected

</li>
<li>Errno::EPROTOTYPE - the <em>sockaddr</em> has a different type than the
socket bound to the specified peer address

</li>
<li>Errno::ETIMEDOUT - the attempt to <a href="Socket.html#M002090">connect</a>
time out before a connection was made.

</li>
</ul>
<p>
On unix-based systems if the address family of the calling <tt>socket</tt>
is AF_UNIX the follow exceptions may be raised if the call to <em><a
href="Socket.html#M002090">connect</a></em> fails:
</p>
<ul>
<li>Errno::EIO - an i/o error occured while reading from or writing to the file
system

</li>
<li>Errno::ELOOP - too many symbolic links were encountered in translating the
pathname in <em>sockaddr</em>

</li>
<li>Errno::ENAMETOOLLONG - a component of a pathname exceeded NAME_MAX
characters, or an entired pathname exceeded PATH_MAX characters

</li>
<li>Errno::ENOENT - a component of the pathname does not name an existing file
or the pathname is an empty string

</li>
<li>Errno::ENOTDIR - a component of the path prefix of the pathname in
<em>sockaddr</em> is not a directory

</li>
</ul>
<h3>Windows Exceptions</h3>
<p>
On Windows systems the following system exceptions may be raised if the
call to <em><a href="Socket.html#M002090">connect</a></em> fails:
</p>
<ul>
<li>Errno::ENETDOWN - the network is down

</li>
<li>Errno::EADDRINUSE - the socket&#8216;s local address is already in use

</li>
<li>Errno::EINTR - the socket was cancelled

</li>
<li>Errno::EINPROGRESS - a blocking socket is in progress or the service
provider is still processing a callback function. Or a nonblocking <a
href="Socket.html#M002090">connect</a> call is in progress on the
<tt>socket</tt>.

</li>
<li>Errno::EALREADY - see Errno::EINVAL

</li>
<li>Errno::EADDRNOTAVAIL - the remote address is not a valid address, such as
ADDR_ANY TODO check ADDRANY TO INADDR_ANY

</li>
<li>Errno::EAFNOSUPPORT - addresses in the specified family cannot be used with
with this <tt>socket</tt>

</li>
<li>Errno::ECONNREFUSED - the target <em>sockaddr</em> was not listening for
connections refused the connection request

</li>
<li>Errno::EFAULT - the socket&#8216;s internal address or address length
parameter is too small or is not a valid part of the user space address

</li>
<li>Errno::EINVAL - the <tt>socket</tt> is a listening socket

</li>
<li>Errno::EISCONN - the <tt>socket</tt> is already connected

</li>
<li>Errno::ENETUNREACH - the network cannot be reached from this host at this
time

</li>
<li>Errno::EHOSTUNREACH - no route to the network is present

</li>
<li>Errno::ENOBUFS - no buffer space is available

</li>
<li>Errno::ENOTSOCK - the <tt>socket</tt> argument does not refer to a socket

</li>
<li>Errno::ETIMEDOUT - the attempt to <a href="Socket.html#M002090">connect</a>
time out before a connection was made.

</li>
<li>Errno::EWOULDBLOCK - the socket is marked as nonblocking and the connection
cannot be completed immediately

</li>
<li>Errno::EACCES - the attempt to <a href="Socket.html#M002090">connect</a>
the datagram socket to the broadcast address failed

</li>
</ul>
<h3>See</h3>
<ul>
<li><a href="Socket.html#M002090">connect</a> manual pages on unix-based
systems

</li>
<li><a href="Socket.html#M002090">connect</a> function in Microsoft&#8216;s
Winsock functions reference

</li>
</ul>
        </div>
      </div>

      <div id="method-M002091" class="method-detail">
        <a name="M002091"></a>

        <div class="method-heading">
          <a href="Socket.src/M002091.html" target="Code" class="method-signature"
            onclick="popupCode('Socket.src/M002091.html');return false;">
          <span class="method-name">socket.connect_nonblock(server_sockaddr) => 0<br />
</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Requests a connection to be made on the given <tt>server_sockaddr</tt>
after O_NONBLOCK is set for the underlying file descriptor. Returns 0 if
successful, otherwise an exception is raised.
</p>
<h3>Parameter</h3>
<ul>
<li><tt>server_sockaddr</tt> - the <tt>struct</tt> sockaddr contained in a
string

</li>
</ul>
<h3>Example:</h3>
<pre>
     # Pull down Google's web page
     require 'socket'
     include Socket::Constants
     socket = Socket.new(AF_INET, SOCK_STREAM, 0)
     sockaddr = Socket.sockaddr_in(80, 'www.google.com')
     begin
       socket.connect_nonblock(sockaddr)
     rescue Errno::EINPROGRESS
       IO.select(nil, [socket])
       begin
         socket.connect_nonblock(sockaddr)
       rescue Errno::EISCONN
       end
     end
     socket.write(&quot;GET / HTTP/1.0\r\n\r\n&quot;)
     results = socket.read
</pre>
<p>
Refer to <a href="Socket.html#M002090">Socket#connect</a> for the
exceptions that may be thrown if the call to <em><a
href="Socket.html#M002091">connect_nonblock</a></em> fails.
</p>
<p>
<a href="Socket.html#M002091">Socket#connect_nonblock</a> may raise any
error corresponding to <a href="Socket.html#M002090">connect</a>(2)
failure, including Errno::EINPROGRESS.
</p>
<h3>See</h3>
<ul>
<li><a href="Socket.html#M002090">Socket#connect</a>

</li>
</ul>
        </div>
      </div>

      <div id="method-M002093" class="method-detail">
        <a name="M002093"></a>

        <div class="method-heading">
          <a href="Socket.src/M002093.html" target="Code" class="method-signature"
            onclick="popupCode('Socket.src/M002093.html');return false;">
          <span class="method-name">socket.listen( int ) => 0<br />
</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Listens for connections, using the specified <tt>int</tt> as the backlog. A
call to <em><a href="Socket.html#M002093">listen</a></em> only applies if
the <tt>socket</tt> is of type SOCK_STREAM or SOCK_SEQPACKET.
</p>
<h3>Parameter</h3>
<ul>
<li><tt>backlog</tt> - the maximum length of the queue for pending connections.

</li>
</ul>
<h3>Example 1</h3>
<pre>
     require 'socket'
     include Socket::Constants
     socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
     sockaddr = Socket.pack_sockaddr_in( 2200, 'localhost' )
     socket.bind( sockaddr )
     socket.listen( 5 )
</pre>
<h3>Example 2 (listening on an arbitary port, unix-based systems only):</h3>
<pre>
     require 'socket'
     include Socket::Constants
     socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
     socket.listen( 1 )
</pre>
<h3>Unix-based Exceptions</h3>
<p>
On unix based systems the above will work because a new <tt>sockaddr</tt>
struct is created on the address ADDR_ANY, for an arbitrary port number as
handed off by the kernel. It will not work on Windows, because Windows
requires that the <tt>socket</tt> is bound by calling <em><a
href="Socket.html#M002092">bind</a></em> before it can <em><a
href="Socket.html#M002093">listen</a></em>.
</p>
<p>
If the <em>backlog</em> amount exceeds the implementation-dependent maximum
queue length, the implementation&#8216;s maximum queue length will be used.
</p>
<p>
On unix-based based systems the following system exceptions may be raised
if the call to <em><a href="Socket.html#M002093">listen</a></em> fails:
</p>
<ul>
<li>Errno::EBADF - the <em>socket</em> argument is not a valid file descriptor

</li>
<li>Errno::EDESTADDRREQ - the <em>socket</em> is not bound to a local address,
and the protocol does not support listening on an unbound socket

</li>
<li>Errno::EINVAL - the <em>socket</em> is already connected

</li>
<li>Errno::ENOTSOCK - the <em>socket</em> argument does not refer to a socket

</li>
<li>Errno::EOPNOTSUPP - the <em>socket</em> protocol does not support <a
href="Socket.html#M002093">listen</a>

</li>
<li>Errno::EACCES - the calling process does not have approriate privileges

</li>
<li>Errno::EINVAL - the <em>socket</em> has been shut down

</li>
<li>Errno::ENOBUFS - insufficient resources are available in the system to
complete the call

</li>
</ul>
<h3>Windows Exceptions</h3>
<p>
On Windows systems the following system exceptions may be raised if the
call to <em><a href="Socket.html#M002093">listen</a></em> fails:
</p>
<ul>
<li>Errno::ENETDOWN - the network is down

</li>
<li>Errno::EADDRINUSE - the socket&#8216;s local address is already in use.
This usually occurs during the execution of <em><a
href="Socket.html#M002092">bind</a></em> but could be delayed if the call
to <em><a href="Socket.html#M002092">bind</a></em> was to a partially
wildcard address (involving ADDR_ANY) and if a specific address needs to be
commmitted at the time of the call to <em><a
href="Socket.html#M002093">listen</a></em>

</li>
<li>Errno::EINPROGRESS - a Windows Sockets 1.1 call is in progress or the
service provider is still processing a callback function

</li>
<li>Errno::EINVAL - the <tt>socket</tt> has not been bound with a call to
<em><a href="Socket.html#M002092">bind</a></em>.

</li>
<li>Errno::EISCONN - the <tt>socket</tt> is already connected

</li>
<li>Errno::EMFILE - no more socket descriptors are available

</li>
<li>Errno::ENOBUFS - no buffer space is available

</li>
<li>Errno::ENOTSOC - <tt>socket</tt> is not a socket

</li>
<li>Errno::EOPNOTSUPP - the referenced <tt>socket</tt> is not a type that
supports the <em><a href="Socket.html#M002093">listen</a></em> method

</li>
</ul>
<h3>See</h3>
<ul>
<li><a href="Socket.html#M002093">listen</a> manual pages on unix-based systems

</li>
<li><a href="Socket.html#M002093">listen</a> function in Microsoft&#8216;s
Winsock functions reference

</li>
</ul>
        </div>
      </div>

      <div id="method-M002097" class="method-detail">
        <a name="M002097"></a>

        <div class="method-heading">
          <a href="Socket.src/M002097.html" target="Code" class="method-signature"
            onclick="popupCode('Socket.src/M002097.html');return false;">
          <span class="method-name">socket.recvfrom(maxlen) => [mesg, sender_sockaddr]<br />
socket.recvfrom(maxlen, flags) => [mesg, sender_sockaddr]<br />
</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Receives up to <em>maxlen</em> bytes from <tt>socket</tt>. <em>flags</em>
is zero or more of the <tt>MSG_</tt> options. The first element of the
results, <em>mesg</em>, is the data received. The second element,
<em>sender_sockaddr</em>, contains protocol-specific information on the
sender.
</p>
<h3>Parameters</h3>
<ul>
<li><tt>maxlen</tt> - the number of bytes to receive from the socket

</li>
<li><tt>flags</tt> - zero or more of the <tt>MSG_</tt> options

</li>
</ul>
<h3>Example</h3>
<pre>
     # In one file, start this first
     require 'socket'
     include Socket::Constants
     socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
     sockaddr = Socket.pack_sockaddr_in( 2200, 'localhost' )
     socket.bind( sockaddr )
     socket.listen( 5 )
     client, client_sockaddr = socket.accept
     data = client.recvfrom( 20 )[0].chomp
     puts &quot;I only received 20 bytes '#{data}'&quot;
     sleep 1
     socket.close

     # In another file, start this second
     require 'socket'
     include Socket::Constants
     socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
     sockaddr = Socket.pack_sockaddr_in( 2200, 'localhost' )
     socket.connect( sockaddr )
     socket.puts &quot;Watch this get cut short!&quot;
     socket.close
</pre>
<h3>Unix-based Exceptions</h3>
<p>
On unix-based based systems the following system exceptions may be raised
if the call to <em><a href="Socket.html#M002097">recvfrom</a></em> fails:
</p>
<ul>
<li>Errno::EAGAIN - the <tt>socket</tt> file descriptor is marked as O_NONBLOCK
and no data is waiting to be received; or MSG_OOB is set and no out-of-band
data is available and either the <tt>socket</tt> file descriptor is marked
as O_NONBLOCK or the <tt>socket</tt> does not support blocking to wait for
out-of-band-data

</li>
<li>Errno::EWOULDBLOCK - see Errno::EAGAIN

</li>
<li>Errno::EBADF - the <tt>socket</tt> is not a valid file descriptor

</li>
<li><a href="Errno/ECONNRESET.html">Errno::ECONNRESET</a> - a connection was
forcibly closed by a peer

</li>
<li>Errno::EFAULT - the socket&#8216;s internal buffer, address or address
length cannot be accessed or written

</li>
<li>Errno::EINTR - a signal interupted <em><a
href="Socket.html#M002097">recvfrom</a></em> before any data was available

</li>
<li>Errno::EINVAL - the MSG_OOB flag is set and no out-of-band data is
available

</li>
<li>Errno::EIO - an i/o error occurred while reading from or writing to the
filesystem

</li>
<li>Errno::ENOBUFS - insufficient resources were available in the system to
perform the operation

</li>
<li>Errno::ENOMEM - insufficient memory was available to fulfill the request

</li>
<li>Errno::ENOSR - there were insufficient STREAMS resources available to
complete the operation

</li>
<li>Errno::ENOTCONN - a receive is attempted on a connection-mode socket that
is not connected

</li>
<li>Errno::ENOTSOCK - the <tt>socket</tt> does not refer to a socket

</li>
<li>Errno::EOPNOTSUPP - the specified flags are not supported for this socket
type

</li>
<li>Errno::ETIMEDOUT - the connection timed out during connection establishment
or due to a transmission timeout on an active connection

</li>
</ul>
<h3>Windows Exceptions</h3>
<p>
On Windows systems the following system exceptions may be raised if the
call to <em><a href="Socket.html#M002097">recvfrom</a></em> fails:
</p>
<ul>
<li>Errno::ENETDOWN - the network is down

</li>
<li>Errno::EFAULT - the internal buffer and from parameters on <tt>socket</tt>
are not part of the user address space, or the internal fromlen parameter
is too small to accomodate the peer address

</li>
<li>Errno::EINTR - the (blocking) call was cancelled by an internal call to the
WinSock function WSACancelBlockingCall

</li>
<li>Errno::EINPROGRESS - a blocking Windows Sockets 1.1 call is in progress or
the service provider is still processing a callback function

</li>
<li>Errno::EINVAL - <tt>socket</tt> has not been bound with a call to <em><a
href="Socket.html#M002092">bind</a></em>, or an unknown flag was specified,
or MSG_OOB was specified for a socket with SO_OOBINLINE enabled, or (for
byte stream-style sockets only) the internal len parameter on
<tt>socket</tt> was zero or negative

</li>
<li>Errno::EISCONN - <tt>socket</tt> is already connected. The call to <em><a
href="Socket.html#M002097">recvfrom</a></em> is not permitted with a
connected socket on a socket that is connetion oriented or connectionless.

</li>
<li>Errno::ENETRESET - the connection has been broken due to the keep-alive
activity detecting a failure while the operation was in progress.

</li>
<li>Errno::EOPNOTSUPP - MSG_OOB was specified, but <tt>socket</tt> is not
stream-style such as type SOCK_STREAM. OOB data is not supported in the
communication domain associated with <tt>socket</tt>, or <tt>socket</tt> is
unidirectional and supports only send operations

</li>
<li>Errno::ESHUTDOWN - <tt>socket</tt> has been shutdown. It is not possible to
call <em><a href="Socket.html#M002097">recvfrom</a></em> on a socket after
<em>shutdown</em> has been invoked.

</li>
<li>Errno::EWOULDBLOCK - <tt>socket</tt> is marked as nonblocking and a call to
<em><a href="Socket.html#M002097">recvfrom</a></em> would block.

</li>
<li>Errno::EMSGSIZE - the message was too large to fit into the specified
buffer and was truncated.

</li>
<li>Errno::ETIMEDOUT - the connection has been dropped, because of a network
failure or because the system on the other end went down without notice

</li>
<li><a href="Errno/ECONNRESET.html">Errno::ECONNRESET</a> - the virtual circuit
was reset by the remote side executing a hard or abortive close. The
application should close the socket; it is no longer usable. On a
UDP-datagram socket this error indicates a previous send operation resulted
in an ICMP Port Unreachable message.

</li>
</ul>
        </div>
      </div>

      <div id="method-M002098" class="method-detail">
        <a name="M002098"></a>

        <div class="method-heading">
          <a href="Socket.src/M002098.html" target="Code" class="method-signature"
            onclick="popupCode('Socket.src/M002098.html');return false;">
          <span class="method-name">socket.recvfrom_nonblock(maxlen) => [mesg, sender_sockaddr]<br />
socket.recvfrom_nonblock(maxlen, flags) => [mesg, sender_sockaddr]<br />
</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Receives up to <em>maxlen</em> bytes from <tt>socket</tt> using <a
href="Socket.html#M002097">recvfrom</a>(2) after O_NONBLOCK is set for the
underlying file descriptor. <em>flags</em> is zero or more of the
<tt>MSG_</tt> options. The first element of the results, <em>mesg</em>, is
the data received. The second element, <em>sender_sockaddr</em>, contains
protocol-specific information on the sender.
</p>
<p>
When <a href="Socket.html#M002097">recvfrom</a>(2) returns 0, <a
href="Socket.html#M002098">Socket#recvfrom_nonblock</a> returns an empty
string as data. The meaning depends on the socket: EOF on TCP, empty packet
on UDP, etc.
</p>
<h3>Parameters</h3>
<ul>
<li><tt>maxlen</tt> - the number of bytes to receive from the socket

</li>
<li><tt>flags</tt> - zero or more of the <tt>MSG_</tt> options

</li>
</ul>
<h3>Example</h3>
<pre>
     # In one file, start this first
     require 'socket'
     include Socket::Constants
     socket = Socket.new(AF_INET, SOCK_STREAM, 0)
     sockaddr = Socket.sockaddr_in(2200, 'localhost')
     socket.bind(sockaddr)
     socket.listen(5)
     client, client_sockaddr = socket.accept
     begin
       pair = client.recvfrom_nonblock(20)
     rescue Errno::EAGAIN
       IO.select([client])
       retry
     end
     data = pair[0].chomp
     puts &quot;I only received 20 bytes '#{data}'&quot;
     sleep 1
     socket.close

     # In another file, start this second
     require 'socket'
     include Socket::Constants
     socket = Socket.new(AF_INET, SOCK_STREAM, 0)
     sockaddr = Socket.sockaddr_in(2200, 'localhost')
     socket.connect(sockaddr)
     socket.puts &quot;Watch this get cut short!&quot;
     socket.close
</pre>
<p>
Refer to <a href="Socket.html#M002097">Socket#recvfrom</a> for the
exceptions that may be thrown if the call to <em><a
href="Socket.html#M002098">recvfrom_nonblock</a></em> fails.
</p>
<p>
<a href="Socket.html#M002098">Socket#recvfrom_nonblock</a> may raise any
error corresponding to <a href="Socket.html#M002097">recvfrom</a>(2)
failure, including Errno::EAGAIN.
</p>
<h3>See</h3>
<ul>
<li><a href="Socket.html#M002097">Socket#recvfrom</a>

</li>
</ul>
        </div>
      </div>

      <div id="method-M002096" class="method-detail">
        <a name="M002096"></a>

        <div class="method-heading">
          <a href="Socket.src/M002096.html" target="Code" class="method-signature"
            onclick="popupCode('Socket.src/M002096.html');return false;">
          <span class="method-name">socket.sysaccept => [client_socket_fd, client_sockaddr]<br />
</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Accepts an incoming connection returnings an array containg the (integer)
file descriptor for the incoming connection, <em>client_socket_fd</em>, and
a string that contains the <tt>struct</tt> sockaddr information about the
caller, <em>client_sockaddr</em>.
</p>
<h3>Example</h3>
<pre>
     # In one script, start this first
     require 'socket'
     include Socket::Constants
     socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
     sockaddr = Socket.pack_sockaddr_in( 2200, 'localhost' )
     socket.bind( sockaddr )
     socket.listen( 5 )
     client_fd, client_sockaddr = socket.sysaccept
     client_socket = Socket.for_fd( client_fd )
     puts &quot;The client said, '#{client_socket.readline.chomp}'&quot;
     client_socket.puts &quot;Hello from script one!&quot;
     socket.close

     # In another script, start this second
     require 'socket'
     include Socket::Constants
     socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
     sockaddr = Socket.pack_sockaddr_in( 2200, 'localhost' )
     socket.connect( sockaddr )
     socket.puts &quot;Hello from script 2.&quot;
     puts &quot;The server said, '#{socket.readline.chomp}'&quot;
     socket.close
</pre>
<p>
Refer to <a href="Socket.html#M002094">Socket#accept</a> for the exceptions
that may be thrown if the call to <em><a
href="Socket.html#M002096">sysaccept</a></em> fails.
</p>
<h3>See</h3>
<ul>
<li><a href="Socket.html#M002094">Socket#accept</a>

</li>
</ul>
        </div>
      </div>


    </div>


  </div>


<div id="validator-badges">
  <p><small><a href="http://validator.w3.org/check/referer">[Validate]</a></small></p>
</div>

<div style="font-size: smaller; text-align:center" id="credits">
 <!-- 2 --><p> <a href="http://www.ruby-doc.org">ruby-doc.org</a> is a service of <a href="http://www.jamesbritt.com">James Britt</a> and <a href="http://www.neurogami.com">Neurogami</a>, a <a href="http://www.neurogami.com"> Ruby application development company in Phoenix, AZ</a>. </p>
  <p><span>Documentation content on <a href="http://ruby-doc.org">ruby-doc.org</a> is provided by </span><a href="http://www.ruby-doc.org/about">remarkable members</a> of the Ruby community.</p>
  <p>For more information on the Ruby programming language, visit <a href="http://www.ruby-lang.org">ruby-lang.org</a>.</p>
  <p>Want to help improve Ruby's API docs? See <a href="/documentation-guidelines.html"> Ruby Documentation Guidelines</a>.</p>
  </div>



</body>
</html>